---
title: dyld 和动态链接
date: 2018-06-28 17:46:31
tags: 
---

代码从写完到编译到运行之间发生了什么？我们的程序是如何在设备上执行的？为什么我们代码中没有的库函数也能执行？在工作中我们可能常常会疑惑这样的问题，下面我们来探究一下这些问题。在阅读本文之前，需要充分了解进程的概念：[并发编程之进程](https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/)。

### 一、编译

编译是一个很复杂的过程，往往也是检验我们代码正确与否的第一步，编译器会帮助我们做很多很多很多事，比如，语法分析、词法分析、类型检查、预处理、生成中间代码等等，本文着重介绍链接，所以关于编译的过程也不会展开太多。那么，点了编译器的编译按钮后，编译器主要做了什么工作呢？

- 源程序分析。语法分析、词法分析、语义分析、类型检查等等，这一阶段的目标是主要是检查代码有没有错误，就像我们常见的 `error` 和 `warning` 就是这个阶段确定的。

- 预处理。预处理器会展开所有导入的头文件和替换宏定义，预处理后生成 `*.i` 文件。

- 编译。编译器将 `*.i` 文件编译成 ASCII 汇编语言文件 `*.s`。

- 汇编。汇编器将 `*.s` 文件汇编成一个可重定位的二进制目标文件`*.o`。

- 链接。链接分为动态链接和静态链接，链接器将所有的目标文件和系统目标文件组合起来，生成能在机器上运行的可执行文件。iOS 中为 `.ipa`，Windows 中为 `.exe`，Android 中为 `.apk` 等等。

例如两段 c 代码：
```c
// mian.c
#include <stdio.h>
#include "sum.h"

int main(int argc, const char * argv[]) {
    
    int arr[2] = {1, 2};
    sum(arr, 2);
    return 0;
}
```

```c
// sum.h
int sum(int *a, int n);
// sum.c
int sum(int *a, int n) {
    
    int sum = 0;
    
    for (int i = 0; i < n; ++i) {
        sum += a[i];
    }
    
    return sum;
}
```

此时，它们的编译过程为：

![](https://upload-images.jianshu.io/upload_images/5314152-076779743e52d486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`sum.c` 和 `main.c` 源文件分别被单独编译成目标文件，然后经过链接器链接成可执行文件。

### 二、链接

链接就是上面的例子那样，将若干个目标文件组合成单一可执行文件的过程，这个文件被加载到内存中并执行。链接发生的时机可能为：编译时（源代码被翻译成机器代码时），加载时（程序被加载到内存中时），运行时。

在 iOS 开发中，我们会经常用到 cocoapod，或者引入一些第三方的 sdk，例如，`*.a`，`*.framework` 等等。这些就是可以独立编译成目标文件的动态库和静态库。

#### 2.1 静态链接

如上述例子即为静态链接，在程序加载进内存之前就完成两个目标文件的链接工作。我们知道目标文件是机器可识别的二进制文件，编译的时候就会确定指令和数据的内存布局。当 `main.o` 和 `sum.o` 被汇编器汇编成机器码时，就会完成指令和数据的内存分配。

目标文件也是由一系列不间断的字节序列组成，这些字节序列包括：`.text`（指令集）、`.rodata`（只读数据）、`.data`（已初始化的全局和静态变量）、`.bss`（未初始化的全局和静态变量）、`.symtab`（符号表）、debug 信息等等。

符号表是一个陌生的概念，上面例子中的 `sum` 即为函数 `sum()` 的符号被存储在符号表中，只有在该模块中被外部可见的符号或者 `static` 修饰的符号才会被存储在符号表中，该模块私有的符号对其他模块来说没有意义，链接器也不关心它们。 比如 `static int foo = 1`，`foo` 这个字符串是符号，符号表中每个符号都对应一个结构体，结构体中存储了该符号对应的地址。

拿上面的例子来说，编译器会展开 `sum.h` 得到 `sum()` 的声明，当编译器在 `sum.s` 中找不到该函数的实现时，就会生成一个符号条目，扔给链接器处理，如果链接器在其他模块也没找到该函数的定义，就会遇到 crash。

#### 2.2 重定向符号引用

静态链接器解析目标文件中的符号，并且重定位它们，使所有目标文件中的符号在可执行文件中有正确的位置。比如代码：

```c
int main(int argc, const char * argv[]) {
    // insert code here...   
    printf("Hello, World!\n");
    return 0;
}
```

编译器将它编译成机器代码：

```c
main.o:
(__TEXT,__text) section // __TEXT 段，__text 节
_main:
0000000000000000	pushq	%rbp
0000000000000001	movq	%rsp, %rbp
0000000000000004	leaq	0x9(%rip), %rdi
000000000000000b	callq	0x10
0000000000000010	xorl	%eax, %eax
0000000000000012	popq	%rbp
0000000000000013	retq
```

`callq` 指令是一个有符号偏移的跳转指令，也就是跳转到 `printf()` 函数，地址为 `0x10`（称为符号的引用），我们可以看到 `0x10` 处存放的是一个异或指令，因此汇编器会生成一个符号，存储到符号表中，交给链接器来处理（`printf()` 是 `libc.a` 静态库中的某个目标文件的函数）。

链接器会将定义 `printf()` 的目标文件将 `main.o` 链接成一个新的可执行文件：

```c
(__TEXT,__text) section // __TEXT 段，__text 节
_main:
0000000100000f76	pushq	%rbp
0000000100000f77	movq	%rsp, %rbp
0000000100000f7a	leaq	0x29(%rip), %rdi
0000000100000f81	callq	0x100000f8a
0000000100000f86	xorl	%eax, %eax
0000000100000f88	popq	%rbp
0000000100000f89	retq
```

链接之后的可执行文件中 `callq` 指令的目标地址被重定向成 `0x100000f8a`，也就是 `main()` 函数调用 `retq` 指令返回后的下一个地址。当可执行文件被加载进内存中时，`prinf()` 的指令就会被加载器分配到 `0x100000f8a` 处。

链接器使用符号表来完成符号的重定向，如果没有符号表的话，仅靠 `0x10` 这种 magic value，链接器很难知道它是属于哪个目标模块的地址。因此，符号表和符号对链接来说很重要。

#### 2.3 静态库

假如链接器将所有相关的文件打包成一个单独的文件，就被称为静态库，就像我们熟悉的 `.a` 文件。第一个例子中的代码中的 `main()` 修改为：

```c
int main(int argc, const char * argv[]) {
    
    int arr[2] = {1, 2};
    sum(arr, 2);
    printf("%d", sum);
    return 0;
}
```

则整个代码的编译过程为：

![](https://upload-images.jianshu.io/upload_images/5314152-32688dce211add4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`libc.a` 静态库中的 `printf.o` 文件被链接进可执行文件，因为链接器只会复制静态库里被应用程序引用的目标模块。

静态库的存在降低了程序的耦合性和维护成本，但是当一个系统中很多程序都在引用 `libc.a` 时，每个程序都要拷贝一份它的副本，就会造成磁盘内存的极度浪费。

#### 2.4 动态链接和动态共享库

我们在写 C 程序时，第一步要做的就是输入 `#include<stdio.h>`，在写 iOS 代码时，每个类都要导入 `CoreFoundation.h`，`stdio.h` 是 c 语言的标准输入输出库（standard input/output） `libc` 的头文件，几乎每个 c 程序都会用到。假如使用静态链接的话，每个程序都要拷贝一份。当每个程序都引入很多的标准库时，就会造成内存的极大浪费。

动态共享库（linux 中为 `*.so`）的出现就是为了解决静态库的缺陷，动态库同样也是一个目标模块，他不会被链接进任何其他目标模块，而是被加载进任意的内存地址，然后和一个加载到内存中的程序链接，这个过程称为动态链接。iOS 中的 dyld 就是一个动态链接器，负责程序之间的动态链接。

当我们将上述例子中的静态链接换成动态链接时，编译过程为：

![](https://upload-images.jianshu.io/upload_images/5314152-3bfdbe3cc310c982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

动态链接器也会重定位符号的引用，比如上面例子中的 `0x10`，动态链接器会将动态库中的符号表拷贝到内存的内存中，然后像静态链接那样重定向它们在该进程空间内的引用，就是将目标文件中的地址修改为符号在进程内存中的地址。

### 三、dyld

dyld (dynamic loader and linker) 是 iOS 和 Mac OS 系统中的动态加载器和链接器，它负责共享库的动态链接，比如 libobjc.A.dylib，Foundation.framework 等等。加载和链接是在程序启动时，`main()` 函数之前做的，dyld 主要做了什么？大致分为以下几步：

- 动态链接器自身就是一个共享目标文件，dyld 会首先将他自己加载进内存中并运行。

- 递归的向进程的内存空间中加载动态库。

- 重定向对动态库中符号的引用，完成链接工作。

- 初始化可执行文件。

- 为 `main()` 函数准备参数和环境变量（argc，argv[]，envp[]）。

- 为运行中的程序动态链接一些懒加载的符号（链接也可能发生在运行时）。

- 在一些情况下，当 `main()` 函数返回时，调用 `exit` 指令退出当前进程。

总结一下就是，当进程开始时，以 iOS 为例，就是点击了某个应用程序，dyld 会将可执行文件和它的共享库加载到内存中，将跨库 C 函数和变量引用链接到一起，然后在 `main` 函数开始执行。因此，从启动应用程序到我们写的代码开始执行，这段时间内都是 dyld 的工作。

注意：`main()` 函数执行之前，进程都是被内核管理的，直到 `main()` 函数，进程才开始运行在用户态。

#### 3.1 共享缓存

我们知道 objc 这门语言是动态特性的语言，对象的内存分配都是运行时来完成的，也就是它是一门重度依赖运行时的语言， 运行时以动态库的形式被 dyld 链接进进程内存空间。因此，所有 iOS 中的应用程序都要在启动时链接运行时库，因为 iOS 中程序所依赖的系统库不止一个，dyld 会在程序启动时链接它们，这样就会造成很大的时间和空间的开销。dyld 会通过共享缓存来优化这一点。

从上面对 dyld 的工作模式的分析，我们可以知道，每个进程的动态库都应该是不同的，因为它们分别被加载进不同的进程内存。事实上，dyld 的实现对这里进行了优化，它使用了共享缓存，共享缓存中保存了系统动态库的拷贝，大部分的系统库的加载和链接都是在程序启动前就完成的，所有的进程都会共享这部分内存，这样就可以节省了很多的启动时间和内存。共享内存是进程间通信的一种方式，可以参考我的这篇文章：[并发编程之进程](https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/)。

共享缓存解决了每个进程都要加载共享库的缺陷，dyld 的另一个工作是重定向符号表，就是上文中的第三步，在 iOS 和 Mac OS 中被称为 `selector` ，它就是 C 语言中符号的名称，例如上文中提到的 `sum`。我们可以从开源库中找到系统的动态库的符号列表：[built-in selector table](http://www.opensource.apple.com/source/objc4/objc4-371/runtime/objc-sel-table.h)，这些符号保存了函数（指令）的实际地址，dyld 需要将它们拷贝的进程内存中，然后重定向对它们的引用（类似于静态链接的重定向）。

共享缓存会自己创建一个符号表，并且更新它们的引用，这样就可以使所有的进程都共享这些动态库的符号表，不用将符号表拷贝到自己的进程空间中，节约了拷贝的时间和空间，但是 dyld 仍要将目标文件中的符号地址重定向为共享缓存中的地址。

共享缓存的优化会节省一半的程序启动时间，也能为 iOS  设备节省 1MB 的内存。该结论由 runtime 源码的维护者：Hamster Emporium 的[这篇文章](http://www.sealiesoftware.com/blog/archive/2009/09/01/objc_explain_Selector_uniquing_in_the_dyld_shared_cache.html)给出。











