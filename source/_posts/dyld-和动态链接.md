---
title: dyld 和动态链接
date: 2018-06-28 17:46:31
tags: 
---

代码从写完到编译到运行之间发生了什么？我们的程序是如何在设备上执行的？为什么我们代码中没有的库函数也能执行？在工作中我们可能常常会疑惑这样的问题，下面我们来探究一下这些问题。

### 一、编译

编译是一个很复杂的过程，往往也是检验我们代码正确与否的第一步，编译器会帮助我们做很多很多很多事，比如，语法分析、词法分析、类型检查、预处理、生成中间代码等等，本文着重介绍链接，所以关于编译的过程也不会展开太多。那么，点了编译器的编译按钮后，编译器主要做了什么工作呢？

- 源程序分析。语法分析、词法分析、语义分析、类型检查等等，这一阶段的目标是主要是检查代码有没有错误，就像我们常见的 `error` 和 `warning` 就是这个阶段确定的。

- 预处理。预处理器会展开所有导入的头文件和替换宏定义，预处理后生成 `*.i` 文件。

- 编译。编译器将 `*.i` 文件编译成 ASCII 汇编语言文件 `*.s`。

- 汇编。汇编器将 `*.s` 文件汇编成一个可重定位的二进制目标文件`*.o`。

- 链接。链接分为动态链接和静态链接，链接器将所有的目标文件和系统目标文件组合起来，生成能在机器上运行的可执行文件。iOS 中为 `.ipa`，Windows 中为 `.exe`，Android 中为 `.apk` 等等。

例如两段 c 代码：
```c
// mian.c
#include <stdio.h>
#include "sum.h"

int main(int argc, const char * argv[]) {
    
    int arr[2] = {1, 2};
    sum(arr, 2);
    return 0;
}
```

```c
// sum.h
int sum(int *a, int n);
// sum.c
int sum(int *a, int n) {
    
    int sum = 0;
    
    for (int i = 0; i < n; ++i) {
        sum += a[i];
    }
    
    return sum;
}
```

此时，它们的编译过程为：

![](https://upload-images.jianshu.io/upload_images/5314152-076779743e52d486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`sum.c` 和 `main.c` 源文件分别被单独编译成目标文件，然后经过链接器链接成可执行文件。

### 二、链接

链接就是上面的例子那样，将若干个目标文件组合成单一可执行文件的过程，这个文件被加载到内存中并执行。链接发生的时机可能为：编译时（源代码被翻译成机器代码时），加载时（程序被加载到内存中时），运行时。

在 iOS 开发中，我们会经常用到 cocoapod，或者引入一些第三方的 sdk，例如，`*.a`，`*.framework` 等等。这些就是可以独立编译成目标文件的动态库和静态库。

#### 2.1 静态链接

如上述例子即为静态链接，在程序加载进内存之前就完成两个目标文件的链接工作。我们知道目标文件是机器可识别的二进制文件，编译的时候就会确定指令和数据的内存布局。当 `main.o` 和 `sum.o` 被汇编器汇编成机器码时，就会完成指令和数据的内存分配。

目标文件也是由一系列不间断的字节序列组成，这些字节序列包括：`.text`（指令集）、`.rodata`（只读数据）、`.data`（已初始化的全局和静态变量）、`.bss`（未初始化的全局和静态变量）、`.symtab`（符号表）、debug 信息等等。

符号表是一个陌生的概念，上面例子中的 `sum` 即为函数 `sum()` 的符号被存储在符号表中，只有在该模块中被外部可见的符号或者 `static` 修饰的符号才会被存储在符号表中，该模块私有的符号对其他模块来说没有意义，链接器也不关心它们。 比如 `static int foo = 1`，`foo` 这个字符串是符号，符号表中每个符号都对应一个结构体，结构体中存储了该符号对应的地址。

拿上面的例子来说，编译器会展开 `sum.h` 得到 `sum()` 的声明，当编译器在 `sum.s` 中找不到该函数的实现时，就会生成一个符号条目，扔给链接器处理，如果链接器在其他模块也没找到该函数的定义，就会遇到 crash。

静态链接器解析目标文件中的符号，并且重定位它们，使所有目标文件中的符号在可执行文件中有正确的位置。比如代码：

```c
int main(int argc, const char * argv[]) {
    // insert code here...   
    printf("Hello, World!\n");
    return 0;
}
```

编译器将它编译成机器代码：

```c
main.o:
(__TEXT,__text) section // __TEXT 段，__text 节
_main:
0000000000000000	pushq	%rbp
0000000000000001	movq	%rsp, %rbp
0000000000000004	leaq	0x9(%rip), %rdi
000000000000000b	callq	0x10
0000000000000010	xorl	%eax, %eax
0000000000000012	popq	%rbp
0000000000000013	retq
```

`callq` 指令是一个有符号偏移的跳转指令，也就是跳转到 `printf()` 函数，地址为 `0x10`（称为符号的引用），我们可以看到 `0x10` 处存放的是一个异或指令，因此汇编器会生成一个符号，存储到符号表中，交给链接器来处理（`printf()` 是 `libc.a` 静态库中的某个目标文件的函数）。

链接器会将定义 `printf()` 的目标文件将 `main.o` 链接成一个新的可执行文件：

```c
(__TEXT,__text) section // __TEXT 段，__text 节
_main:
0000000100000f76	pushq	%rbp
0000000100000f77	movq	%rsp, %rbp
0000000100000f7a	leaq	0x29(%rip), %rdi
0000000100000f81	callq	0x100000f8a
0000000100000f86	xorl	%eax, %eax
0000000100000f88	popq	%rbp
0000000100000f89	retq
```

链接之后的可执行文件中 `callq` 指令的目标地址被重定向成 `0x100000f8a`，也就是 `main()` 函数调用 `retq` 指令返回后的下一个地址。当可执行文件被加载进内存中时，`prinf()` 的指令就会被加载器分配到 `0x100000f8a` 处。

链接器使用符号表来完成符号的重定向，如果没有符号表的话，仅靠 `0x10` 这种 magic value，链接器很难知道它是属于哪个目标模块的地址。因此，符号表和符号对链接来说很重要。

假如链接器将所有相关的文件打包成一个单独的文件，就被称为静态库，就像我们熟悉的 `.a` 文件。第一个例子中的代码中的 `main()` 修改为：

```c
int main(int argc, const char * argv[]) {
    
    int arr[2] = {1, 2};
    sum(arr, 2);
    printf("%d", sum);
    return 0;
}
```

则整个代码的编译过程为：

![](https://upload-images.jianshu.io/upload_images/5314152-32688dce211add4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`libc.a` 静态库中的 `printf.o` 文件被链接进可执行文件，因为链接器只会复制静态库里被应用程序引用的目标模块。

静态库的存在降低了程序的耦合性和维护成本，但是当一个系统中很多程序都在引用 `libc.a` 时，每个程序都要拷贝一份它的副本，就会造成磁盘内存的极度浪费。

#### 2.2 动态链接

我们在写 c 程序时，第一部要做的就是输入 `#include<stdio.h>`，在写 iOS 代码时，每个类都要导入 `CoreFoundation`，`stdio` 是 c 语言的标准输入输出库（standard input/output） `libc` 的头文件，几乎每个 c 程序都会用到，假如使用静态链接的话，每个程序都要拷贝一份，会造成内存的极大浪费，因为标准库不止一个。

动态共享库（linux 中为 `*.so`）的出现就是为了解决静态库的缺陷，动态库同样也是一个目标模块，他不会被链接进任何其他目标模块，而是被加载进任意的内存地址，然后和一个加载到内存中的程序链接，这个过程称为动态链接。iOS 中的 dyld 就是一个动态链接器，负责程序之间的动态链接。

当我们将上述例子中的静态链接换成动态链接时，编译过程为：

![](https://upload-images.jianshu.io/upload_images/5314152-3bfdbe3cc310c982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

动态链接器也会重定位符号的引用，比如上面例子中的 `0x10`，动态链接器会将这个地址重定位为动态库中该符号的内存地址。

### 三、dyld

dyld (dynamic loader and linker) 是 iOS 和 Mac OS 系统中的动态加载器和链接器，它负责共享库的动态链接，比如 `libobjc.A.dylib`，`Foundation.framework` 等等。加载和链接是在程序启动时，`main()` 函数之前做的，dyld 主要做了什么？大致分为以下几步：

- 动态链接器自身就是一个共享目标文件，dyld 会首先将他自己加载进内存中并运行。

- 递归的向进程的内存空间中加载动态库。

- 重定向对动态库中符号的引用，完成链接工作。

- 初始化可执行文件。

- 为 `main()` 函数准备参数和环境变量（argc，argv[]，envp[]）。

- 为运行中的程序动态链接一些懒加载的符号（链接也可能发生在运行时）。

- 在一些情况下，当 `main()` 函数返回时，调用 `exit` 指令退出当前进程。

由此可见，在我们的代码开始执行之前，就是从点击了手机上的应用到执行 `main()` 函数之前，也就是我们经常说的应用启动时间。当然链接只是一部分，还有加载。

未完。。







