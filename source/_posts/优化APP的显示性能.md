---
title: 优化APP的显示性能
date: 2018-07-21 16:16:16
tags: 
---

APP 的显示性能问题一直以来都是一个经久不衰的话题，特别是滚动视图、表视图的滚动流畅性等等问题。那么从我们 `new` 一个 `UIKit` 开始到它在屏幕上显示这么一个过程，CPU 和 GPU 以及显示设备是如何协同工作的呢？APP 的显示性能、帧率到底应该从哪些方面入手去优化？还是说忽略理论分析，而强行优化性能？下面我们就来讨论一下这个问题。

### 一、几个概念

#### 1、像素和分辨率

像素，通俗的来讲就是构成图像的最小单位，APP 的显示界面就是由像素组成，每个像素都会携带一个由 RGB 三原色组成的颜色信息，一个界面所有的像素和其携带的颜色信息组成我们肉眼看到的多彩的界面。分辨率就是一个界面可以显示的像素数，比如 iPhone 6 的分辨率为 750x1334，即单个 iPhone 6 界面可以显示 750x1334 个像素。分辨率的大小决定了画面的精细程度。比如：

![](http://i1.hdslb.com/bfs/archive/aafcde785dc26db2a710c2faa133b7a9bd35015e.jpg)

左侧的图片甚至可以看到一个一个的小格子（像素）。

#### 2、位图

[位图](https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%9B%BE)，在计算机术语中，它是一种数据结构，我们也可以理解为，一张由二进制表示的图像，它也是由若干个点组成，每个点会携带一个表示 RGB 三原色的数值，比如 `0xffffff` 等。

#### 3、FPS（Frame per second，帧率）

在计算机图形学、视频、动画、游戏都领域都有帧率的影子，[这个视频](https://www.bilibili.com/video/av15263885?spm_id_from=333.338.__bofqi.25)可以帮助我们很好的理解这个概念，当我们在 APP 上滚动视图时，滚动动画其实就是一帧一帧的图像组成的，只不过 CPU 让它滚动的频率过快，才形成了动画，其实视频、动画、游戏等都是相同的原理。iOS 设备的帧率是 60，也就是 CPU 会每秒刷新 60 次界面，如果不够这个数，就会丢帧，丢帧的直观感受就是小时候看 CD 机时，我们叫丢帧为卡碟，这也是界面不流畅或者卡顿的根源。

#### 4、CALayer 和 UIView

`UIView` 和 `CALayer` 都是一些被层级关系管理的矩形块，每一个视图都有一个 layer，当我们对视图做仿射变换（比如旋转、缩放），滑动、渐变等动画时，其实是操作的它的 layer，我们也可以直接对每个视图的 layer 做这些事。

`UIView` 是对 `CALayer` 的高级封装，他除了具有和 layer 相同的功能以外，还能处理手势事件。但是为什么 iOS 要基于 `UIView` 和 `CALayer` 提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在 iOS 和 Mac OS 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么 iOS 有 UIKit 和 `UIView`，但是 Mac OS 有 AppKit 和 `NSView` 的原因。他们功能上很相似，但是在实现上有着显著的区别。

 `UIView` 和 `CALayer`  之间有一个 **has a** 的关系，每一个视图都 has a layer，其实既然视图是对图层能力的扩充，那么为什么不是继承关系？这是因为 has a 比 is a 具有更好的扩展性和可维护性。

二者有相同的层级关系，父视图（父图层）、子视图（子图层），这个应该没人不知道，不再赘述。

#### 5、寄宿图

上面说，每个我们在手机屏幕上看到的内容都是由像素组成的图像，动画也是有一帧一帧的图像组成的，每个图像在经过 GPU 处理之前都是以位图的形式存储在内存中，它也被成为 `CALayer` 的寄宿图。

#### 6、Core Graphics

CG 是一个轻量级的 2D 绘图 API，`CALayer` 工作在它的上层，当我们创建一个 `UIView` 时，`CALayer` 会使用 CG 生成一个位图，所以，它的作用是生成位图，我们也可以不通过 `CALayer` 而直接使用它：

```objc
CGContextRef ctx = UIGraphicsGetCurrentContext();
CGContextAddRect(ctx, CGRectMake(100, 100, 100, 100));
CGContextSetFillColorWithColor(ctx, [UIColor redColor].CGColor);
CGContextFillPath(ctx);
```

用 CG 绘制一个简单的矩形。

#### 7、Core Animation

当我双击 home 键或者长按应用图标的时候，iPhone 都会有动画交互，其实动画不止存在于应用内，也存在于应用外。其实 CA 是一个独立的渲染服务进程，当我们在应用内准备好动画的执行时间、位图等内容时，通过 IPC 将这些信息传递给 CA，它会调用 OpenGL-ES API 完成对动画的渲染工作。OpenGL 是一个开放式的图形库，它负责使用 GPU 和图形管线等硬件将位图输送到等屏幕上。

### 二、一个视图从创建到显示在屏幕上

CPU 和 GPU 的工作原理请自行维基百科，从上面的几个概念，我们可以得出一个结论：

![](https://upload-images.jianshu.io/upload_images/5314152-c8542442dfa8458f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

整个图像的绘制和显示过程如上图，其实这里 `CALayer` 并没有承担图层的工作，它更像是图像的数据模型，如上文我们用 CG 绘制一个矩形时，会给它的上下文设置一些信息，比如填充色、大小、位置等信息，而这些内容都是我们平常工作中设置给 layer 或者 view 的，因此，可以认为 `CALayer` 是 CG 上下文的对象描述。所以，从创建一个 `UIView` 到它显示在屏幕上，经历了如下几个步：

- **布局**，准备视图/图层的层级关系，以及视图/图层的属性（背景色、位置、填充内容、阴影等）。
- **绘制**，由 CG 生成图层的寄宿图（位图），调用 `- drawRect:` 方法。
- **准备**，准备将位图和一些动画信息打包发送给渲染服务，同时 CA 也会解码动画的执行时间、缓冲函数等一些信息。
- **提交**，CA 打包所有位图和动画属性，通过 IPC 发送到渲染服务。
- **纹理化**，渲染服务按照图层之间的层级结构将所有的位图通过计算，设置 OpenGL 几何形状。
- **渲染**，OpenGL 指令操作 GPU、图形总线等将图像渲染到屏幕上。

现在回想一下，好像我们工作中，也就经历了第一步，可能有部分人会经历第二步，简单

#### 待续...



















