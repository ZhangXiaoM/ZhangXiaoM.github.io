---
title: 多线程编程与 GCD
date: 2018-07-05 12:16:27
tags: 并发编程
---

如果你还不了解进程的话，请参考：[并发编程之进程](https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/)，进程是由完整的逻辑控制流和独立的地址空间构成的，一个线程就是进程中一个单一顺序的逻辑控制流，由进程调度的线程被称为用户级线程，由内核调度的被称为内核线程（轻量级进程），这里仅讨论用户级线程。多个进程可以被操作系统调度而组成多进程程序，同样的，多个线程也可以被进程调度而组成多线程编程，同一进程的多个线程共享该进程的地址空间，也就是整个进程的虚拟内存都是该进程内所有线程的共享内存。

### 一、几个概念

#### 1.1 同步 vs 异步

同步和异步的概念是针对指令，不针对线程，也就是仅用主线程也能进行异步操作，所以异步的并不一定是多线程的，同步的指令也不一定只是主线程执行的。假如将一个同步或者异步任务视为一个指令集的话，执行同步任务的线程会等待该指令集执行完再去执行该指令集的下一条指令，而异步任务会直接跳过当前指令集去执行下一条指令，当执行该指令集的线程空闲的时候才会执行该指令集。所以异步任务不会阻塞当前线程。

#### 1.2 并发 vs 并行

这两个概念是很多人比较容易混淆的概念，有人会说并发是并行的子集，只要是并行的，一定是并发的，因为牵扯到线程调度（单核 CPU 的情况下，多个线程交替使用 CPU）的问题，并发的不一定是并行的。有个问题请思考一下，假设我们的程序运行在一个四核 CPU 的设备上，也就是此时操作系统是支持并行的，但是我们设计的程序仅仅使用的主线程，比如说打印了一个 Hello world，那么此时能说并行的一定是并发的吗？

其实这两个概念相关联但是又不是那么关联，并行表述的是能力，并发表述的是程序结构，也就是具有双核以上 CPU 的系统具有并行的能力，我们写的代码是支持并发的程序结构。在具有并行能力的系统上执行的并发结构的程序一定是并发的，即使在不具有并行能力的系统（单核）上执行的并发结构的程序仍然是并发的。

#### 1.3 线程 vs 队列

对 iOS 来说，特别是习惯使用 GCD 的开发者，线程和队列也是需要区分的概念，队列和线程本质上并不是一一对应的关系（其实主线程不一定只执行主队列的指令）。GCD 会为我们的程序提供几种类型的队列（主队列，全局并发队列，串行队列，并发队列），我们只需要将任务以同步或者异步的形式添加进队列，GCD 会调度需要的线程帮我们依次执行队列中的任务。

#### 1.4 context（上下文）

**context** 一般被翻译为上下文，是一个抽象的概念，在 iOS 中也经常出现（CGContext），其实我们可以将它理解为一个可变 `map` 或者作为 `model` 的结构体，它保存了当前对象此时所有的状态信息，比如要绘制一个 `UILabel`，此时绘制对象的 `context` 里就会保存我们为 `UILabel` 设置的信息，比如背景颜色、字体、字号等等，然后负责绘制的对象会从 `context` 取出这些属性完成绘制。对进程和线程来说是一样的，当进程被抢占时，它的 `context` 中就会保存进程此时的状态信息，等进程重新进入运行状态时，调度程序就会将进程信息恢复。

### 二、线程调度

和进程一样，线程也有一个上下文保存它当前执行的状态信息，比如堆栈信息、PC、寄存器等等，当该线程被抢占挂起时，上下文就会保存此时线程执行的栈帧、寄存器状态等等，线程的调度也被称为**上下文切换**。就像进程一样，线程也是交替使用 CPU 的，因为对于交互式程序来说，runloop 的存在就造成主线程一直占有 CPU 资源，线程的调度可以避免其他子线程**饿死**。

当多进程编程和多线程编程共存的情况下，对于线程的调度就分为两种情况。

- 由进程调度

  调度程序将时间片分配给进程，进程通过调度算法将时间片分配给线程，此时线程的上下文切换由进程决定，比如一个进程得到 10 ms 的时间片，它会根据自身的调度算法将时间片分配给线程，等时间片用完，调度程序会将该进程挂起，进程内正在执行的线程也会挂起，进程会保存所有线程的上下文，这是用户级线程常用的调度方式。

- 由调度程序调度

  调度程序负责调度线程，比如进程 A 和进程 B 分别有三个线程 A1, A2, A3, B1, B2, B3，调度程序分配 10ms 的时间片给线程 A1，10ms 过后分配 10ms 的时间片给 B1，此时既要切换进程的上下文，也要切换线程的上下文，因此，这种调度方式会带来更大的开销。线程的上下文由内核保存，一般来说，内核级线程会使用这种调度方式。

![](https://upload-images.jianshu.io/upload_images/5314152-ebe04302a61f6c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 三、线程同步—锁

同一进程的多个线程会共享该进程的地址空间，比如数据段、文本段、堆等。当多个线程并发的访问同一块内存段时，就会产生竞态条件导致的线程安全问题。锁就是为了解决这些问题，也填一下[并发编程之进程](https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/)里进程同步问题留下的坑。

#### 3.1 互斥锁

#### 3.2 自旋锁

#### 3.3 信号量

#### 3.4 同步锁

#### 3.5 NSLock



### 四、GCD

#### 4.1 同步串行

#### 4.2 同步并发

#### 4.3 异步串行

#### 4.4 异步并发

### 未完待续...