---
title: 几个关于数字数组的算法
date: 2018-06-11 14:44:43
tags:
---

### 写在前面的话

算法无用论和算法重要论一直以来都是程序员界争论不休的话题，至今也没人能给出一个明确的定论。个人认为，解算法或者说刷题的目的不在于我们在工作中使用这个算法，而在于解题的过程能锻炼我们解决问题的思维和扩展思维。这种思维可以给我带来的是：一个复杂的流程可以想到多种解决方法，并且从中选择最优的解法，而不是只有一种解法还是十分垃圾的解法。另外，一个简单的数据结构的使用可能会大大的简化我们代码的时间复杂度（时间复杂度和空间复杂度的概念请自行了解）。下面来看例子吧：

### 一、缺少了谁？

问题一：1 - n，n个数，无序无重复，被拿掉了一个，请找到被拿掉的那个数，例如：

```c
nums = [2,6,4,3,1]; n = 6;
result: 5.
// 6个数：1-6，被拿掉的那个是5，所以结果就是5。
```

解法：用等差数列求和公式得到 n 个数的和，然后把数组中的数字挨个减一遍。直接上代码：

```java
int findAbsence(int[] nums, int n) {
    if (nums == null || nums.length == 0) return -1;

    int sum = (1 + n) * n / 2;
    for (int i: nums) {
        sum -= i;
    }
    return sum;
}
```

看上去也没有什么难度嘛！而且此解法的时间复杂度为 O(N)，空间复杂度为 O(1)，简直完美。

上面的解法已经是这道题的最优解法，但是它不具备通用性，假如我们遇到的问题不是抽掉一个数字而是两个呢？那么上面的解法就不具备解决这个的问题的能力。

问题二：在问题一的基础上，扩展为拿掉两个数字或者更多数字，例如：

```c
nums = [2,6,4,1]; n = 6;
result: [3,5].
// 6个数：1-6，被拿掉的那个是5，所以结果就是5。
```

很显然，问题一的解法显然已经不适用于现在的问题了，有的人可能会想到先排序，然后比较数组的下标和对应的值，当第一次出现不对应的时候就是缺少的值，同样的方法再找到第二个，但是排序的时间复杂度是 O(N*lgN)，该题目可能还会有更好的解法。

散列法，将数组中的值全部散列到 `Map` 中，然后将 1 - n 作为键去 `Map` 中查找，查不到的即为缺少的。代码：

```java
List<Integer> findAbsenceWithMap(int[] nums, int n) {
    if (nums == null || nums.length == 0) return null;
        
    List<Integer> list = new ArrayList<>();
    Map<Integer, Integer> map = new HashMap<>();
        
    for (int i: nums) {
        map.put(i, 1);
    }
        
    for (int i = 1; i <= n; ++i) {
    	if (map.get(i) == null) {
            list.add(i);
        }
    }
    return list;
}
```

我们用了 O(N) 的空间复杂度换取了 O(lgN) 的时间复杂度，同时这种解法好像更容易理解一些。

这种解法 O(N) 的时间复杂度当然是建立在哈希表没有哈希冲突的情况下，假设在极端情况下哈希表完全冲突，那么该问题的时间复杂度变成了 O(N^2)，好像还不如我们第一次想到的排序算法，当然哈希完全冲突的情况基本上不会出现，作这个假设的目的是为了引出更好的解法：

申请一个新的数组，数组的长度为 n，将 `nums` 中的值作为下标，将 `nums` 中的内容散列到新的数组，标记为 1，最后遍历一遍新数组，未被散列的下标即为我们要查找的目标：

```java
List<Integer> findAbsenceWithArray(int[] nums, int n) {
    if (nums == null || nums.length == 0) return null;

    List<Integer> list = new ArrayList<>();
    int[] temp = new int[n];

    for (int i: nums) {
        temp[i - 1] = 1;
    }

    for (int i = 0; i < n; ++i) {
        if (temp[i] == 0) {
            list.add(i + 1);
        }
    }
    return list;
}
```

这样就解决了哈希表哈希冲突的问题，同时基础类型的数组要比 `Map` 这种封装类型对内存的消耗少得多。

### 二、多了谁？

现在问题又变得复杂了：

问题三：依然是 n 个数，每个数的大小都大于等于1，小于等于 n，但是有的数被拿掉了，有的数出现了两次，请找到出现两次的数。例如：

```c
nums = [2,6,6,4,2,1]; n = 6;
result: [2,6].
// 2和6分别出现了两次，缺少了3和5。
```

经过对问题一和问题二的思考，我们马上就想到了，将所有数以数为键，以出现的次数为值散列一遍，最后找到哈希表中值为 2 的数，emm，是个好解法，但是不幸的是，此时待处理的数组过大，已经没有多余的内存给你申请一个相同内存的数组或者哈希表，也就是说我们必须要在 O(1) 的空间复杂度解决这个问题。同时，由于待处理数组太大，我们设计的算法的时间复杂度不宜过高。

现在看上去这个问题是有点变态了，但是又确确实实是我们在工作中可能会遇到的问题，因为 4G 内存装满整形数字也就 10亿数量级的数字，好像并不是特别大。

好在，题目并没有不允许我们修改原始数组，题干中的 1 - n，好像也是解题的关键所在。因此，我们就想到了原地散列的解法，也就是以数组中的值为下标再散列该数组，将该下标下的值乘以 -1，当遍历到某个下标的值小于 0时，则该下标出现两次。例如：

```c
// 原数组
key: 0 1 2 3 4 5
val: 2 6 6 4 2 1
// 将第一个 val，即2的下标乘以-1
key: 0  1 2 3 4 5
val: 2 -6 6 4 2 1   
// 将第二个 val，即6的下标乘以-1
key: 0  1 2 3 4  5
val: 2 -6 6 4 2 -1 
/* 遍历到第三个val，6时，发现数组中第6个数为负数，说明6是第二次出现，
 * 因此，6为出现两次的数，保存6。
 * 然后将第6个数乘以-1，避免重复，以此类推。
 */
key: 0  1 2 3 4  5
val: 2 -6 6 4 2  1
```

代码：

```java
public List<Integer> findDuplicates(int[] nums) {
    List<Integer> list = new ArrayList<>();

    if (nums == null) return null;
    if (nums.length == 0) return list;

    for (int i = 0; i < nums.length; ++ i) {
        int index = Math.abs(nums[i]) - 1;
        if (nums[index] < 0) list.add(Math.abs(index + 1));

        nums[index] = -nums[index];
    }

    return list;
}
```

这样我们就用 O(N) 的时间复杂度和 O(1) 的空间复杂度解决了这个问题。

经过上面几道题目的锻炼，感觉自己好像掌握了解决这种问题的套路了，自信满满。放马过来吧！🤓🤓

问题四：这次不再是 n 个数了，而是 n + 1 个数，仍然是大于等于1，小于等于 n，但是这堆数里面出现了一个异类，它出现了好多次，当然它的出现挤掉了其他成员的位置，例如：

```c
nums = [2,5,1,1,1,3]; n = 5;
result: 1.
```

条件继承自问题三，没有多余的空间给我们用，时间复杂度不宜过高，但是不同的是，此时你不能再修改数组。

假如没有这些条件的话，上面几个问题的解法看起来好像都能解决这个问题，我们的铺垫是有用的，但是假如加了这些限制条件，你还能想到解法吗？要知道永远不会变的是变化，你怎么知道自己在职业生涯中不会遇到这类问题和限制条件呢？

假如问个