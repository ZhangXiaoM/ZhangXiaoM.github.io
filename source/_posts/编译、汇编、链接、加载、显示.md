---
title: 编译、汇编、链接、加载、显示
date: 2018-09-21 18:03:56
tags: 
---

之前写过关于链接的文章[dyld 和链接](https://zhangxiaom.github.io/2018/07/01/dyld-%E5%92%8C%E9%93%BE%E6%8E%A5/)，链接对我们了解组件化和模块化具有重要的意义。

我们写完的文本代码，点击了编译器上 build 按钮之后，是怎么在机器上运行的呢？另外以 iOS 为例的可视化应用，又是怎么将 UIView 实例在手机上显示的呢？

### 前言  计算机的思考方式和人脑的思考方式

程序 = 数据结构 + 算法，这个公式是计算机界的定理，不管使用多么高级的语言，cpp 还是 php，不管是某个领域的开发专家，还是入门级菜鸟，写出来的程序都是数据结构和算法组成的，区别无非是算法的好坏，数据结构的合适与否，设计模式也是算法的一种体现。

其实我们生活中充斥着各种各样的程序，比如：人吃饭（主谓宾！），人和饭即为某种数据结构，例如对象（对象在内存中的存储方式类似于结构体，一块连续的内存块），而吃的行为即是算法，算法合适与否的区别在于，用勺子吃面还是用筷子吃面。用这种方式理解面向对象更容易理解一些。

我们出生以来接触的最早的一个具有科学意义的程序可能就是 1 + 1 = 2 了吧，试想一下，当我们只会用数手指计数时，计算 1 + 1，会将 1 转换为 1 根手指，我们会将这个程序转换成这种可以理解的方式，同理计算机也是一样的，它看不懂文本代码，也听不懂任何语言，它只知道高低电平（二进制），因此它也会把代码转换成它可以理解的方式，机器码。而这个转换的任务就是编译器完成的。

比如下面一段 c 代码：

```c
// main.c
#include <stdio.h>
#include "Sum.h"

#define DEFINE 3 * 5

int main(int argc, const char * argv[]) {

    int c = sum(3, DEFINE);
    printf("%d\n", c);
    
    return 0;
}

// Sum.h
#include <stdio.h>
int sum(int a, int b);

// Sum.c
#include "Sum.h"
int sum(int a, int b) {
    return a + b;
}
```

编译器通过编译、汇编、链接的步骤将它转化为机器码：

```c
main:
Contents of (__TEXT,__text) section
0000000100000f20	55 48 89 e5 48 83 ec 20 b8 03 00 00 00 b9 0f 00 
0000000100000f30	00 00 c7 45 fc 00 00 00 00 89 7d f8 48 89 75 f0 
0000000100000f40	89 c7 89 ce e8 27 00 00 00 48 8d 3d 56 00 00 00 
0000000100000f50	89 45 ec 8b 75 ec b0 00 e8 27 00 00 00 31 c9 89 
0000000100000f60	45 e8 89 c8 48 83 c4 20 5d c3 90 90 90 90 90 90 
0000000100000f70	55 48 89 e5 89 7d fc 89 75 f8 8b 75 fc 03 75 f8 
0000000100000f80	89 f0 5d c3 
```

可以看出编译器的发明为程序员界带来了多大的便利性。

一个工程（源文件集合）是怎么转换成机器码的呢？

![](\编译、汇编、链接、加载、显示\whole-progress.png)

上图即为我们写的代码转换为机器代码的全过程，这个过程很像一个流水线的工作，前一步的输出是后一步的输入。

### 一、预处理

预处理的作用主要有两个：1、展开头文件；2、替换宏定义，如上述代码中的 `main.c`，经过预处理器预处理后的结果为：

```c
# 412 "/usr/include/stdio.h" 2 3 4
# 10 "main.c" 2
# 1 "./Sum.h" 1
# 14 "./Sum.h"
int sum(int a, int b);
# 11 "main.c" 2

int main(int argc, const char * argv[]) {

    int c = sum(3, 3 * 5);
    printf("%d\n", c);

    return 0;
}
```

可以看到，展开了 `Sum.h`，替换了宏定义 `DEFINE`。（上述代码省略了展开的标准io库头文件）

### 二、编译

预处理后的 `main.i` 文件作为输入文件输入到编译器编译，编译器有前后端之分：

![](\编译、汇编、链接、加载、显示\fe-be.png)

编译的过程也是一种流水线的过程，前一步的输出作为后一步的输入，最后得到结果。
典型的例子就是 clang 和 llvm，编译器前端的作用是词法分析、语法分析等，保证代码没有错误，比如，变量未声明、标识符错误、漏写分隔符和括号等语法问题，而编译器后端的任务是通过复杂的寄存器分配算法，为代码中的变量和常量分配合适的寄存器，然后生成并优化汇编指令。

![](\编译、汇编、链接、加载、显示\complier.png)

`*.i` 中存储的我们的代码是一种字符流的形式，词法分析器会将字符流转换为记号流，举个栗子：

```c
if (x > 5)
    y = "hello";
else 
    z = 1;
```

经过词法分析器分析后得到的记号流为：

```c
IF LPAREN IDENT(x) GT INT(5) RPAREN
	IDENT(y) ASSIGN STRING("hello") SEMICOLON
ELSE
	IDENT(z) ASSIGN INT(1) SEMICOLON EOF 
```

词法分析只是简单的将字符流转换为记号流，比如标识符、括号、分隔符等，而判断我们程序是否有语法错误是语法分析器做的事，比如写代码的时候漏写了一个括号，词法分析器不会报错，只是在记号流中，少了一个括号的记号，语法分析器会将报错信息反馈给我们，告诉我们，哪里应该有一个括号。

（未完）