<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zmc的技术博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-01T03:37:02.779Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zmc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/09/01/%E7%BC%96%E8%AF%91%E3%80%81%E6%B1%87%E7%BC%96%E3%80%81%E9%93%BE%E6%8E%A5%E3%80%81%E5%8A%A0%E8%BD%BD%E3%80%81%E6%98%BE%E7%A4%BA/"/>
    <id>http://yoursite.com/2019/09/01/编译、汇编、链接、加载、显示/</id>
    <published>2019-09-01T03:37:02.779Z</published>
    <updated>2019-09-01T03:37:02.779Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过关于链接的文章<a href="https://zhangxiaom.github.io/2018/07/01/dyld-%E5%92%8C%E9%93%BE%E6%8E%A5/" target="_blank" rel="noopener">dyld 和链接</a>，链接对我们了解组件化和模块化具有重要的意义。</p><p>我们写完的文本代码，点击了编译器上 run 按钮之后，是怎么在机器上运行的呢？另外以 iOS APP 为例的可视化应用，又是怎么将 UIView 实例在手机上显示的呢？</p><h3 id="前言-计算机的思考方式和人脑的思考方式"><a href="#前言-计算机的思考方式和人脑的思考方式" class="headerlink" title="前言  计算机的思考方式和人脑的思考方式"></a>前言  计算机的思考方式和人脑的思考方式</h3><p>程序 = 数据结构 + 算法，这个公式是计算机界的定理，不管使用多么高级的语言，cpp 还是 php，不管是某个领域的开发专家，还是入门级菜鸟，写出来的程序都是数据结构和算法组成的，区别无非是算法的好坏，数据结构的合适与否，设计模式也是算法的一种体现。</p><p>其实我们生活中充斥着各种各样的程序，比如：人吃饭（主谓宾！），人和饭即为某种数据结构，例如对象（对象在内存中的存储方式类似于结构体，一块连续的内存块），而吃的行为即是算法，算法合适与否的区别在于，用勺子吃面还是用筷子吃面。</p><p>我们出生以来接触的最早的一个具有科学意义的程序可能就是 1 + 1 = 2 了吧，试想一下，当我们只会用数手指计数时，计算 1 + 1，会将 1 转换为 1 根手指，我们会将这个程序转换成这种可以理解的方式，同理计算机也是一样的，它看不懂文本代码，也听不懂任何语言，它只知道高低电平（二进制），因此它也会把代码转换成它可以理解的方式–机器码。而这个转换的任务就是编译器完成的。</p><p>比如下面一段 c 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sum.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE 3 * 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = sum(<span class="number">3</span>, DEFINE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sum.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sum.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sum.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器通过编译、汇编、链接的步骤将它转化为机器码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">main:</span><br><span class="line"><span class="function">Contents <span class="title">of</span> <span class="params">(__TEXT,__text)</span> section</span></span><br><span class="line"><span class="function">0000000100000f2055 48 89 e5 48 83 ec 20 b8 03 00 00 00 b9 0f 00 </span></span><br><span class="line"><span class="function">0000000100000f3000 00 c7 45 fc 00 00 00 00 89 7d f8 48 89 75 f0 </span></span><br><span class="line"><span class="function">0000000100000f4089 c7 89 ce e8 27 00 00 00 48 8d 3d 56 00 00 00 </span></span><br><span class="line"><span class="function">0000000100000f5089 45 ec 8b 75 ec b0 00 e8 27 00 00 00 31 c9 89 </span></span><br><span class="line"><span class="function">0000000100000f6045 e8 89 c8 48 83 c4 20 5d c3 90 90 90 90 90 90 </span></span><br><span class="line"><span class="function">0000000100000f7055 48 89 e5 89 7d fc 89 75 f8 8b 75 fc 03 75 f8 </span></span><br><span class="line"><span class="function">0000000100000f8089 f0 5d c3</span></span><br></pre></td></tr></table></figure><p>可以看出编译器的发明为程序员界带来了多大的便利性。</p><p>一个工程（源文件集合）是怎么转换成机器码的呢？</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16681731a4b476f6?w=728&amp;h=95&amp;f=png&amp;s=16376" alt=""></p><p>上图即为我们写的代码转换为机器代码的全过程，这个过程很像一个流水线的工作，前一步的输出是后一步的输入。</p><h3 id="一、预处理"><a href="#一、预处理" class="headerlink" title="一、预处理"></a>一、预处理</h3><p>预处理的作用主要有两个：1、展开头文件；2、替换宏定义，如上述代码中的 <code>main.c</code>，经过预处理器预处理后的结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">412</span> <span class="string">"/usr/include/stdio.h"</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"># <span class="number">10</span> <span class="string">"main.c"</span> <span class="number">2</span></span><br><span class="line"># <span class="number">1</span> <span class="string">"./Sum.h"</span> <span class="number">1</span></span><br><span class="line"># <span class="number">14</span> <span class="string">"./Sum.h"</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"># <span class="number">11</span> <span class="string">"main.c"</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = sum(<span class="number">3</span>, <span class="number">3</span> * <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，展开了 <code>Sum.h</code>，替换了宏定义 <code>DEFINE</code>。（上述代码省略了展开的标准io库头文件）</p><h3 id="二、编译"><a href="#二、编译" class="headerlink" title="二、编译"></a>二、编译</h3><p>预处理后的 <code>main.i</code> 文件作为输入文件输入到编译器编译，编译器有前后端之分：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/1668173568173b8b?w=466&amp;h=67&amp;f=png&amp;s=4722" alt=""></p><p>编译的过程也是一种流水线的过程，前一步的输出作为后一步的输入，最后得到结果。<br>典型的例子就是 clang 和 llvm，编译器前端的作用是词法分析、语法分析等，保证代码没有错误，比如，变量未声明、标识符错误、漏写分隔符和括号等语法问题，而编译器后端的任务是通过复杂的寄存器分配算法，为代码中的变量和常量分配合适的寄存器，然后生成并优化汇编指令。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/16681741b3051f4d?w=543&amp;h=178&amp;f=png&amp;s=19281" alt=""></p><p><code>*.i</code> 中存储的我们的代码是一种字符流的形式，词法分析器会将字符流转换为记号流，举个栗子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">5</span>)</span><br><span class="line">    y = <span class="string">"h"</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    z = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>经过词法分析器分析后得到的记号流为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IF LPAREN <span class="title">IDENT</span><span class="params">(x)</span> GT <span class="title">INT</span><span class="params">(<span class="number">5</span>)</span> RPAREN</span></span><br><span class="line"><span class="function">    <span class="title">IDENT</span><span class="params">(y)</span> ASSIGN <span class="title">STRING</span><span class="params">(<span class="string">"h"</span>)</span> SEMICOLON</span></span><br><span class="line"><span class="function">ELSE</span></span><br><span class="line"><span class="function">    <span class="title">IDENT</span><span class="params">(z)</span> ASSIGN <span class="title">INT</span><span class="params">(<span class="number">1</span>)</span> SEMICOLON EOF</span></span><br></pre></td></tr></table></figure><p>词法分析只是简单的将字符流转换为记号流，比如将标识符、关键字、括号、分隔符等转换成相应的记号，而判断我们程序是否有语法错误是语法分析器做的事，比如写代码的时候漏写了一个括号，词法分析器不会报错，只是在产生的记号流中，少了一个括号的记号，语法分析器会将报错信息反馈给我们，告诉我们，哪里应该有一个括号。语法错误我们平常写代码过程中经常遇到的问题。<br>语法分析器除了会帮我们分析语法是否符合规范之外，还有一个作用就是生成抽象语法树，比如上述例子中，语法分析器生成的抽象语法树为：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/1668177c71e5db2f?w=330&amp;h=203&amp;f=png&amp;s=9680" alt=""></p><p>编译器后端会通过使用抽象语法树经过一系列的算法生成汇编指令，由于寄存器分配，指令优化等算法过于高深，此处不再分析。</p><p>第一个例子中的 <code>main.c</code>，我们可以通过反汇编得到机器码对应的汇编指令为：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: <span class="number">55</span>                 <span class="keyword">pushq</span>%rbp</span><br><span class="line"> <span class="number">1</span>:<span class="number">48</span> <span class="number">89</span> e5         <span class="keyword">movq</span>%rsp, %rbp</span><br><span class="line"> <span class="number">4</span>:<span class="number">48</span> <span class="number">83</span> ec <span class="number">20</span>          <span class="keyword">subq</span><span class="number">$32</span>, %rsp</span><br><span class="line"> <span class="number">8</span>:<span class="keyword">b8 </span><span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">movl</span><span class="number">$3</span>, %eax</span><br><span class="line"> d:<span class="keyword">b9 </span><span class="number">0</span>f <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       <span class="keyword">movl</span><span class="number">$15</span>, %ecx</span><br><span class="line"><span class="number">12</span>:<span class="built_in">c7</span> <span class="number">45</span> fc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="keyword">movl</span><span class="number">$0</span>, -<span class="number">4</span>(%rbp)</span><br><span class="line"><span class="number">19</span>:<span class="number">89</span> <span class="number">7</span>d f8         <span class="keyword">movl </span>%edi, -<span class="number">8</span>(%rbp)</span><br><span class="line"><span class="number">1</span>c:<span class="number">48</span> <span class="number">89</span> <span class="number">75</span> <span class="built_in">f0</span>         <span class="keyword">movq </span>%rsi, -<span class="number">16</span>(%rbp)</span><br><span class="line"><span class="number">20</span>:<span class="number">89</span> <span class="built_in">c7</span>                 <span class="keyword">movl </span>%eax, %edi</span><br><span class="line"><span class="number">22</span>:<span class="number">89</span> ce                 <span class="keyword">movl</span>%ecx, %esi</span><br><span class="line"><span class="number">24</span>:e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>        callq<span class="number">0</span> &lt;_main+<span class="number">0x29</span>&gt;</span><br><span class="line"><span class="number">29</span>:<span class="number">48</span> <span class="number">8</span>d <span class="number">3</span>d <span class="number">1</span>a <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> leaq<span class="number">26</span>(%rip), %rdi</span><br><span class="line"><span class="number">30</span>:<span class="number">89</span> <span class="number">45</span> ec         <span class="keyword">movl</span>%eax, -<span class="number">20</span>(%rbp)</span><br><span class="line"><span class="number">33</span>:<span class="number">8</span>b <span class="number">75</span> ec         <span class="keyword">movl</span>-<span class="number">20</span>(%rbp), %esi</span><br><span class="line"><span class="number">36</span>:<span class="keyword">b0 </span><span class="number">00</span>                <span class="keyword">movb</span><span class="number">$0</span>, %al</span><br><span class="line"><span class="number">38</span>:e8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>        callq<span class="number">0</span> &lt;_main+<span class="number">0x3D</span>&gt;</span><br><span class="line"><span class="number">3</span>d:<span class="number">31</span> <span class="built_in">c9</span>                xorl %ecx, %ecx</span><br><span class="line"><span class="number">3</span>f:<span class="number">89</span> <span class="number">45</span> e8             <span class="keyword">movl </span>%eax, -<span class="number">24</span>(%rbp)</span><br><span class="line"><span class="number">42</span>:<span class="number">89</span> <span class="built_in">c8</span>                 <span class="keyword">movl</span>%ecx, %eax</span><br><span class="line"><span class="number">44</span>:<span class="number">48</span> <span class="number">83</span> <span class="built_in">c4</span> <span class="number">20</span>          <span class="keyword">addq </span><span class="number">$32</span>, %rsp</span><br><span class="line"><span class="number">48</span>:<span class="number">5</span>d                      <span class="keyword">popq</span>%rbp</span><br><span class="line"><span class="number">49</span>:<span class="built_in">c3</span>                 retq</span><br></pre></td></tr></table></figure></p><h4 id="一个简单的编译器的例子"><a href="#一个简单的编译器的例子" class="headerlink" title="*一个简单的编译器的例子"></a>*一个简单的编译器的例子</h4><p>某种简单的加法计算器，只接受两种指令 <code>push</code> 和 <code>add</code>，<code>push</code> 是压栈操作，<code>add</code> 是将栈顶两个元素弹出相加并将结果压栈。<br>那么当我们输入程序 <code>1 + 2 + 3</code> 时，它的编译过程为：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/17/166819e2e514d18e?w=693&amp;h=112&amp;f=png&amp;s=10367" alt=""></p><p>生成的指令：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push </span><span class="number">1</span></span><br><span class="line"><span class="keyword">push </span><span class="number">2</span></span><br><span class="line"><span class="keyword">add</span></span><br><span class="line"><span class="keyword">push </span><span class="number">3</span></span><br><span class="line"><span class="keyword">add</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><h3 id="三、汇编"><a href="#三、汇编" class="headerlink" title="三、汇编"></a>三、汇编</h3><p>汇编器将汇编指令汇编成机器代码。</p><h3 id="四、链接"><a href="#四、链接" class="headerlink" title="四、链接"></a>四、链接</h3><p>参见 <a href="https://zhangxiaom.github.io/2018/07/01/dyld-%E5%92%8C%E9%93%BE%E6%8E%A5/" target="_blank" rel="noopener">dyld 和链接</a>。</p><h4 id="补充："><a href="#补充：" class="headerlink" title="*补充："></a>*补充：</h4><p>首先需要知道的是，函数（区分函数指针）是一段指令块，被分配在可执行文件的某块内存中。</p><p>我们工程中的每个源文件都被编译器编译成后缀为 <code>.o</code> 的目标文件（object file），试想一下上面的例子中，<code>main.i</code> 中仅仅得到了 <code>sum()</code> 的声明，因此 <code>main.o</code> 中也仅存在 <code>sum()</code> 的声明，那么 <code>sum()</code> 的指令集是怎么执行的呢？这就是链接的作用了，其实整个代码的编译过程中，有一个叫<strong>符号表</strong>的东西起了很大的作用，符号表以键值对的形式存储了当前工程中所有源文件的外部符号，比如上面的例子中，<code>_sum</code> 即为符号（键），<code>*_sum</code> 即为符号的引用（指向 <code>sum()</code> 指令块的指针，值）。</p><p>语法分析器拿到 <code>sum</code> 记号时，它会从当前文件（<code>main.i</code>）中寻找 <code>sum</code> 的定义，这个定义可能是从别的头文件展开的，也可能是该文件本身定义的，当不存在时就会报语法错误。然后编译器后端分析抽象语法树时，会将当前函数的指令预设置为下一条指令。比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 上个例子中的 Sum.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Sum.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    foo();</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的目标文件 <code>main.o</code> 中的指令为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main.o</span>:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line"><span class="symbol">_foo</span>:</span><br><span class="line"><span class="number">0000000000000000</span><span class="keyword">pushq</span>%rbp</span><br><span class="line"><span class="number">0000000000000001</span><span class="keyword">movq</span>%rsp, %rbp</span><br><span class="line"><span class="number">0000000000000004</span><span class="keyword">popq</span>%rbp</span><br><span class="line"><span class="number">0000000000000005</span>retq</span><br><span class="line"><span class="number">0000000000000006</span><span class="keyword">nopw</span>%cs:(%rax,%rax)</span><br><span class="line"><span class="symbol">_main</span>:</span><br><span class="line"><span class="number">0000000000000010</span><span class="keyword">pushq</span>%rbp</span><br><span class="line"><span class="number">0000000000000011</span><span class="keyword">movq</span>%rsp, %rbp</span><br><span class="line"><span class="number">0000000000000014</span><span class="keyword">subq</span><span class="number">$0x20</span>, %rsp</span><br><span class="line"><span class="number">0000000000000018</span><span class="keyword">movl</span><span class="number">$0x0</span>, -<span class="number">0x4</span>(%rbp)</span><br><span class="line"><span class="number">000000000000001</span>f<span class="keyword">movl</span>%edi, -<span class="number">0x8</span>(%rbp)</span><br><span class="line"><span class="number">0000000000000022</span><span class="keyword">movq</span>%rsi, -<span class="number">0x10</span>(%rbp)</span><br><span class="line"><span class="number">0000000000000026</span>callq<span class="number">0x2b</span></span><br><span class="line"><span class="number">000000000000002</span>b<span class="keyword">movl</span><span class="number">$0x1</span>, %edi</span><br><span class="line"><span class="number">0000000000000030</span><span class="keyword">movl</span><span class="number">$0x2</span>, %esi</span><br><span class="line"><span class="number">0000000000000035</span>callq<span class="number">0x3a</span></span><br><span class="line"><span class="number">000000000000003</span>axorl%esi, %esi</span><br><span class="line"><span class="number">000000000000003</span>c<span class="keyword">movl</span>%eax, -<span class="number">0x14</span>(%rbp)</span><br><span class="line"><span class="number">000000000000003</span>f<span class="keyword">movl</span>%esi, %eax</span><br><span class="line"><span class="number">0000000000000041</span><span class="keyword">addq</span><span class="number">$0x20</span>, %rsp</span><br><span class="line"><span class="number">0000000000000045</span><span class="keyword">popq</span>%rbp</span><br><span class="line"><span class="number">0000000000000046</span>retq</span><br></pre></td></tr></table></figure><p>可以看到 <code>main.o</code> 中并没有 <code>sum</code> 函数。此时符号表中存储的的符号为 <code>_sum</code>，此时的 <code>Sum.o</code>：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Sum.o</span>:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line"><span class="symbol">_sum</span>:</span><br><span class="line"><span class="number">0000000000000000</span><span class="keyword">pushq</span>%rbp</span><br><span class="line"><span class="number">0000000000000001</span><span class="keyword">movq</span>%rsp, %rbp</span><br><span class="line"><span class="number">0000000000000004</span><span class="keyword">movl</span>%edi, -<span class="number">0x4</span>(%rbp)</span><br><span class="line"><span class="number">0000000000000007</span><span class="keyword">movl</span>%esi, -<span class="number">0x8</span>(%rbp)</span><br><span class="line"><span class="number">000000000000000</span>a<span class="keyword">movl</span>-<span class="number">0x4</span>(%rbp), %esi</span><br><span class="line"><span class="number">000000000000000</span>d<span class="keyword">addl</span>-<span class="number">0x8</span>(%rbp), %esi</span><br><span class="line"><span class="number">0000000000000010</span><span class="keyword">movl</span>%esi, %eax</span><br><span class="line"><span class="number">0000000000000012</span><span class="keyword">popq</span>%rbp</span><br><span class="line"><span class="number">0000000000000013</span>retq</span><br></pre></td></tr></table></figure><p>链接器会将 <code>Sum.o</code> 和 <code>main.o</code> 链接成一个可执行文件，当需要调用 <code>sum</code> 函数时，链接器会去符号表中找 <code>_sum</code> 符号，如果找不到编译器就会报链接错误，如果找到，链接器通过 <code>_sum</code> 键找到指向 <code>sum</code> 指令块的指针，然后将 <code>sum</code> 指令块重新布局到可执行文件的内存中，此时的 <code>callq</code> 指令会调用重新定义后的内存地址。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">main</span>:</span><br><span class="line">(__TEXT,__text) section</span><br><span class="line"><span class="symbol">_foo</span>:</span><br><span class="line"><span class="number">0000000100000</span>f50<span class="keyword">pushq</span>%rbp</span><br><span class="line"><span class="number">0000000100000</span>f51<span class="keyword">movq</span>%rsp, %rbp</span><br><span class="line"><span class="number">0000000100000</span>f54<span class="keyword">popq</span>%rbp</span><br><span class="line"><span class="number">0000000100000</span>f55retq</span><br><span class="line"><span class="number">0000000100000</span>f56<span class="keyword">nopw</span>%cs:(%rax,%rax)</span><br><span class="line"><span class="symbol">_main</span>:</span><br><span class="line"><span class="number">0000000100000</span>f60<span class="keyword">pushq</span>%rbp</span><br><span class="line"><span class="number">0000000100000</span>f61<span class="keyword">movq</span>%rsp, %rbp</span><br><span class="line"><span class="number">0000000100000</span>f64<span class="keyword">subq</span><span class="number">$0x20</span>, %rsp</span><br><span class="line"><span class="number">0000000100000</span>f68<span class="keyword">movl</span><span class="number">$0x0</span>, -<span class="number">0x4</span>(%rbp)</span><br><span class="line"><span class="number">0000000100000</span>f6f<span class="keyword">movl</span>%edi, -<span class="number">0x8</span>(%rbp)</span><br><span class="line"><span class="number">0000000100000</span>f72<span class="keyword">movq</span>%rsi, -<span class="number">0x10</span>(%rbp)</span><br><span class="line"><span class="number">0000000100000</span>f76callq<span class="number">0x100000f50</span> // foo 函数首地址</span><br><span class="line"><span class="number">0000000100000</span>f7b<span class="keyword">movl</span><span class="number">$0x1</span>, %edi</span><br><span class="line"><span class="number">0000000100000</span>f80<span class="keyword">movl</span><span class="number">$0x2</span>, %esi</span><br><span class="line"><span class="number">0000000100000</span>f85callq<span class="number">0x100000fa0</span> // sum 函数首地址</span><br><span class="line"><span class="number">0000000100000</span>f8axorl%esi, %esi</span><br><span class="line"><span class="number">0000000100000</span>f8c<span class="keyword">movl</span>%eax, -<span class="number">0x14</span>(%rbp)</span><br><span class="line"><span class="number">0000000100000</span>f8f<span class="keyword">movl</span>%esi, %eax</span><br><span class="line"><span class="number">0000000100000</span>f91<span class="keyword">addq</span><span class="number">$0x20</span>, %rsp</span><br><span class="line"><span class="number">0000000100000</span>f95<span class="keyword">popq</span>%rbp</span><br><span class="line"><span class="number">0000000100000</span>f96retq</span><br><span class="line"><span class="number">0000000100000</span>f97<span class="keyword">nop</span></span><br><span class="line"><span class="keyword">0000000100000f98</span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword">0000000100000f99</span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword">0000000100000f9a</span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword">0000000100000f9b</span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword">0000000100000f9c</span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword">0000000100000f9d</span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword">0000000100000f9e</span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword">0000000100000f9f</span><span class="keyword">nop</span></span><br><span class="line"><span class="keyword">_sum:</span></span><br><span class="line"><span class="keyword">0000000100000fa0</span><span class="keyword">pushq</span>%rbp</span><br><span class="line"><span class="number">0000000100000</span>fa1<span class="keyword">movq</span>%rsp, %rbp</span><br><span class="line"><span class="number">0000000100000</span>fa4<span class="keyword">movl</span>%edi, -<span class="number">0x4</span>(%rbp)</span><br><span class="line"><span class="number">0000000100000</span>fa7<span class="keyword">movl</span>%esi, -<span class="number">0x8</span>(%rbp)</span><br><span class="line"><span class="number">0000000100000</span>faa<span class="keyword">movl</span>-<span class="number">0x4</span>(%rbp), %esi</span><br><span class="line"><span class="number">0000000100000</span>fad<span class="keyword">addl</span>-<span class="number">0x8</span>(%rbp), %esi</span><br><span class="line"><span class="number">0000000100000</span>fb0<span class="keyword">movl</span>%esi, %eax</span><br><span class="line"><span class="number">0000000100000</span>fb2<span class="keyword">popq</span>%rbp</span><br><span class="line"><span class="number">0000000100000</span>fb3retq</span><br></pre></td></tr></table></figure><p>这就是静态链接过程中，静态链接器的工作。</p><p>但是 iOS 开发中方法的调用会更复杂，涉及到 <code>runtime</code> 和 dyld，大致流程为：</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/19/1668b86b12e208f4?w=648&amp;h=360&amp;f=png&amp;s=31407" alt=""></p><p>上图中，dyld 会将 <code>0xyy</code> 重定向为 <code>objc_msgSend()</code> 指令块的地址（运行时完成，动态链接）。<code>- foo</code> 的首地址被存储在名为 <code>Foo</code> 的类对象中（类似于 C++ 的虚函数表）。然后该指令块会在运行时被调用。<a href="https://zhangxiaom.github.io/2018/01/20/%E4%BB%8Eruntime%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7/" target="_blank" rel="noopener">了解更多</a></p><h3 id="五、加载"><a href="#五、加载" class="headerlink" title="五、加载"></a>五、加载</h3><p>dyld 会将链接完成的可执行文件加载到内存中：</p><ul><li>将 <code>__TEXT,__text</code> 中的指令拷贝到虚拟内存的 <code>.rodata（readonly）</code> 中。</li><li>将 <code>__DATA,__data</code> 中的全局和静态变量拷贝到虚拟内存的 <code>.rwdata （readwrite）</code>中。</li><li>使用 <code>.symbol</code> 中的符号完成动态链接。</li><li>初始化堆栈，从 <code>main()</code> 函数开始执行程序。</li></ul><p>其中涉及到的 <code>+ load</code> 函数，参见 <a href="https://zhangxiaom.github.io/2018/07/01/dyld-%E5%92%8C%E9%93%BE%E6%8E%A5/" target="_blank" rel="noopener">dyld 和链接</a>。</p><h3 id="六、显示"><a href="#六、显示" class="headerlink" title="六、显示"></a>六、显示</h3><p>参见<a href="https://zhangxiaom.github.io/" target="_blank" rel="noopener">优化APP的显示性能</a>。</p><h3 id="七、结语"><a href="#七、结语" class="headerlink" title="七、结语"></a>七、结语</h3><p>现在知道我们写完的代码是怎么转换成机器能明白的语言了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前写过关于链接的文章&lt;a href=&quot;https://zhangxiaom.github.io/2018/07/01/dyld-%E5%92%8C%E9%93%BE%E6%8E%A5/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;dyld 和链接&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>优化APP的显示性能</title>
    <link href="http://yoursite.com/2018/07/21/%E4%BC%98%E5%8C%96APP%E7%9A%84%E6%98%BE%E7%A4%BA%E6%80%A7%E8%83%BD/"/>
    <id>http://yoursite.com/2018/07/21/优化APP的显示性能/</id>
    <published>2018-07-21T08:16:16.000Z</published>
    <updated>2019-09-01T03:37:02.777Z</updated>
    
    <content type="html"><![CDATA[<p>APP 的显示性能问题一直以来都是一个经久不衰的话题，特别是滚动视图、表视图的滚动流畅性等等问题。那么从我们 <code>new</code> 一个 <code>UIKit</code> 开始到它在屏幕上显示的过程，CPU 和 GPU 以及显示设备是如何协同工作的呢？APP 的显示性能、帧率到底应该从哪些方面入手去优化？还是说忽略理论分析，而强行优化性能？下面我们就来讨论一下这个问题。</p><h3 id="一、几个概念"><a href="#一、几个概念" class="headerlink" title="一、几个概念"></a>一、几个概念</h3><h4 id="1、像素和分辨率"><a href="#1、像素和分辨率" class="headerlink" title="1、像素和分辨率"></a>1、像素和分辨率</h4><p>像素，通俗的来讲就是构成图像的最小单位，APP 的显示界面就是由像素组成，每个像素都会携带一个由 RGB 三原色组成的颜色信息，一个界面所有的像素和其携带的颜色信息组成我们肉眼看到的多彩的界面。分辨率就是一个界面可以显示的像素数，比如 iPhone 6 的分辨率为 750x1334，即单个 iPhone 6 界面可以显示 750x1334 个像素。分辨率的大小决定了画面的精细程度。比如：</p><p><img src="http://i1.hdslb.com/bfs/archive/aafcde785dc26db2a710c2faa133b7a9bd35015e.jpg" alt=""></p><p>左侧的图片甚至可以看到一个一个的小格子（像素）。</p><h4 id="2、位图"><a href="#2、位图" class="headerlink" title="2、位图"></a>2、位图</h4><p><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%9B%BE" target="_blank" rel="noopener">位图</a>，在计算机术语中，它是一种数据结构，我们也可以理解为，一张由二进制表示的图像，它也是由若干个点组成，每个点会携带一个表示 RGB 三原色的数值，比如 <code>0xffffff</code> 等。</p><h4 id="3、FPS（Frame-per-second，帧率）"><a href="#3、FPS（Frame-per-second，帧率）" class="headerlink" title="3、FPS（Frame per second，帧率）"></a>3、FPS（Frame per second，帧率）</h4><p>在计算机图形学、视频、动画、游戏等领域都有帧率的影子，<a href="https://www.bilibili.com/video/av15263885?spm_id_from=333.338.__bofqi.25" target="_blank" rel="noopener">这个视频</a>可以帮助我们很好的理解这个概念，当我们在 APP 上滚动视图时，滚动动画其实就是一帧一帧的图像组成的，只不过 CPU 让它滚动的频率过快，才形成了动画，其实视频、动画、游戏等都是相同的原理。iOS 设备的帧率是 60，也就是 CPU 会每秒刷新 60 次界面，如果不够这个数，就会丢帧，丢帧的直观感受就是小时候看 CD 机时，我们叫丢帧为卡碟，这也是界面不流畅或者卡顿的根源。</p><h4 id="4、CALayer-和-UIView"><a href="#4、CALayer-和-UIView" class="headerlink" title="4、CALayer 和 UIView"></a>4、CALayer 和 UIView</h4><p><code>UIView</code> 和 <code>CALayer</code> 都是一些被层级关系管理的矩形块，每一个视图都有一个 layer，当我们对视图做仿射变换（比如旋转、缩放），滑动、渐变等动画时，其实是操作的它的 layer，我们也可以直接对每个视图的 layer 做这些事。</p><p><code>UIView</code> 是对 <code>CALayer</code> 的高级封装，他除了具有和 layer 相同的功能以外，还能处理手势事件。但是为什么 iOS 要基于 <code>UIView</code> 和 <code>CALayer</code> 提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在 iOS 和 Mac OS 两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么 iOS 有 UIKit 和 <code>UIView</code>，但是 Mac OS 有 AppKit 和 <code>NSView</code> 的原因。他们功能上很相似，但是在实现上有着显著的区别。</p><p> <code>UIView</code> 和 <code>CALayer</code>  之间有一个 <strong>has a</strong> 的关系，每一个视图都 has a layer，其实既然视图是对图层能力的扩充，那么为什么不是继承关系？这是因为 has a 比 is a 具有更好的扩展性和可维护性。</p><p>二者有相同的层级关系，父视图（父图层）、子视图（子图层），这个应该没人不知道，不再赘述。</p><h4 id="5、寄宿图"><a href="#5、寄宿图" class="headerlink" title="5、寄宿图"></a>5、寄宿图</h4><p>上面说，每个我们在手机屏幕上看到的内容都是由像素组成的图像，动画也是有一帧一帧的图像组成的，每个图像在经过 GPU 处理之前都是以位图的形式存储在内存中，它也被成为 <code>CALayer</code> 的寄宿图：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Layer content properties and methods. **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* An object providing the contents of the layer, typically a CGImageRef,</span></span><br><span class="line"><span class="comment"> * but may be something else. (For example, NSImage objects are</span></span><br><span class="line"><span class="comment"> * supported on Mac OS X 10.6 and later.) Default value is nil.</span></span><br><span class="line"><span class="comment"> * Animatable. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> contents;</span><br></pre></td></tr></table></figure><h4 id="6、Core-Graphics"><a href="#6、Core-Graphics" class="headerlink" title="6、Core Graphics"></a>6、Core Graphics</h4><p>CG 是一个轻量级的 2D 绘图 API，<code>CALayer</code> 工作在它的上层，当我们创建一个 <code>UIView</code> 时，<code>CALayer</code> 会使用 CG 生成一个位图，所以，它的作用是生成位图，我们也可以不通过 <code>CALayer</code> 而直接使用它：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"><span class="built_in">CGContextAddRect</span>(ctx, <span class="built_in">CGRectMake</span>(<span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>));</span><br><span class="line"><span class="built_in">CGContextSetFillColorWithColor</span>(ctx, [<span class="built_in">UIColor</span> redColor].CGColor);</span><br><span class="line"><span class="built_in">CGContextFillPath</span>(ctx);</span><br></pre></td></tr></table></figure><p>用 CG 绘制一个简单的矩形。</p><h4 id="7、Core-Animation"><a href="#7、Core-Animation" class="headerlink" title="7、Core Animation"></a>7、Core Animation</h4><p>Core Animation 的作用不仅仅是动画，我们可能对它有点误解，动画的能力只是它所有能力中的冰山一角。</p><p>当我双击 home 键或者长按应用图标的时候，iPhone 都会有动画交互，其实动画不止存在于应用内，也存在于应用外。动画和图层的显示是一个独立的渲染服务进程，当我们在应用内准备好动画的执行时间、位图等内容时，CA 通过 IPC（进程通信） 将这些信息传递给渲染进程，它会调用 OpenGL-ES API 完成对动画的渲染工作。OpenGL 是一个开放式的图形库，它负责使用 GPU 和图形管线等硬件将位图输送到等屏幕上。</p><p>（我没有深入研究过 OpenGL 和硬件渲染，仅仅知道一些皮毛，所以不做过多的讨论。）</p><h3 id="二、一个视图从创建到显示在屏幕上"><a href="#二、一个视图从创建到显示在屏幕上" class="headerlink" title="二、一个视图从创建到显示在屏幕上"></a>二、一个视图从创建到显示在屏幕上</h3><p>CPU 和 GPU 的工作原理请自行维基百科，从上面的几个概念，我们可以得出一个结论：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-c8542442dfa8458f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>整个图像的绘制和显示过程如上图，其实这里 <code>CALayer</code> 并没有承担图层的工作，它更像是保存图像属性的数据模型，如上文我们用 CG 绘制一个矩形时，会给它的上下文设置一些信息，比如填充色、大小、位置等信息，而这些内容都是我们平常工作中设置给 layer 或者 view 的，因此，可以认为 <code>CALayer</code> 是 CG 上下文的对象描述。</p><p>从创建一个 <code>UIView</code> 到它显示在屏幕上，经历了如下几个步：</p><ul><li><strong>布局</strong>，准备视图/图层的层级关系，以及视图/图层的属性（背景色、位置、填充内容、阴影等）。</li><li><strong>绘制</strong>，由 CG 生成图层的寄宿图（位图），调用 <code>-drawRect:</code> 方法。</li><li><strong>准备</strong>，准备将位图和一些动画信息打包发送给渲染服务进程，同时 CA 也会解码动画的执行时间、缓冲函数（渐入渐出）等一些信息。</li><li><strong>提交</strong>，CA 打包所有位图和动画属性，通过 IPC 发送到渲染服务进程。</li><li><strong>纹理化</strong>，渲染服务进程按照图层之间的层级结构将所有的位图信息计算后，设置 OpenGL 几何形状。</li><li><strong>渲染</strong>，OpenGL 指令操作 GPU、图形总线等将图像渲染到屏幕上。</li></ul><p>现在回想一下，好像工作中，也就经历了第一步，可能有部分人会经历第二步，看起来简单的过程，其实幕后工作很复杂，当然我们可能永远不会绕过 CA 直接编写 OpenGL 程序，但是知道这些幕后工作对优化 APP 来说有很大的意义。</p><p>CPU 和 GPU 协同工作，上面的六个步骤前五步都是 CPU 的工作，第六步才交付给 GPU，它用来采集图片和形状（三角形），运行变换，应用纹理和混合然后把它们输送到屏幕上。也就是说渲染之前的计算、绘制等仍然会占用 CPU 和 RAM 资源。</p><p>考虑一下上面几步哪些会是 CPU 和 GPU 的性能瓶颈？</p><ul><li>布局计算，如果视图层级过于复杂，当视图呈现或者修改的时候，计算图层布局就会消耗一部分时间。Autolayout 会增加 CPU 的计算时间，但是它又有更好的可维护性，建议平衡取舍后使用它。</li><li><code>-drawRect:</code> ，重写这个方法会产生一定的性能损耗，我们被灌输过这样的观点，下文会解释原因所在。</li><li>特别复杂的视图层级，当图层绘制完成后，CA 会将所有的位图打包，通过 IPC 提交给渲染服务，IPC 是 CPU 的工作，假如视图层级特别多的话，也会增加 CPU 的传送时间。</li><li>重绘（每一帧都需要相同的像素填充多次），主要是半透明的图层引起的，因为半透明的图层在显示时，需要和后面的图层的像素混合才能达到半透明的效果，GPU 需要耗费更多的时间来绘制。</li><li>离屏渲染，有些图层 GPU 会用离屏渲染的方式绘制它，也就是在 GPU 的缓冲区渲染，然后在需要显示的时候，直接从缓冲区取出来显示，假如 GPU 在渲染其他图层的过程中，发生了离屏渲染 ，就会造成渲染的上下文切换，假如离屏渲染的图层过多的话，会给 GPU 带来很大的负载。</li><li>图片过大，当加载一个图片到内存中并显示时，CPU 会对它进行预处理，比如压缩和解压缩，当图片过大，就会增加 CPU 的负载。</li></ul><p>等等。</p><h4 id="drawRect-带来的性能问题"><a href="#drawRect-带来的性能问题" class="headerlink" title="- drawRect: 带来的性能问题"></a>- drawRect: 带来的性能问题</h4><p><code>drawRect:</code> 方法的默认实现是不做任何事情，只要你给 <code>UIView/CALayer</code> 设置合适的属性，CG 就会正确的绘制它，<code>-drawRect:</code> 方法只有首次绘制某个图层，或者某个图层的可见部分失效的情况下才会被调用。</p><p>当我们绘制完一个图层时（调用 <code>-drawRect:</code>），CPU 会保存一份快照在缓冲区，对于动画来说，图层的每一帧变化总是会有一大块未被改变的像素集合，比如滚动视图，滚动的前后帧的区别仅仅是很小的一部分像素块。当改变发生时，CPU 会将未改变的部分从缓冲区快照中复制到新的图层，放到合适的位置，改变的部分被重新计算和绘制，而此时 <code>-drawRect</code> 也会被调用。假如重写了这个方法，此时 CG 会重新绘制整个图层，也就是当改变发生时，CG 不会复制未发生改变的大块像素，而是重新绘制整个图层，这就是重写它会带来性能损耗的原因。</p><h4 id="imageView-的优势-or-劣势？"><a href="#imageView-的优势-or-劣势？" class="headerlink" title="imageView 的优势 or 劣势？"></a>imageView 的优势 or 劣势？</h4><p>假如我们直接用静态的 image 填充 <code>imageView</code> 就节省了绘制的过程，直接被 CG 压缩转化为位图后，扔给 CA 处理，然后渲染进程将图片解压缩，纹理化为三角形后，交给 GPU 去渲染。如果图片不是特别大的话，看上去比直接绘制速度可能会快一点，但是，即使 iOS 的闪存比一般的磁盘读写速度快很多，而 RAM 仍然会比它快 200 倍，iOS 视图懒加载的特性又导致了它不会在使用图片之前将它加载进内存，所以，静态图片的优势也就荡然无存，因此，CG 绘制要比静态图片更快一些。</p><h3 id="三、APP-显示性能提升的方案"><a href="#三、APP-显示性能提升的方案" class="headerlink" title="三、APP 显示性能提升的方案"></a>三、APP 显示性能提升的方案</h3><p>基于上述的理论分析，可以得出几种解决性能问题的方案：</p><ul><li>首先，使用 <code>UIKit</code>、<code>CALayer</code> 或者 <code>Core Graphics</code> 绘制寄宿图，都不能给性能带来显著的提升，<code>UIKit</code> 相对于 CG 并不会产生 CPU 的性能损耗，反而能让我们更好的使用面向对象机制。如果要使用异步绘制的话，请使用 CG，但同时也要注意 UI 作为临界区时带来的线程安全问题。</li><li>Autolayout，自动布局从诞生开始就是一个争议性的存在，现在我们可以确定它对性能有一定的损耗，因为 CPU 要重新计算布局，但是它又带来了更好的可维护性，随着硬件的提升，这点损耗在我看来是无伤大雅的，但是究竟如何选择，还要衡量一下利弊，最好不要在性能要求很高的地方使用它。</li><li>不要重写 <code>-drawRect:</code>。</li><li>尽量用代码代替本地图片。</li><li>同一个界面，不要有太复杂的视图层级，最好让所有的子视图都在同一层级。</li><li>说服你们的 UI，减少不必要的圆角、阴影等可能产生离屏渲染的图层。</li><li>尽量将所有的图层都设置为不透明。尽量！！</li><li>从磁盘和网络加载的图片不宜过大，网络图片库，类似于 SDWebImage 会对这方面优化。</li></ul><p>等等。</p><p>这些方法可能都是些老生常谈的内容，因为我们可能在很多地方看到前辈们对我们的忠告，但是从来没有人告诉过我为什么要这样，前面的理论分析都是这段结果的铺垫。</p><h4 id="更流畅的-tableView"><a href="#更流畅的-tableView" class="headerlink" title="更流畅的 tableView"></a>更流畅的 tableView</h4><p>上面提到了，滚动视图的滚动动画中 iOS 所做的优化，即复用不变的部分，重绘可变的部分。相对于显示能力，大家更关注 <code>tableView</code> 的滚动流畅性，滚动动画其实是一帧一帧的图像衔接在一起产生的，因此上述几点对每一帧图像的优化当然也对滚动视图至关重要。比如将所有 <code>cell</code> 的子视图都放在同一层级，同样也会提高滚动的流畅性。</p><p><code>tableView</code> 和普通视图不同的是，它有好几个数据源代理方法，而它的代理方法又是绘制它的关键，因此无论更新数据源还是滚动都会多次调用它的代理方法，现在你应该知道为什么滚动的时候也多次调用代理方法了。假如我们滚动的过程中，绘制帧率达不到 60 次/s，就会造成卡顿的视觉效果（和卡碟差不多）。针对这些，我们也可以提几个优化的点：</p><ul><li>代理方法中不要做太多的耗时工作，它会造成滚动视图的时候占用 CPU，阻塞主线程，从而导致帧率下降。缓存 <code>cell</code> 高度，避免滚动时计算是个不错的好方法。</li><li>尽量不要改变 <code>cell</code> 的显示内容，比如太多的事件导致的 UI 变化，<code>cell</code> 的定位是一个轻量级的展示控件。因为，<code>cell</code> 变化过多的话，就会导致滚动的时候，可变的区域增大。</li><li>RunLoop 单独使用一个 mode 来处理滚动的原因就是为了保持它的帧率，我们可以将它加入 <code>commonModes</code>，让 RunLoop 在响应其他事件的同时滚动视图，但是其他事件可能会阻塞主线程，导致帧率下降，因此，尽可能的处理轻量级的事件，或者使用异步子线程来做。</li></ul><p>等等，后面想到再补充。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>以前总是盲目的看别人的博客，然后优化性能，缺少真正的理论依据，因此自己整理一下，其中不乏一些自己的见解，当然也都是建立在理论上的结果，仅供参考。</p><h3 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h3><p>1、<a href="https://stackoverflow.com/questions/17715530/the-relationship-between-coregraphics-uiviews-and-calayers" target="_blank" rel="noopener">The relationship between CoreGraphics, UIViews and CALayers</a></p><p>2、<a href="https://stackoverflow.com/questions/14659563/to-drawrect-or-not-to-drawrect-when-should-one-use-drawrect-core-graphics-vs-su" target="_blank" rel="noopener">to drawRect or not to drawRect (when should one use drawRect/Core Graphics vs subviews/images and why?)</a></p><p>3、<a href="https://stackoverflow.com/questions/4392918/what-is-different-between-coregraphics-and-coreanimation" target="_blank" rel="noopener">What is different between CoreGraphics and CoreAnimation</a></p><p>4、<a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques" target="_blank" rel="noopener">https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques</a></p><p>5、<a href="https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect" target="_blank" rel="noopener">https://developer.apple.com/documentation/uikit/uiview/1622529-drawrect</a></p><p>6、<a href="https://developer.apple.com/videos/wwdc/2011/?id=129" target="_blank" rel="noopener">Practical Drawing for iOS Developers</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;APP 的显示性能问题一直以来都是一个经久不衰的话题，特别是滚动视图、表视图的滚动流畅性等等问题。那么从我们 &lt;code&gt;new&lt;/code&gt; 一个 &lt;code&gt;UIKit&lt;/code&gt; 开始到它在屏幕上显示的过程，CPU 和 GPU 以及显示设备是如何协同工作的呢？APP
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>runtime管理weak引用的方式</title>
    <link href="http://yoursite.com/2018/07/13/runtime%E7%AE%A1%E7%90%86weak%E5%BC%95%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/07/13/runtime管理weak引用的方式/</id>
    <published>2018-07-13T08:47:32.000Z</published>
    <updated>2019-09-01T03:37:02.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>提及 weak 引用，大多数人都知道在什么时候要用它，如果不知道的话：<a href="https://zhangxiaom.github.io/2018/01/02/ARC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/" target="_blank" rel="noopener">ARC内存管理以及循环引用</a>，其实对于手动管理堆内存来说，比如 C 语言，并不存在所谓的强引用和弱引用，ARC 这种自动引用计数管理内存的方式，导致了两个对象循环引用，从而产生内存泄漏。循环引用就像是双向链表的两个结点的 <code>next</code> 指针互相指向，当我们用 C 语言实现循环链表的时候，即使没有 weak，也能很好的管理每个结点的内存。因此，weak 是引用计数管理内存的产物，它需要提供这种机制来避免循环引用造成的内存泄漏。</p><h3 id="runtime-管理-weak-引用"><a href="#runtime-管理-weak-引用" class="headerlink" title="runtime 管理 weak 引用"></a>runtime 管理 weak 引用</h3><p>runtime 会管理所有元类、类对象、对象的生命周期以及他们的引用计数，这是 objc 的运行时特性，对象的创建和内存分配和销毁都是 runtime 动态库处理的，因此关于 weak 引用，也是 runtime 来管理的。</p><p>我之前看过大多数博客，都会说，runtime 会维护一张 weak 哈希表，以对象的地址为键，以 <code>__weak</code> 修饰的变量为值存入哈希表中，当对象被释放了之后，runtime 就会查表将变量设置为 <code>nil</code>。比如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">__<span class="keyword">weak</span> weakRefer = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime 处理为</span></span><br><span class="line">weak_table_add_item(&amp;obj, weakRefer);</span><br></pre></td></tr></table></figure><p>一开始我也对此深信不疑，但是有个问题一直无法理解：哈希表的特性是同一个键只有一个哈希码，也就是这种方式就会造成对象的弱引用能且只能被存储一个，那么假如该对象有两个弱引用呢？例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];</span><br><span class="line">__<span class="keyword">weak</span> weakRefer1 = obj;</span><br><span class="line">__<span class="keyword">weak</span> weakRefer2 = obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime 处理为</span></span><br><span class="line">weak_table_add_item(&amp;obj, weakRefer1);</span><br><span class="line">weak_table_add_item(&amp;obj, weakRefer2);</span><br></pre></td></tr></table></figure><p>哈希表会将 <code>weakRefer1</code> 覆盖，显然这不是一种正确的方式，大多数博客都是互相抄袭，那不如去看看源码吧。</p><h3 id="真相到底如何？"><a href="#真相到底如何？" class="headerlink" title="真相到底如何？"></a>真相到底如何？</h3><p>我们可以找到 runtime 源码中对 weak 的处理：<a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h" target="_blank" rel="noopener">objc-weak.h</a> 和 <a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.mm" target="_blank" rel="noopener">objc-weak.mm</a>。在看源码之前，先了解一下<a href="https://zhangxiaom.github.io/2018/03/23/%E5%93%88%E5%B8%8C%E8%A1%A8/" target="_blank" rel="noopener">哈希表</a>吧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The global weak references table. Stores object ids as keys,</span></span><br><span class="line"><span class="comment"> * and weak_entry_t structs as their values.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *weak_entries;</span><br><span class="line">    <span class="keyword">size_t</span>    num_entries;</span><br><span class="line">    <span class="keyword">uintptr_t</span> mask;</span><br><span class="line">    <span class="keyword">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>确实是一个全局哈希表，保存了所有对象的弱引用，不过保存的方式是，以对象为键，以 <code>weak_entry_t</code> 结构体为值，而不是之前提到的 weak 变量。<code>mask</code> 是用来计算哈希码的，<code>max_hash_displacement</code>  是用来解决哈希冲突的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The internal structure stored in the weak references table. </span></span><br><span class="line"><span class="comment"> * It maintains and stores</span></span><br><span class="line"><span class="comment"> * a hash set of weak references pointing to an object.</span></span><br><span class="line"><span class="comment"> * If out_of_line_ness != REFERRERS_OUT_OF_LINE then the set</span></span><br><span class="line"><span class="comment"> * is instead a small inline array.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_entry_t</span> &#123;</span></span><br><span class="line">    objc_object* referent;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">// typedef id weak_referrer_t</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span> *referrers; <span class="comment">// 保存弱引用地址的 hash set</span></span><br><span class="line">            <span class="keyword">uintptr_t</span>        out_of_line_ness : <span class="number">2</span>; <span class="comment">// 标记是否需要用 set</span></span><br><span class="line">            <span class="keyword">uintptr_t</span>        num_refs : PTR_MINUS_2; <span class="comment">// 弱引用的数量</span></span><br><span class="line">            <span class="keyword">uintptr_t</span>        mask; <span class="comment">// 计算哈希码</span></span><br><span class="line">            <span class="keyword">uintptr_t</span>        max_hash_displacement; <span class="comment">// 解决哈希冲突</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="comment">// out_of_line_ness field is low bits of inline_referrers[1]</span></span><br><span class="line">            <span class="keyword">weak_referrer_t</span>  inline_referrers[WEAK_INLINE_COUNT]; <span class="comment">// 轻量级内联数组</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 <code>weak_table_t</code> 实现了一个简易的对象类型的哈希表，<code>weak_entry_t</code> 里面保存了哈希表中某一条目的 key 和 value，至于为什么保存 key，是为了发生哈希冲突时，找到这个值。当该对象的弱引用数量低于4个时，<code>weak_entry_t</code> 会用一个轻量级的数组存储它们的<strong>地址</strong>，当数量大于4 时，<code>weak_entry_t</code> 会用哈希 set（哈希 set 是一个只有 keys 的哈希表，相当于 <code>map.allKeys()</code>，为了避免存储两个相同的地址）存储它们的<strong>地址</strong>。</p><p><a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-weak.h" target="_blank" rel="noopener">objc-weak.h</a>  提供了几个接口方法，分别是向 <code>weak_table_t</code> 中添加、删除、清空某一个对象的数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Adds an (object, weak pointer) pair to the weak table.</span></span><br><span class="line"><span class="comment">/// 向 weak table 中添加一个 &lt;object、weak pointer&gt; 的键值对</span></span><br><span class="line"><span class="comment">/// 如果 object 已经存在，则向 weak_entry 中插入 *referrer,否则创建一个 weak_entry,将 *referrer 插入</span></span><br><span class="line"><span class="comment">/// 当哈希表的装填因子满足一定条件时，扩大哈希表长度，重新哈希。</span></span><br><span class="line"><span class="function">id <span class="title">weak_register_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent, </span></span></span><br><span class="line"><span class="function"><span class="params">                         id *referrer, <span class="keyword">bool</span> crashIfDeallocating)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Removes an (object, weak pointer) pair from the weak table.</span></span><br><span class="line"><span class="comment">/// 当键值对存在时，从 weak_entry 中删除一条数据，如果 weak_entry 为空，则从 weak_table 中删除键值对</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">weak_unregister_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent, id *referrer)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DEBUG</span></span><br><span class="line"><span class="comment">/// Returns true if an object is weakly referenced somewhere.</span></span><br><span class="line"><span class="comment">/// 如果 weak_table 中有关于这个对象的数据，返回 true</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">weak_is_registered_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Called on object destruction. Sets all remaining weak pointers to nil.</span></span><br><span class="line"><span class="comment">/// 在对象的析构方法中调用，设置所有的弱引用指针为 nil</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">weak_clear_no_lock</span><span class="params">(<span class="keyword">weak_table_t</span> *weak_table, id referent)</span></span>;</span><br></pre></td></tr></table></figure><p>这几个方法都是常规的操作哈希表的方法，计算哈希码，插入或者删除合适的数据，重新哈希等等。</p><p>我们知道，weak 引用的特性是，当对象被释放后，它就会被设置为 <code>nil</code>，避免造成野指针。</p><p><strong>野指针</strong>：野指针的概念是，当某个指针指向的内存被回收后，该指针变量保存的仍然是那块内存的地址，就会造成访问错误内存的 crash，通常的崩溃信息是 <code>BAD_ACCESS</code>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a); <span class="comment">// BAD_ACCESS crash</span></span><br></pre></td></tr></table></figure><p>崩溃的前提是，指针指向的内存被回收，因为 <code>free()</code> 函数释放的内存不会被立刻回收，所以这段代码可能不会直接崩溃，一旦 <code>a</code> 指向的内存被回收，就肯定会崩溃。因此，我们需要手动将指针设置为 <code>NULL</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span> *));</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line">a = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, a); <span class="comment">// OK, note: 被设置为 NULL 的指针，不要再用*访问它</span></span><br></pre></td></tr></table></figure><p>weak 引用的这种特性配合 ARC 就大大减少了野指针出现的概率。我们来看 runtime  的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Called by dealloc; nils out all weak pointers that point to the </span></span><br><span class="line"><span class="comment"> * provided object so that they can no longer be used.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 在 dealloc 函数中调用，将所有该对象的弱引用设置为 nil，所有它们不应该再被使用。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param weak_table </span></span><br><span class="line"><span class="comment"> * @param referent The object being deallocated. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">weak_clear_no_lock(<span class="keyword">weak_table_t</span> *weak_table, id referent_id) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将 id 类型转换为 objc 类型</span></span><br><span class="line">    objc_object *referent = (objc_object *)referent_id; </span><br><span class="line"><span class="comment">// 通过 object 找到 table 中存的值</span></span><br><span class="line">    <span class="keyword">weak_entry_t</span> *entry = weak_entry_for_referent(weak_table, referent);</span><br><span class="line">    <span class="comment">// assert(entry)</span></span><br><span class="line">    <span class="keyword">if</span> (entry == nil) &#123;</span><br><span class="line">        <span class="comment">/// XXX shouldn't happen, but does with mismatched CF/objc</span></span><br><span class="line">        <span class="comment">//printf("XXX no entry for clear deallocating %p\n", referent);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// zero out references</span></span><br><span class="line">    <span class="keyword">weak_referrer_t</span> *referrers;</span><br><span class="line">    <span class="keyword">size_t</span> count;</span><br><span class="line">    <span class="comment">// 判断是否需要 set</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="comment">// 如果是，将 referrers 指向 set</span></span><br><span class="line">        referrers = entry-&gt;referrers;</span><br><span class="line">        count = TABLE_SIZE(entry);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不是，将 referrers 指向内联数组</span></span><br><span class="line">        referrers = entry-&gt;inline_referrers;</span><br><span class="line">        count = WEAK_INLINE_COUNT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 迭代集合，依次将集合内的指针设置为 nil</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">        objc_object **referrer = referrers[i];</span><br><span class="line">        <span class="keyword">if</span> (referrer) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*referrer == referent) &#123;</span><br><span class="line">                *referrer = nil;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*referrer) &#123;</span><br><span class="line">                <span class="comment">// 如果 *referrer != nil &amp;&amp; *referrer != referent，断点并报错</span></span><br><span class="line">                _objc_inform(<span class="string">"__weak variable at %p holds %p instead of %p. "</span></span><br><span class="line">                             <span class="string">"This is probably incorrect use of "</span></span><br><span class="line">                             <span class="string">"objc_storeWeak() and objc_loadWeak(). "</span></span><br><span class="line">                             <span class="string">"Break on objc_weak_error to debug.\n"</span>, </span><br><span class="line">                             referrer, (<span class="keyword">void</span>*)*referrer, (<span class="keyword">void</span>*)referent);</span><br><span class="line">                objc_weak_error();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后将 entry 从 weak_table 中删除</span></span><br><span class="line">    weak_entry_remove(weak_table, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的具体实现请看注释。</p><p><strong>NOTE：</strong><code>referent</code> 指向 <code>object</code>，<code>referrer</code> 指向 <code>referent</code>，也就是 <code>referrer</code> 中保存的是 weak 变量的地址。</p><p>这个方法的作用是清空某个对象的所有弱引用，并将它们设置为 <code>nil</code>，它会在对象的析构方法（<code>-dealloc</code>）中调用，runtime 在管理对象生命周期的过程中会帮助我们统一调用。</p><p>在对 <code>weak_table</code> 进行清空操作之前，runtime 会根据 <code>isa</code> 指针的 64 位地址空间的某一位判断这个对象是不是有弱引用，<a href="https://zhangxiaom.github.io/2018/06/26/isa%E6%8C%87%E9%92%88%E4%B8%AD%E9%9A%90%E8%97%8F%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95/" target="_blank" rel="noopener">isa指针中隐藏的黑魔法</a>，如果有，再执行清空操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isa.weakly_referenced) &#123;</span><br><span class="line">    weak_clear_no_lock(&amp;table.weak_table, (id)<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>weak_entry</code> 中保存的也是集合，因此，当我们向 <code>weak_table</code> 中插入或者删除一条数据时，runtime 会间接的处理 <code>weak_entry</code>，当我们插入一条数据时，它会先判断键值对是否存在，如果存在就直接向 <code>weak_entry</code> 中插入一条数据，如果不存在，则新建一个 <code>weak_entry</code>，然后插入一条数据，向 <code>weak_entry</code> 中添加数据的实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Add the given referrer to set of weak pointers in this entry.</span></span><br><span class="line"><span class="comment"> * Does not perform duplicate checking (b/c weak pointers are never</span></span><br><span class="line"><span class="comment"> * added to a set twice). </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 将给定的 referrer 添加进 weak_entry 中的 set</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param entry The entry holding the set of weak pointers. </span></span><br><span class="line"><span class="comment"> * @param new_referrer The new weak pointer to be added.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">append_referrer</span><span class="params">(<span class="keyword">weak_entry_t</span> *entry, objc_object **new_referrer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 是否不需要 set</span></span><br><span class="line">    <span class="keyword">if</span> (! entry-&gt;out_of_line()) &#123;</span><br><span class="line">        <span class="comment">// Try to insert inline.</span></span><br><span class="line">        <span class="comment">// 将 new_referrer 添加进内联数组的尾部</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry-&gt;inline_referrers[i] == nil) &#123;</span><br><span class="line">                entry-&gt;inline_referrers[i] = new_referrer;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Couldn't insert inline. Allocate out of line.</span></span><br><span class="line">        <span class="comment">// 创建 set</span></span><br><span class="line">        <span class="keyword">weak_referrer_t</span> *new_referrers = (<span class="keyword">weak_referrer_t</span> *)</span><br><span class="line">            <span class="built_in">calloc</span>(WEAK_INLINE_COUNT, <span class="keyword">sizeof</span>(<span class="keyword">weak_referrer_t</span>));</span><br><span class="line">        <span class="comment">// This constructed table is invalid, but grow_refs_and_insert</span></span><br><span class="line">        <span class="comment">// will fix it and rehash it.</span></span><br><span class="line">        <span class="comment">// 将内联数组的内容拷贝到新创建的 set</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; WEAK_INLINE_COUNT; i++) &#123;</span><br><span class="line">            new_referrers[i] = entry-&gt;inline_referrers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 配置 entry</span></span><br><span class="line">        entry-&gt;referrers = new_referrers;</span><br><span class="line">        entry-&gt;num_refs = WEAK_INLINE_COUNT;</span><br><span class="line">        entry-&gt;out_of_line_ness = REFERRERS_OUT_OF_LINE;</span><br><span class="line">        entry-&gt;mask = WEAK_INLINE_COUNT<span class="number">-1</span>;</span><br><span class="line">        entry-&gt;max_hash_displacement = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(entry-&gt;out_of_line());</span><br><span class="line"><span class="comment">// 当 set 的装填因子大于 3/4 时，扩展 size 并重新 hash</span></span><br><span class="line">    <span class="keyword">if</span> (entry-&gt;num_refs &gt;= TABLE_SIZE(entry) * <span class="number">3</span>/<span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grow_refs_and_insert(entry, new_referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算哈希码</span></span><br><span class="line">    <span class="keyword">size_t</span> begin = w_hash_pointer(new_referrer) &amp; (entry-&gt;mask);</span><br><span class="line">    <span class="keyword">size_t</span> index = begin;</span><br><span class="line">    <span class="keyword">size_t</span> hash_displacement = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 线性探测法解决哈希冲突</span></span><br><span class="line">    <span class="keyword">while</span> (entry-&gt;referrers[index] != nil) &#123;</span><br><span class="line">        hash_displacement++;</span><br><span class="line">        index = (index+<span class="number">1</span>) &amp; entry-&gt;mask;</span><br><span class="line">        <span class="keyword">if</span> (index == begin) bad_weak_table(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hash_displacement &gt; entry-&gt;max_hash_displacement) &#123;</span><br><span class="line">        entry-&gt;max_hash_displacement = hash_displacement;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由哈希码得到 index，将数据插入到该 index 处</span></span><br><span class="line">    <span class="keyword">weak_referrer_t</span> &amp;ref = entry-&gt;referrers[index];</span><br><span class="line">    ref = new_referrer;</span><br><span class="line">    entry-&gt;num_refs++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的详细实现请看注释。</p><p>将 <code>referrer</code> 从 <code>weak_entry</code> 中移除的实现和插入差不多，首先判断是否用内联数组，如果是，直接顺序查找后设置为 <code>nil</code>，如果不是，计算哈希码，通过哈希码找到那个指针，设置为 <code>nil</code>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>runtime 对弱引用的处理，基本上和大部分博客的内容是不一致的，用哈希表存储是没错的，不同的是，哈希表中存储的是一个集合的结构，而不是 &lt;&amp;object, pointer&gt; 这种简单的键值对。当然还有很多细节的处理，比如轻便的内联数组、集合的扩充、解决哈希冲突、特别多的对指针和引用的操作等等。</p><p>鸡汤时刻，信息爆炸的时代，在接受信息的同时，还应该学会筛选和质疑，哥白尼、伽利略了解一下！😂😂</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;提及 weak 引用，大多数人都知道在什么时候要用它，如果不知道的话：&lt;a href=&quot;https://zhangxiaom.github.
      
    
    </summary>
    
    
      <category term="内存管理" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程与 GCD</title>
    <link href="http://yoursite.com/2018/07/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%8E-GCD/"/>
    <id>http://yoursite.com/2018/07/07/多线程编程与-GCD/</id>
    <published>2018-07-07T04:16:27.000Z</published>
    <updated>2019-09-01T03:37:02.778Z</updated>
    
    <content type="html"><![CDATA[<p>如果你还不了解进程的话，请参考：<a href="https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">并发编程之进程</a>，进程是由完整的逻辑控制流和独立的地址空间构成的，一个线程就是进程中一个单一顺序的逻辑控制流，由进程调度的线程被称为用户级线程，由内核调度的被称为内核线程（轻量级进程），这里仅讨论用户级线程。多个进程可以被操作系统调度而组成多进程程序，同样的，多个线程也可以被进程调度而组成多线程编程，同一进程的多个线程共享该进程的地址空间，也就是整个进程的虚拟内存都是该进程内所有线程的共享内存。</p><h3 id="一、几个概念"><a href="#一、几个概念" class="headerlink" title="一、几个概念"></a>一、几个概念</h3><h4 id="1-1-同步-vs-异步"><a href="#1-1-同步-vs-异步" class="headerlink" title="1.1 同步 vs 异步"></a>1.1 同步 vs 异步</h4><p>同步和异步的概念是针对指令，不针对线程，也就是仅用主线程也能进行异步操作，所以异步的并不一定是多线程的，同步的指令也不一定只是主线程执行的。假如将一个同步或者异步任务视为一个指令集的话，执行同步任务的线程会等待该指令集执行完再去执行该指令集的下一条指令，而异步任务会直接跳过当前指令集去执行下一条指令，当执行该指令集的线程空闲的时候才会执行该指令集。所以异步任务不会阻塞当前线程。</p><h4 id="1-2-并发-vs-并行"><a href="#1-2-并发-vs-并行" class="headerlink" title="1.2 并发 vs 并行"></a>1.2 并发 vs 并行</h4><p>这两个概念是很多人比较容易混淆的概念，有人会说并发是并行的子集，只要是并行的，一定是并发的，但是并发的不一定是并行的，因为牵扯到线程调度（单核 CPU 的情况下，多个线程交替使用 CPU）的问题。那么有个问题请思考一下，假设我们的程序运行在一个四核 CPU 的设备上，也就是此时操作系统是支持并行的，但是我们设计的程序仅仅使用的主线程，比如说打印了一个 Hello world，那么此时能说并行的一定是并发的吗？</p><p>其实这两个概念相关联但是又不是那么关联，并行表述的是能力，并发表述的是程序结构，也就是具有双核以上 CPU 的系统具有并行的能力，我们写的代码是支持并发的程序结构。在具有并行能力的系统上执行的并发结构的程序一定是并发的，即使在不具有并行能力的系统（单核）上执行的并发结构的程序仍然是并发的。</p><h4 id="1-3-线程-vs-队列"><a href="#1-3-线程-vs-队列" class="headerlink" title="1.3 线程 vs 队列"></a>1.3 线程 vs 队列</h4><p>对 iOS 来说，特别是习惯使用 GCD 的开发者，线程和队列也是需要区分的概念，队列和线程本质上并不是一一对应的关系（其实主线程不一定只执行主队列的指令）。GCD 会为我们的程序提供几种类型的队列（主队列，全局并发队列，串行队列，并发队列），我们只需要将任务以同步或者异步的形式添加进队列，GCD 会调度需要的线程帮我们依次执行队列中的任务。</p><h4 id="1-4-context（上下文）"><a href="#1-4-context（上下文）" class="headerlink" title="1.4 context（上下文）"></a>1.4 context（上下文）</h4><p><strong>context</strong> 一般被翻译为上下文，是一个抽象的概念，在 iOS 中也经常出现（CGContext），其实我们可以将它理解为一个作为数据模型的结构体，它保存了当前对象此时所有的状态信息，比如要绘制一个 <code>UILabel</code>，此时绘制对象的 <code>context</code> 里就会保存我们为 <code>UILabel</code> 设置的信息，比如背景颜色、字体、字号等等，然后负责绘制的对象会从 <code>context</code> 中取出这些属性完成绘制。对进程和线程来说是一样的，当进程被抢占时，它的 <code>context</code> 中就会保存进程此时的状态信息，等进程重新进入运行状态时，调度程序就会将进程信息恢复。</p><h3 id="二、线程调度"><a href="#二、线程调度" class="headerlink" title="二、线程调度"></a>二、线程调度</h3><p>和进程一样，线程也有一个上下文保存它当前执行的状态信息，比如堆栈信息、PC、寄存器等等，当该线程被抢占挂起时，上下文就会保存此时线程执行的栈帧、寄存器状态等等，线程的调度也被称为<strong>上下文切换</strong>。就像进程一样，线程也是交替使用 CPU 的，因为对于交互式程序来说，runloop 的存在就造成主线程一直占有 CPU 资源，线程的调度可以避免其他子线程<strong>饿死</strong>。</p><p>当多进程和多线程共存的情况下，对于线程的调度就分为两种情况。</p><ul><li><p>由进程调度</p><p>调度程序将时间片分配给进程，进程通过调度算法将时间片分配给线程，此时线程的上下文切换由进程决定，比如一个进程得到 10 ms 的时间片，它会根据自身的调度算法将时间片分配给线程，等时间片用完，调度程序会将该进程挂起，进程内正在执行的线程也会挂起，进程会保存所有线程的上下文，这是用户级线程常用的调度方式。</p></li><li><p>由调度程序调度</p><p>调度程序负责调度线程，比如进程 A 和进程 B 分别有三个线程 A1, A2, A3, B1, B2, B3，调度程序分配 10ms 的时间片给线程 A1，10ms 过后分配 10ms 的时间片给 B1，此时既要切换进程的上下文，也要切换线程的上下文，因此，这种调度方式会带来更大的开销。线程的上下文由内核保存，一般来说，内核级线程会使用这种调度方式。</p></li></ul><p>图示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-ebe04302a61f6c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="三、线程同步—锁"><a href="#三、线程同步—锁" class="headerlink" title="三、线程同步—锁"></a>三、线程同步—锁</h3><p>同一进程的多个线程会共享该进程的地址空间，比如数据段、文本段、堆等。当多个线程并发的访问同一块内存段时，就会产生竞态条件导致的线程安全问题。锁就是为了解决这些问题，也填一下<a href="https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">并发编程之进程</a>里进程同步问题留下的坑。</p><p><strong>临界区：</strong></p><p>理解临界区的概念是解决线程安全和并发编程模型的重要依据。</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-efac21c2f2657b32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>上图即为并发的情况下，临界区不安全的示例，T2 ~ T3 时间段 线程 A 和线程 B 同时访问临界区。我们可能会疑惑的地方是，单核 CPU 的系统中，存在这种并行的情况吗？其实即使在不支持并行的系统中，同样会有这种并发问题：在时间 T2，线程 A 的时间片用完，线程 A 挂起，此时 A 的上下文中记录它的执行状态，切换到线程 B 执行，线程 B 用完时间片记录执行状态，切换回线程 A，此时调度程序读取的线程 A 的执行状态为时间点 T2，因此此时相当于线程 A 回到时间点 T2 继续执行，直到下一次切换。所以我们可以把这种上下文切换的情况描述为上图中的<strong>并行</strong>，实则为<strong>并发</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量 _sum</span></span><br><span class="line"><span class="keyword">int</span> _sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 并发执行函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start %d\n"</span>, _sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        _sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum of 0 ~ 9999 is %d\n"</span>, _sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="comment">// 创建两个线程，执行 thr_fn</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> ntid;</span><br><span class="line">        pthread_create(&amp;ntid, <span class="literal">NULL</span>, thr_fn, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>log 的结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个结果不是唯一的，因为结果取决于线程切换的时机(竞态条件)</span></span><br><span class="line">start <span class="number">0</span></span><br><span class="line">start <span class="number">1021735</span></span><br><span class="line">sum of <span class="number">0</span> ~ <span class="number">9999</span> is <span class="number">46697501</span></span><br><span class="line">sum of <span class="number">0</span> ~ <span class="number">9999</span> is <span class="number">84364406</span></span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们可以计算得到 0~9999 的和为 49995000，因此两个子线程的执行的结果都不是我们想要的结果，其实上图很好的解释这段代码的执行过程，线程 B 迭代之前获取的初始值并不是我们想要的线程 A 的执行结果，是因为在时间点 T2，线程 B 读取的临界区的值为线程 A 的 T1 ~ T2 时间段的执行结果，此时我们得到的结果就是竞态条件造成的。</p><p>锁能帮助我们解决这个问题，当这段代码加锁后的执行过程为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-a6f1fe1e040563fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在时间 T2 线程 B 试图进入临界区时，由于临界区被加锁，所以线程 B 被阻塞，当线程 A 将临界区解锁后，线程 B 才能进入临界区。加锁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start %d\n"</span>, _sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        _sum += i;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"sum of 0 ~ 10000 is %d\n"</span>, _sum);</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>log 结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start <span class="number">0</span></span><br><span class="line">sum of <span class="number">1</span> ~ <span class="number">10000</span> is <span class="number">49995000</span></span><br><span class="line">start <span class="number">49995000</span></span><br><span class="line">sum of <span class="number">1</span> ~ <span class="number">10000</span> is <span class="number">99990000</span></span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><p>互斥锁</p><p>上述例子中所使用的 <code>pthread_mutex_t</code> 即为互斥锁，互斥锁其实也是一个共享的全局变量，当该变量满足一定的条件时，允许线程访问临界区，否则该线程即被挂起。我们可以将该互斥锁想象成现实中的锁，锁的初始值的打开的，线程 A 进入房间（临界区）后，将锁锁住（时刻 T1），当线程 B 想进入房间时（时刻 T2），此时房间上锁，它只能挂起等待，直到线程 A 离开房间并且将锁打开（时刻 T3），线程 B 才能进入房间，并将锁锁住。</p></li><li><p>自旋锁</p><p>自旋锁是特殊的互斥锁，特殊的地方是，当线程访问锁变量时，会一直不停的询问锁变量的状态，也就是在 T2 时刻，线程 B 不会被阻塞而是一直不停（死循环）的访问锁变量，直到它的时间片被消耗完或者锁被打开。因此，互斥锁会在临界区加锁时马上进行上下文切换，而自旋锁会不停的死循环，因此自旋锁会消耗更多的 CPU 资源，在不确定临界区执行时间的前提下，慎用自旋锁。</p></li><li><p>信号量</p><p>互斥锁的概念标定了它只能有两种状态，就是加锁和未加锁，而信号量可以控制进入临界区的线程数量， 信号量被定义为一个正整数，当线程要进入临界区时，会首先访问信号量，当信号量大于 0 时，就代表可以进入临界区， 并将信号量减一，当信号量等于 0 时，线程就会被阻塞，当线程出了临界区时，会将信号量加一。</p></li><li><p>同步锁</p><p>同步锁是 objc 语言特有的一种锁，<code>@synchronized{}</code>，代码块中的内容即为临界区，它会被编译器替换为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line">@synchronized&#123;</span><br><span class="line">    work();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译器替换后</span></span><br><span class="line">objc_sync_enter(obj);</span><br><span class="line">work();</span><br><span class="line">objc_sync_exit(obj);</span><br></pre></td></tr></table></figure><p>我们可以从 runtime 动态库中的 <code>&lt;objc/objc-sync.h&gt;</code>（<a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.h" target="_blank" rel="noopener">在这</a>）中找到这两个方法的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Begin synchronizing on 'obj'.  </span></span><br><span class="line"><span class="comment"> * Allocates recursive pthread_mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param obj The object to begin synchronizing on.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">OBJC_EXPORT  <span class="keyword">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    <span class="title">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.3</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param obj The objet to end synchronizing on.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">OBJC_EXPORT  <span class="keyword">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    <span class="title">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.3</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>进一步从实现文件中，我们可以得到的结论是：<code>objc_sync_enter()</code> 会为 <code>obj</code> 生成并关联一个递归锁，然后将临界区的内容加锁，临界区代码执行完后，调用 <code>objc_sync_exit()</code> 解锁。</p></li><li><p>NSLock</p><p>NSLock 是对 <code>pthread_mutex_t</code> 的对象封装。</p></li></ul><p><strong>NOTE</strong>：除了同步锁，其他几个锁都是不可重入锁，如果重复加同一个锁，就会造成死锁，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br></pre></td></tr></table></figure><p>这样锁变量将永远不会处于解锁状态导致死锁。</p><h3 id="四、GCD-中的多线程编程"><a href="#四、GCD-中的多线程编程" class="headerlink" title="四、GCD 中的多线程编程"></a>四、GCD 中的多线程编程</h3><p>GCD 是对 POSIX 线程的高级封装，它会帮我们管理线程的生命周期，我们只需要将要执行的任务（block）以同步或者异步的形式添加进队列中，GCD 会选择合适的线程去执行任务。队列就是一种先入先出的数据结构，因此，添加进队列中的任务的执行顺序即为入队的顺序，而执行完成的顺序，取决于线程的调度、任务的长短、队列是串行还是并发、同步任务还是异步任务等等。</p><p><strong>NOTE</strong>：我们所有没有添加进队列的任务其实就是主线程在执行，我们可以将这些任务理解为同步串行任务，也就是所有的函数顺序执行，当前函数执行完才会执行下一个，这些任务包含 <code>dispatch_sync()</code> 和 <code>dispatch_async()</code>。大概的模型就是这样（忽略任务之间空隙）：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-b3a0b67c91fe605f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面的讨论的队列均不包含主队列。我们将 <code>dispatch_sync()</code> 和 <code>dispatch_async()</code> 定义为一个 Task。并且将上下文切换以并行（伪并行）的形式描述。</p><h4 id="4-1-同步串行"><a href="#4-1-同步串行" class="headerlink" title="4.1 同步串行"></a>4.1 同步串行</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.xm.test.serialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// Task1</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line"><span class="comment">// Task2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task2"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [<span class="built_in">NSThread</span> isMainThread]); </span><br><span class="line">    <span class="comment">// log result is 1.</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Task3</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line"><span class="comment">// task4</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// task5</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task5"</span>);</span><br></pre></td></tr></table></figure><p>此时这段代码的执行情况理论上应该为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-7de31071475c4fa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在时间 T1 处切换到子线程执行加入 <code>serialQueue</code> 中的同步任务 <code>Task2</code>，直到任务执行完，切回主线程继续执行 <code>Task3</code>。同步任务阻塞主线程的原因是：主线程在等待 <code>dispatch_sync()</code> 函数返回，而 <code>dispatch_sync()</code> 函数在等待 <code>Task2</code> 返回，因此，即使同步任务由子线程完成，它依然会阻塞主线程。实际上，GCD 会帮我们做一些优化：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-43745da8a0d48a26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>GCD 会直接返回 <code>dispatch_sync()</code> 函数，然后在主线程执行同步任务，这样就避免了多余的上下文切换的开销。</p><h4 id="4-2-同步并发"><a href="#4-2-同步并发" class="headerlink" title="4.2 同步并发"></a>4.2 同步并发</h4><p>同样是上面的示例代码，我们将串行队列，替换为并发队列：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.xm.test.concurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">// Task1</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line"><span class="comment">// Task2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task2"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [<span class="built_in">NSThread</span> isMainThread]); </span><br><span class="line">    <span class="comment">// log result is 1.</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Task3</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line"><span class="comment">// task4</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// task5</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task5"</span>);</span><br></pre></td></tr></table></figure><p>此时，理论上的任务的执行方式为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-0daa148ae166e0cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>实际上 GCD 仍然会做上面的优化：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-f23c4a04836b7903.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>即使是添加进并发队列的同步任务也会阻塞主线程，理由同上，因此，GCD 同样会将任务放到主线程去执行，避免了上下文切换的开销。</p><h4 id="4-3-异步串行"><a href="#4-3-异步串行" class="headerlink" title="4.3 异步串行"></a>4.3 异步串行</h4><p>我们现在将 4.1 中的同步方法改成异步方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.xm.test.serialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// Task1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line"><span class="comment">// Task2 (可使用 for 循环模拟线程阻塞，看代码的输出顺序)</span></span><br><span class="line"><span class="comment">// for (int i = 0; i &lt; 1000; ++i) &#123;&#125;</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task2"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [<span class="built_in">NSThread</span> isMainThread]); </span><br><span class="line">    <span class="comment">// log result is 0.</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Task3</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"><span class="comment">// task4</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// task5</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task5"</span>);</span><br></pre></td></tr></table></figure><p>主线程会在执行 <code>dispatch_async()</code> 时将任务加入 <code>serialQueue</code> 然后立刻返回执行下一条指令，同时调度子线程去执行加入队列中的任务，此时任务执行完成的时机依赖于调度程序的调度、任务的长短和加入队列中的顺序。</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-e70e3cc5db0846cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>NOTE</strong>：当该示例中的队列为主队列时，异步任务会添加进主队列的队尾，当主线程执行完主队列中其他任务时，才会去执行该任务。</p><h4 id="4-4-异步并发"><a href="#4-4-异步并发" class="headerlink" title="4.4 异步并发"></a>4.4 异步并发</h4><p>将 4.2 中的同步改为异步：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.xm.test.concurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">// Task1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line"><span class="comment">// Task2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task2"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [<span class="built_in">NSThread</span> isMainThread]); </span><br><span class="line">    <span class="comment">// log result is 0.</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Task3</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line"><span class="comment">// task4</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// task5</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task5"</span>);</span><br></pre></td></tr></table></figure><p>此时：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-1710825fa0fa14cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>任务执行完成的顺序仍然依赖于调度程序分配的时间片、任务的长度等。<code>Task4</code> 会在 <code>dispatch_async2()</code> 执行后加入队列，GCD 会分配合适的线程去执行它。</p><h4 id="4-5-死锁"><a href="#4-5-死锁" class="headerlink" title="4.5 死锁"></a>4.5 死锁</h4><p>同步任务是造成死锁的主要原因，假如将 4.1 中的串行队列换成主队列的话，此时主队列在等待 <code>dispatch_sync()</code> 返回，<code>dispatch_sync()</code> 在等待 <code>block</code> 返回，block 被添加进主队列，并且在 <code>dispatch_sync()</code> 之后，因此，<code>dispatch_sync()</code> 返回后才能执行 block，这样就造成了 <code>dispatch_sync()</code> 和 block 之间的循环等待而造成死锁（只有添加进非主队列的同步任务，GCD 才会优化）。</p><p><strong>NOTE：</strong>GCD 造成的死锁不是<a href="https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">并发编程之进程</a>中所描述的进程同步造成的死锁，也就是，这里的死锁不是多个线程争夺共享资源造成的死锁，而是由于同步任务和串行队列的性质造成的死锁，两者都是造成死锁的充分非必要条件。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在实际工作中，并发带来的问题是比较让人头痛的问题。本文以最简单的模型分析并发时多个线程协同工作的原理，当然必须理解原理才能在工作中更好的分析并发带来的问题。推荐一本书 《现代操作系统》，虽然它不讲 GCD，但是看了它再去理解 GCD 有种豁然开朗的感觉。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你还不了解进程的话，请参考：&lt;a href=&quot;https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/&quot; target
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>dyld 和链接</title>
    <link href="http://yoursite.com/2018/07/01/dyld-%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2018/07/01/dyld-和链接/</id>
    <published>2018-07-01T09:46:31.000Z</published>
    <updated>2019-09-01T03:37:02.776Z</updated>
    
    <content type="html"><![CDATA[<p>代码从写完到编译到运行之间发生了什么？我们的程序是如何在设备上执行的？为什么我们代码中没有的库函数也能执行？在工作中我们可能常常会疑惑这样的问题，下面我们来探究一下这些问题。在阅读本文之前，需要充分了解进程的概念：<a href="https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">并发编程之进程</a>。</p><h3 id="一、编译"><a href="#一、编译" class="headerlink" title="一、编译"></a>一、编译</h3><p>编译是一个很复杂的过程，往往也是检验我们代码正确与否的第一步，编译器会帮助我们做很多很多很多事，比如，语法分析、词法分析、类型检查、预处理、生成中间代码等等，本文着重介绍链接，所以关于编译的过程也不会展开太多。那么，点击编译器的编译按钮后，编译器主要做了什么工作呢？</p><ul><li><p>源程序分析。语法分析、词法分析、语义分析、类型检查等等，这一阶段的目标是主要是检查代码有没有错误，就像我们常见的 <code>error</code> 和 <code>warning</code> 就是这个阶段确定的。</p></li><li><p>预处理。预处理器会展开目标模块导入的头文件和替换宏定义，预处理后生成 <code>*.i</code> 文件。</p></li><li><p>编译。编译器将 <code>*.i</code> 文件编译成 ASCII 汇编语言文件 <code>*.s</code>。</p></li><li><p>汇编。汇编器将 <code>*.s</code> 文件汇编成一个可重定位的二进制目标文件<code>*.o</code>，Mac OS 和 iOS 中称为 Mach-O文件。</p></li><li><p>链接。链接分为动态链接和静态链接，链接器将所有的目标文件和系统目标文件组合起来，生成能在机器上运行的可执行文件。iOS 中为 <code>*.ipa</code>，Windows 中为 <code>*.exe</code>，Android 中为 <code>*.apk</code> 等等。</p></li></ul><p>例如两段 c 代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mian.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sum.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    sum(arr, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="comment">// sum.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，它们的编译过程为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-076779743e52d486.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><code>sum.c</code> 和 <code>main.c</code> 源文件分别被单独编译成目标文件，然后经过链接器链接成可执行文件。</p><h3 id="二、链接"><a href="#二、链接" class="headerlink" title="二、链接"></a>二、链接</h3><p>链接就是上面的例子那样，将若干个目标文件组合成单一可执行文件的过程，这个文件被加载到内存中并执行。链接发生的时机可能为：编译时（源代码被翻译成机器代码时），加载时（程序被加载到内存中时），运行时。</p><p>在 iOS 开发中，我们会经常用到 cocoapod，或者引入一些第三方的 sdk，例如，<code>*.a</code>，<code>*.framework</code> 等等。这些就是可以独立编译成目标文件的动态库和静态库。</p><h4 id="2-1-静态链接"><a href="#2-1-静态链接" class="headerlink" title="2.1 静态链接"></a>2.1 静态链接</h4><p>如上述例子即为静态链接，在程序加载进内存之前就完成两个目标文件的链接工作。我们知道目标文件是机器可识别的二进制文件，其中指令被存放在 <code>__TEXT</code> 内存段中，数据被存储在 <code>__DATA</code> 内存段中。</p><p>目标文件和进程的地址空间一样也是由一系列不间断的字节序列组成，这些字节序列包括：<code>.text</code>（指令集）、<code>.rodata</code>（只读数据）、<code>.data</code>（已初始化的全局和静态变量）、<code>.bss</code>（未初始化的全局和静态变量）、<code>.symtab</code>（符号表）、debug 信息等等。</p><p>目标文件是可以独立编译并运行的，一旦它被加载进内存中并运行，我们就可以将它视为一个进程，而进程虚拟内存的概念就决定了它所有的数据和指令都是从 <code>0x0</code> 开始布局的，因此，目标文件也是从 0x0 开始布局的。</p><p>符号表是一个陌生的概念，上面例子中的 <code>sum</code> 即为函数 <code>sum()</code> 的符号名称被存储在符号表中，只有在该模块中被外部可见的符号或者 <code>static</code> 修饰的符号才会被存储在符号表中，该模块私有的符号对其他模块来说没有意义，链接器也不关心它们。符号表中每个符号都对应一个结构体，结构体中存储了该符号对应的函数地址。</p><p>拿上面的例子来说，编译器会展开 <code>sum.h</code> 得到 <code>sum()</code> 的声明，当编译器在 <code>sum.s</code> 中找不到该函数的实现时，就会生成一个符号条目，扔给链接器处理，如果链接器在其他模块也没找到该函数的定义，就会造成链接中断，并报错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols <span class="keyword">for</span> architecture x86_64:</span><br><span class="line">  <span class="string">"_sum"</span>, referenced from:</span><br><span class="line">      _main in main.o</span><br><span class="line">ld: symbol(s) <span class="keyword">not</span> found <span class="keyword">for</span> architecture x86_64</span><br><span class="line">clang: error: linker command failed with <span class="built_in">exit</span> code <span class="number">1</span> (use -v to see invocation)</span><br></pre></td></tr></table></figure><h4 id="2-2-重定向符号引用"><a href="#2-2-重定向符号引用" class="headerlink" title="2.2 重定向符号引用"></a>2.2 重定向符号引用</h4><p>静态链接器解析目标文件中的符号，并且重定位它们，使所有目标文件中的符号在可执行文件中有正确的位置。比如代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...   </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, World!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器将它编译成机器代码（<code>clang -c main.c -o main.o -Os</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main.o:</span><br><span class="line">(__TEXT,__text) section <span class="comment">// __TEXT 段，__text 节</span></span><br><span class="line">_main:</span><br><span class="line"><span class="number">0000000000000000</span>pushq%rbp</span><br><span class="line"><span class="number">0000000000000001</span>movq%rsp, %rbp</span><br><span class="line"><span class="number">0000000000000004</span>leaq<span class="number">0x9</span>(%rip), %rdi</span><br><span class="line"><span class="number">000000000000000b</span>callq<span class="number">0x10</span></span><br><span class="line"><span class="number">0000000000000010</span>xorl%eax, %eax</span><br><span class="line"><span class="number">0000000000000012</span>popq%rbp</span><br><span class="line"><span class="number">0000000000000013</span>retq</span><br></pre></td></tr></table></figure><p><code>callq</code> 指令是一个有符号偏移的跳转指令，也就是跳转到 <code>printf()</code> 函数，地址为 <code>0x10</code>（称为符号的引用），我们可以看到 <code>0x10</code> 处存放的是一个异或指令，因此汇编器会生成一个符号，存储到符号表中，交给链接器来处理（<code>printf()</code> 是 <code>libc.a</code> 静态库中的某个目标文件的函数）。</p><p>链接器会将定义 <code>printf()</code> 的目标文件和 <code>main.o</code> 链接成一个新的可执行文件：（<code>clang main.c -o main -Os</code>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(__TEXT,__text) section <span class="comment">// __TEXT 段，__text 节</span></span><br><span class="line">_main:</span><br><span class="line"><span class="number">0000000100000f</span>76pushq%rbp</span><br><span class="line"><span class="number">0000000100000f</span>77movq%rsp, %rbp</span><br><span class="line"><span class="number">0000000100000f</span>7aleaq<span class="number">0x29</span>(%rip), %rdi</span><br><span class="line"><span class="number">0000000100000f</span>81callq<span class="number">0x100000f8a</span></span><br><span class="line"><span class="number">0000000100000f</span>86xorl%eax, %eax</span><br><span class="line"><span class="number">0000000100000f</span>88popq%rbp</span><br><span class="line"><span class="number">0000000100000f</span>89retq</span><br></pre></td></tr></table></figure><p>链接之后的可执行文件中 <code>callq</code> 指令的目标地址被重定向成 <code>0x100000f8a</code>，也就是 <code>main()</code> 函数调用 <code>retq</code> 指令返回后的下一个地址。当可执行文件被加载进内存中时，<code>prinf()</code> 的指令集就会被加载器分配到 <code>0x100000f8a</code> 处。</p><p>链接器使用符号表来完成符号的重定向，如果没有符号表的话，仅靠 <code>0x10</code> 这种 magic value，链接器很难知道它是属于哪个目标模块的地址。因此，符号表和符号对链接来说很重要。</p><h4 id="2-3-静态库"><a href="#2-3-静态库" class="headerlink" title="2.3 静态库"></a>2.3 静态库</h4><p>假如链接器将所有相关的文件打包成一个单独的文件，就被称为静态库，就像我们熟悉的 <code>.a</code> 文件。第一个例子中的代码中的 <code>main()</code> 修改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">2</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    sum(arr, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则整个代码的编译过程为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-32688dce211add4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><code>libc.a</code> 静态库中的 <code>printf.o</code> 文件被链接进可执行文件，因为链接器只会复制静态库里被应用程序引用的目标模块。</p><p>静态库的存在降低了程序的耦合性和维护成本，但是当一个系统中很多程序都在引用 <code>libc.a</code> 时，每个程序都要拷贝一份它的副本，就会造成磁盘内存的极度浪费。</p><h4 id="2-4-动态链接和动态共享库"><a href="#2-4-动态链接和动态共享库" class="headerlink" title="2.4 动态链接和动态共享库"></a>2.4 动态链接和动态共享库</h4><p>我们在写 C 程序时，第一步要做的就是输入 <code>#include&lt;stdio.h&gt;</code>，在写 iOS 代码时，每个类都要导入 <code>CoreFoundation.h</code>，<code>stdio.h</code> 是 c 语言的标准输入输出库（standard input/output） <code>libc</code> 的头文件，几乎每个 c 程序都会用到。假如使用静态链接的话，每个程序都要拷贝一份。当每个程序都引入很多的标准库时，就会造成内存的极大浪费。</p><p>动态共享库（linux 中为 <code>*.so</code>）的出现就是为了解决静态库的缺陷，动态库同样也是一个目标模块，他不会被链接进任何其他目标模块，而是被加载进任意的内存地址，然后和一个加载到内存中的程序链接，这个过程称为动态链接。iOS 中的 dyld 就是一个动态链接器，负责程序的动态链接。</p><p>当我们将上述例子中的静态链接换成动态链接时，编译过程为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-3bfdbe3cc310c982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>动态链接器也会重定位符号的引用，比如上面例子中的 <code>0x10</code>，动态链接器会将动态库中的符号表拷贝到进程的内存中，然后像静态链接那样重定向它们在该进程空间内的引用，就是将目标文件中的地址修改为符号在进程内存中的地址。</p><p>静态链接将目标文件拷贝到磁盘中，被链接完成后加载进内存，动态链接在加载的时候拷贝到内存中，节省了磁盘空间。</p><h3 id="三、dyld"><a href="#三、dyld" class="headerlink" title="三、dyld"></a>三、dyld</h3><p>dyld (dynamic loader and linker) 是 iOS 和 Mac OS 系统中的动态加载器和链接器，它负责共享库的动态链接，比如 libobjc.A.dylib，Foundation.framework 等等。加载和链接是在程序启动时，<code>main()</code> 函数之前做的，dyld 主要做了什么？</p><p>打印一下堆栈信息如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* thread #<span class="number">1</span>, stop reason = breakpoint <span class="number">1.1</span></span><br><span class="line">  * frame #<span class="number">0</span>: <span class="number">0x00007fff5e29794a</span> libSystem.B.dylib`libSystem_initializer</span><br><span class="line">    frame #<span class="number">1</span>: <span class="number">0x000000010001ca7a</span> dyld`ImageLoaderMachO::doModInitFunctions(ImageLoader::LinkContext <span class="keyword">const</span>&amp;) + <span class="number">420</span></span><br><span class="line">    frame #<span class="number">2</span>: <span class="number">0x000000010001ccaa</span> dyld`ImageLoaderMachO::doInitialization(ImageLoader::LinkContext <span class="keyword">const</span>&amp;) + <span class="number">40</span></span><br><span class="line">    frame #<span class="number">3</span>: <span class="number">0x00000001000181cc</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">330</span></span><br><span class="line">    frame #<span class="number">4</span>: <span class="number">0x000000010001815f</span> dyld`ImageLoader::recursiveInitialization(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>*, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">221</span></span><br><span class="line">    frame #<span class="number">5</span>: <span class="number">0x0000000100017302</span> dyld`ImageLoader::processInitializers(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, <span class="keyword">unsigned</span> <span class="keyword">int</span>, ImageLoader::InitializerTimingList&amp;, ImageLoader::UninitedUpwards&amp;) + <span class="number">134</span></span><br><span class="line">    frame #<span class="number">6</span>: <span class="number">0x0000000100017396</span> dyld`ImageLoader::runInitializers(ImageLoader::LinkContext <span class="keyword">const</span>&amp;, ImageLoader::InitializerTimingList&amp;) + <span class="number">74</span></span><br><span class="line">    frame #<span class="number">7</span>: <span class="number">0x0000000100008521</span> dyld`dyld::initializeMainExecutable() + <span class="number">126</span></span><br><span class="line">    frame #<span class="number">8</span>: <span class="number">0x000000010000d239</span> dyld`dyld::_main(macho_header <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">unsigned</span> <span class="keyword">long</span>*) + <span class="number">7242</span></span><br><span class="line">    frame #<span class="number">9</span>: <span class="number">0x00000001000073d4</span> dyld`dyldbootstrap::start(macho_header <span class="keyword">const</span>*, <span class="keyword">int</span>, <span class="keyword">char</span> <span class="keyword">const</span>**, <span class="keyword">long</span>, macho_header <span class="keyword">const</span>*, <span class="keyword">unsigned</span> <span class="keyword">long</span>*) + <span class="number">453</span></span><br><span class="line">    frame #<span class="number">10</span>: <span class="number">0x00000001000071d2</span> dyld`_dyld_start + <span class="number">54</span></span><br></pre></td></tr></table></figure><p>dyld 的工作大致分为以下几步：</p><ul><li><p>动态链接器自身就是一个共享目标文件，dyld 会首先将他自己加载进内存中并运行。</p></li><li><p>使用 <code>ImageLoader</code> 递归的向进程的内存空间中加载动态库。</p></li><li><p>加载可执行文件，重定向对动态库中符号的引用，完成链接工作。</p></li><li><p>初始化进程。</p></li><li><p>为 <code>main()</code> 函数准备参数和环境变量（argc，argv[]，envp[]）。</p></li><li><p>为运行中的程序动态链接一些懒加载的符号（链接也可能发生在运行时）。</p></li><li><p>在一些情况下，当 <code>main()</code> 函数返回时，调用 <code>exit</code> 指令退出当前进程。</p></li></ul><p>总结一下就是，当进程开始时，以 iOS 为例，就是点击了某个应用程序，dyld 会将可执行文件和它的共享库加载到内存中，将跨库 C 函数和变量引用链接到一起，然后在 <code>main</code> 函数开始执行。因此，从启动应用程序到我们写的代码开始执行，这段时间内都是 dyld 的工作。</p><p>注意：dyld 工作时，进程都是被内核管理的，直到可执行文件和动态库被链接并且加载完成，进程才开始运行在用户态。</p><h4 id="3-1-共享缓存"><a href="#3-1-共享缓存" class="headerlink" title="3.1 共享缓存"></a>3.1 共享缓存</h4><p>我们知道 objc 这门语言是动态特性的语言，对象的内存分配都是运行时来完成的，也就是它是一门重度依赖运行时的语言， 运行时以动态库的形式被 dyld 链接进进程的地址空间，因此，所有 iOS 中的应用程序都要在启动时链接运行时库。iOS 中程序所依赖的系统库并不只有运行时库一个，dyld 会在程序启动时链接它们，这样就会造成很大的时间和空间的开销。dyld 会通过共享缓存来优化这一点。</p><p>从上面对 dyld 的工作模式的分析，我们可以知道，每个进程的动态库都应该是不同的，因为它们分别被拷贝进不同的进程内存。事实上，dyld 的实现对这里进行了优化，它使用了共享缓存，共享缓存中保存了系统动态库的拷贝，大部分的系统库的加载和链接都是在程序启动前就完成的，所有的进程都会共享这部分内存，这样就可以节省了很多的启动时间和内存。共享内存是进程间通信的一种方式，可以参考我的这篇文章：<a href="https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">并发编程之进程</a>。</p><p>共享缓存解决了每个进程都要加载共享库的缺陷，dyld 的另一个工作是重定向符号表，就是上文中的第三步，在 iOS 和 Mac OS 中被称为 <code>selector</code> ，它就是 C 语言中符号的名称，例如上文中提到的 <code>sum</code>。我们可以从开源库中找到系统的动态库的符号列表：<a href="http://www.opensource.apple.com/source/objc4/objc4-371/runtime/objc-sel-table.h" target="_blank" rel="noopener">built-in selector table</a>，数据量不算小，这些符号保存了函数（指令）的实际地址，dyld 需要将它们拷贝的进程内存中，然后重定向对它们的引用（类似于静态链接的重定向，加载时完成）。</p><p>共享缓存会自己创建一个符号表，并且更新它们的引用，这样就可以使所有的进程都共享这些动态库的符号表，不用将符号表拷贝到自己的进程空间中，节约了拷贝的时间和空间，但是 dyld 仍要将目标文件中的符号地址重定向为共享缓存中的地址。</p><p>共享缓存的优化会节省一半的程序启动时间，也能为 iOS  设备节省 1MB 的内存。该结论由 runtime 源码的维护者：Hamster Emporium 的<a href="http://www.sealiesoftware.com/blog/archive/2009/09/01/objc_explain_Selector_uniquing_in_the_dyld_shared_cache.html" target="_blank" rel="noopener">这篇文章</a>给出。</p><h4 id="3-2-load"><a href="#3-2-load" class="headerlink" title="3.2  +load"></a>3.2  +load</h4><p>当 dyld 干完自己要干的事之后，进程就由内核态切换为用户态，这时候，运行时库 libobjc.dylib 会初始化自己，然后向所有静态链接进可执行文件的类对象发送 <code>+load</code> 消息，表示该类对象已经被加载进内存。对于动态链接的共享库中的类对象，runtime 会在共享库加载进进程的地址空间之后尽早的发送 <code>+load</code> 消息。</p><p>因此，无论动态链接还是静态链接的目标模块，我们都可以认为 runtime 发送给类对象的第一条消息就是 <code>+load</code>。</p><p>从 runtime 源码<a href="http://opensource.apple.com/source/objc4/objc4-532.2/runtime/objc-loadmethod.mm" target="_blank" rel="noopener"><code>objc-loadmethod.mm</code></a> 中，我们可以找到 <code>+load</code> 方法的调用时机，以及它在继承关系的类中的调用情况：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*call_load_methods （函数名）</span></span><br><span class="line"><span class="comment">* Call all pending class and category +load methods. （调用所有类和分类的 +load 方法）</span></span><br><span class="line"><span class="comment">* Class +load methods are called superclass-first. （先调用父类的 +load，在调用子类的）</span></span><br><span class="line"><span class="comment">* Category +load methods are not called until after the parent class's +load.（先调用类的 +load，在调用分类的）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 迭代的向所有类对象发送 `+load` 消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">    <span class="keyword">bool</span> more_categories;</span><br><span class="line"></span><br><span class="line">    loadMethodLock.assertLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.（重复调用该方法无效，最外层的调用将完成所有工作）</span></span><br><span class="line">    <span class="comment">// 注意： loading 是 static 变量</span></span><br><span class="line">    <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">    loading = YES;</span><br><span class="line"><span class="comment">// 自动释放池，管理迭代中生成的对象</span></span><br><span class="line">    <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">        <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Call all pending class +load methods.</span></span><br><span class="line">            call_class_loads();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">        <span class="comment">// category 的 `+load` 在所有类对象之后调</span></span><br><span class="line">        more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories);</span><br><span class="line"></span><br><span class="line">    objc_autoreleasePoolPop(pool);</span><br><span class="line"></span><br><span class="line">    loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，我们可以得到类对象的 <code>+load</code> 方法的调用时机和调用顺序，以及每个类对象只会被发送一次 <code>+load</code> 消息。</p><p>做个试验验证一下，创建几个类为：<code>Father</code>、<code>Son</code>、<code>GrandSon</code>、<code>Father+Extension</code>，然后重写每个类的 <code>+load</code>，函数的实现为打印 <code>XXX(类) load</code>，并且在 <code>Father</code> 的 <code>+load</code> 和 <code>main()</code> 函数分别打个断点，运行程序，程序会先在 <code>+load</code> 方法处中断，然后才在 <code>main()</code> 函数中断，并且 log 结果为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">father load</span><br><span class="line">son load</span><br><span class="line">grandson load</span><br><span class="line">extension load</span><br></pre></td></tr></table></figure><p>符合理论结果。</p><p>iOS 开发中的 <strong>Method Swizzling</strong>，为什么要在 <code>+load</code> 方法中做？</p><p>熟悉 runtime 的同学一定知道 runtime 会将函数实现成 C++ 中虚函数表的形式，在运行时调用，参考我的另一篇文章：<a href="https://zhangxiaom.github.io/2018/01/20/%E4%BB%8Eruntime%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7/" target="_blank" rel="noopener">从runtime源码解析消息发送的动态性</a>。从上文我们知道了 <code>+load</code> 方法的调用时机是类对象加载到进程地址空间的之后的第一时间，也就是可能是该类对象接收到的第一条消息，因此，此时做方法交换是修改类对象的方法列表的最好时机。其实 <strong>Method Swizzling</strong> 的实质有点类似于对符号引用的重定向，当然要在类对象加载的时候完成。</p><h3 id="四、优化程序启动时间"><a href="#四、优化程序启动时间" class="headerlink" title="四、优化程序启动时间"></a>四、优化程序启动时间</h3><p>从上面我们的分析，可以看到应用程序从启动到我们写的代码的执行之间经历了多少事，链接和加载也是影响程序启动的主要因素，其中 apple 对 dyld 的优化-共享缓存可以帮我们很大程度的提高应用的启动时间，但是我们自己也应该承担一部分责任：</p><ul><li><p>删除项目中不再使用的动态库（非系统库，dyld 不会创建共享缓存），因为链接和加载它们需要很多的时间和空间。</p></li><li><p>删除项目中不再使用的类和分类，因为加载它们到进程的地址空间是在启动时完成的。</p></li><li><p>尽量少的使用 <strong>Method Swizzling</strong>，因为方法交换需要遍历方法列表，会拖慢 <code>+load</code> 方法的执行，这也是在启动的时候完成的。</p></li><li><p>使用静态库代替非系统库的动态库，让重定向在编译的时候完成，能节省一部分链接的时间。</p></li></ul><p>等等。</p><p> 另外：删除不再使用的静态库，即使它不会拖慢启动时间，但是它仍然会被编译成目标文件而占用磁盘空间。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>emm，老规矩，知道这些并不会提高我们的业务能力，但是，你现在知道平时开发中遇到的 Apple Mach-O Linker Error 是什么原因了吗？知道影响程序启动时间的是谁了吗？知道 <code>Redefinition of &#39;XX&#39; as different kind of symbol</code> 的报错原因是什么了吧（符号表）？了解这些的目的是，当我们在某一时间遇到了一些关于 linker 的错误消息时，大概能知道从哪里查找问题，然后解决它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码从写完到编译到运行之间发生了什么？我们的程序是如何在设备上执行的？为什么我们代码中没有的库函数也能执行？在工作中我们可能常常会疑惑这样的问题，下面我们来探究一下这些问题。在阅读本文之前，需要充分了解进程的概念：&lt;a href=&quot;https://zhangxiaom.gi
      
    
    </summary>
    
    
      <category term="编译和链接" scheme="http://yoursite.com/tags/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>isa指针中隐藏的黑魔法</title>
    <link href="http://yoursite.com/2018/06/26/isa%E6%8C%87%E9%92%88%E4%B8%AD%E9%9A%90%E8%97%8F%E7%9A%84%E9%BB%91%E9%AD%94%E6%B3%95/"/>
    <id>http://yoursite.com/2018/06/26/isa指针中隐藏的黑魔法/</id>
    <published>2018-06-26T06:46:11.000Z</published>
    <updated>2019-09-01T03:37:02.776Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在 objc 的对象系统中，<code>isa</code> 指针是一个非常重要的角色，每个对象都有一个 <code>isa</code> 指针，它的含义用中文可以解释为<strong>是一个</strong>，例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> xiaoming = [Person new];</span><br></pre></td></tr></table></figure><p>可以解释为，xiaoming is a person（小明是一个人）。我们知道在 32 位架构下，指针变量的存储空间是 4 字节，在 64 位架构下，指针变量的存储空间是 8 字节，从 iPhone 5s 往后的 iPhone 设备都是搭载了 64 位的处理器和指令集，在保持原有的运行时和对象系统的设计不变的情况下，指针变量的字节扩充会造成一部分多余的内存开销。runtime 对 <code>isa</code> 指针的设计很巧妙的规避了这部分的内存消耗，让 <code>isa</code> 不再仅仅是一个指针。当然，深入了解这些的前提是你要足够了解指针变量的存储域以及<strong>位操作</strong>。</p><h4 id="一、Tagged-Pointer-（标记指针）"><a href="#一、Tagged-Pointer-（标记指针）" class="headerlink" title="一、Tagged Pointer （标记指针）"></a>一、Tagged Pointer （标记指针）</h4><p>在深入了解 <code>isa</code> 之前，我们需要了解一下运行时系统对64位的指针变量所做的一些优化。例如当我们初始化一个 <code>NSNumber</code> 对象时：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> foo = @(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>此时，<code>foo</code> 变量指向堆内存的 <code>NSNumber</code> 对象，在64位架构下，<code>foo</code> 变量的存储空间为 8 字节，并且 <code>NSNumber</code>  对象中还包含该对象的引用计数，<code>weak</code> 引用表，数值 <code>2</code> 等等，同时，runtime 还要处理它的生命周期，这样就会给程序增加许多额外的内存开销和逻辑处理的时间开销。而我们的目的仅仅是为了以对象的形式存储和访问数值 <code>2</code>，一个 4 字节的整型数值而已。</p><p>当我们使用一些基础数据类型（例如：<code>int</code>，<code>uint</code>，<code>c string</code> 等等）的封装对象（<code>NSNumber</code>， <code>NSString</code>）时，Tagged Pointer 会将指针的其中几个位作为标志位，标记该指针是否为 Tagged Pointer，什么类型等等，另外的部分用来存储内容。当使用 Tagged Pointer优化后，上文中  <code>foo</code> 变量中存储的不再是一个堆内存地址，而是值 <code>2</code> 和几个标志位。这样就可以省去对象的内存开销和对象的持有释放等时间开销。<code>int</code> 和 <code>uint</code>  类型的变量最高只需要 4 字节的存储空间，<code>c string</code> 一个字符占 1 个字节，8 字节长度的指针去掉标志位，可以存储 7 个字符。因此当存储的内容低于指针的地址长度减去标志位长度时，这些内容即被存储到指针变量中，当内容超过指针地址长度减去标志位长度时，内容就会被存储到普通对象中。如下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">id</span> foo = [<span class="built_in">NSString</span> stringWithCString:<span class="string">"aaaaa"</span> encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">        <span class="keyword">id</span> bar = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">id</span> baz = @(<span class="number">0x111111111111111</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"foo is %p"</span>, foo);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"bar is %p"</span>, bar);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"baz is %p"</span>, baz);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>log 结果：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo is <span class="number">0xa000061616161615</span> <span class="comment">// 字符 a 的 ASCII 码是97(0x61)</span></span><br><span class="line">bar is <span class="number">0xb000000000000023</span></span><br><span class="line">baz is <span class="number">0x600000034880</span></span><br></pre></td></tr></table></figure><p><code>foo</code> 和 <code>bar</code> 的最高四位和最低四位去掉之后正是实际存储的值。而 <code>baz</code> 的存储空间超过了 Tagged Pointer 所能分配的极限，因此被当做常规对象处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_OSX &amp;&amp; __x86_64__</span></span><br><span class="line">    <span class="comment">// 64-bit Mac - tag bit is LSB</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// Everything else - tag bit is MSB</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> OBJC_MSB_TAGGED_POINTERS 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> OBJC_MSB_TAGGED_POINTERS</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK (1ULL&lt;&lt;63)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> _OBJC_TAG_MASK 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>runtime 中描述了在 64 位 Mac 中区分指针变量是标记指针还是普通指针的标志位为最低位，在其他系统中，标志位为最高位（<code>1ULL&lt;&lt;63</code>）。runtime 会根据标志位区分一个指针是标记指针还是普通指针，从而对指针做出不同的处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内联函数，通过位操作判断指针是不是 tagged pointer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> </span><br><span class="line">_objc_isTaggedPointer(<span class="keyword">const</span> <span class="keyword">void</span> *ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">intptr_t</span>)ptr &amp; _OBJC_TAG_MASK) == _OBJC_TAG_MASK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的函数可看出，runtime 通过使用<a href="https://zh.wikipedia.org/wiki/%E6%8E%A9%E7%A0%81" target="_blank" rel="noopener">掩码</a>判断指针是不是标记指针，如果是标记指针，会用相应的函数取出它存储的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span></span><br><span class="line">_objc_getTaggedPointerValue(<span class="keyword">const</span> <span class="keyword">void</span> *ptr) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// assert(_objc_isTaggedPointer(ptr));</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> basicTag = ((<span class="keyword">uintptr_t</span>)ptr &gt;&gt; _OBJC_TAG_INDEX_SHIFT) &amp; _OBJC_TAG_INDEX_MASK;</span><br><span class="line">    <span class="comment">// 标志位在不同的情况下有区别</span></span><br><span class="line">    <span class="keyword">if</span> (basicTag == _OBJC_TAG_INDEX_MASK) &#123;</span><br><span class="line">        <span class="comment">// 先左移 n 位，然后右移 n 位，保留中间位</span></span><br><span class="line">        <span class="comment">// 无符号长整型，逻辑移位后补 0</span></span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">uintptr_t</span>)ptr &lt;&lt; _OBJC_TAG_EXT_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_EXT_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">uintptr_t</span>)ptr &lt;&lt; _OBJC_TAG_PAYLOAD_LSHIFT) &gt;&gt; _OBJC_TAG_PAYLOAD_RSHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过左移和右移去掉标志位，剩下的中间几位即为指针中存储的值。runtime 给出了几种可能会用 Tagged Pointer 优化的对象：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从命名中就可以看出是哪种类型的对象</span></span><br><span class="line">OBJC_TAG_NSAtom            = <span class="number">0</span>, </span><br><span class="line">OBJC_TAG_1                 = <span class="number">1</span>, </span><br><span class="line">OBJC_TAG_NSString          = <span class="number">2</span>, </span><br><span class="line">OBJC_TAG_NSNumber          = <span class="number">3</span>, </span><br><span class="line">OBJC_TAG_NSIndexPath       = <span class="number">4</span>, </span><br><span class="line">OBJC_TAG_NSManagedObjectID = <span class="number">5</span>, </span><br><span class="line">OBJC_TAG_NSDate            = <span class="number">6</span>, </span><br><span class="line">OBJC_TAG_RESERVED_7        = <span class="number">7</span>,</span><br></pre></td></tr></table></figure><p>runtime 会根据这些枚举值来判断一个 Tagged Pointer 是哪种类型的指针，以便于将取出来的值当做这种类型的对象来处理。</p><h4 id="二、isa"><a href="#二、isa" class="headerlink" title="二、isa"></a>二、isa</h4><p><code>isa</code> 指针也是指针，在 64 位架构下也需要 8 个字节的存储空间，而在原有的 32 位架构的设计中，<code>isa</code> 只需要 4 个字节的存储空间， 因此在保持原有的设计下，<code>isa</code> 指针同样会有 4 个字节的内存被浪费。就像 Tagged Pointer 一样，<code>isa</code> 也不再仅仅是一个指针，而是一个 <code>nonpointer</code>。</p><p><code>isa</code> 指针的一些位仍然被编码为指向类对象的指针，但是被编码为指针的位不是全部的 64 位地址空间，iOS 和 Mac OS 都是对 <code>isa</code> 指针做了相同的处理。和标记指针一样，<code>isa</code> 也使用掩码的形式最大程度使用指针的全部地址空间。runtime 会用 <code>isa</code> 的其他额外的位来存储对象的其他数据，例如引用计数，是否被弱引用等等。</p><p>这样就可以避免用额外的数据结构存储每个对象的引用计数和弱引用情况，也可以减少对象 <code>-retain</code>，<code>-release</code>，<code>-alloc</code>，<code>-dealloc</code> 时通过查表修改和获取引用计数的时间。</p><p>那么 <code>isa</code> 的 64 位地址空间都用来存储什么数据了呢？记住，看源码，而不是百度或者google。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="keyword">isa_t</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="keyword">isa_t</span>(<span class="keyword">uintptr_t</span> value) : bits(value) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> ISA_MAGIC_VALUE 0x000001a000000001ULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">// LSB</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// MACH_VM_MAX_ADDRESS 0x1000000000</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>;</span><br><span class="line">        <span class="comment">// MSB</span></span><br><span class="line">        <span class="comment">// bits + RC_ONE is equivalent to extra_rc + 1</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_ONE   (1ULL&lt;&lt;45)</span></span><br><span class="line">        <span class="comment">// RC_HALF is the high bit of extra_rc (i.e. half of its range)</span></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">define</span> RC_HALF  (1ULL&lt;&lt;18)</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>isa</code> 被定义为一个联合体，其中 <code>Class</code> 类型的变量 <code>cls</code> 指向类对象，还有一个无名位域指定了 64 位地址空间的存储内容。从最低有效位到最高有效位依次表示：</p><ul><li><p><code>nonpointer</code>：1 bit，置位（1）代表是 <code>nonpointer</code> ，复位（0）代表是原始的 <code>isa</code> 指针。</p></li><li><p><code>has_assoc</code>：1bit，对象是否被变量引用过。没有被引用的对象会很快被释放。</p></li><li><p><code>has_cxx_dtor</code>：1bit，对象有一个 c++ 或者 ARC 的析构函数，没有析构函数的对象会被很快释放。</p></li><li><p><code>shiftcls</code>：33 bits，这 33 位地址空间存储的就是真正的指向堆内存的地址。</p></li><li><p><code>magic</code>：6 bits，用来给调试器区分该对象是真正的对象还是未初始化过的垃圾内存。</p></li><li><p><code>weakly_referenced</code>：1 bit，对象是否被弱引用。</p></li><li><p><code>deallocating</code>：1 bit，对象正在被释放。</p></li><li><p><code>has_sidetable_rc</code>：1 bit，对象的引用计数太大，要用额外的数据结构存储。</p></li><li><p><code>extra_rc</code>：19 bits，如果对象的引用计数超过 1，就用这 19 位是用来存储额外的引用计数，最大可以表示的数字为 2^19 - 1。也就是当一个对象的引用计数低于 2 ^ 19 时就用这 19 位来存储，否则的话用额外的数据结构存储。例如对象的引用计数为 6，那么 extra_rc = 5。</p></li></ul><p>这就是全部的 64 位地址空间的存储内容。宏定义 <code>ISA_MASK</code> 作为指向类对象的指针的掩码。<code>0x0000000ffffffff8ULL</code> 正是第 3 到第 35 位的掩码值，<code>ISA_MAGIC_MASK</code> 是 6 位 <code>magic</code> 的掩码，当 <code>isa &amp;ISA_MAGIC_MASK == ISA_MAGIC_VALUE</code> 时，表明该对象是被初始化过的对象。（我猜 <code>0x000001a000000001ULL</code> 的意义和命名一样，magic value…）</p><p><code>RC_ONE</code> 表示 <code>extra_rc</code> 的最低位，因此 <code>bits + RC_ONE = extra_rc + 1</code>。<code>RC_HALF</code> 表示 <code>extra_rc</code> 范围的一半，此处为 2 ^ 19 / 2。</p><p>如何获取一个对象的引用计数呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">uintptr_t</span> objc_object::rootRetainCount()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> (<span class="keyword">uintptr_t</span>)<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    sidetable_lock();</span><br><span class="line">    <span class="keyword">isa_t</span> bits = LoadExclusive(&amp;isa.bits);</span><br><span class="line">    ClearExclusive(&amp;isa.bits);</span><br><span class="line">    <span class="keyword">if</span> (bits.nonpointer) &#123;</span><br><span class="line">        <span class="keyword">uintptr_t</span> rc = <span class="number">1</span> + bits.extra_rc;</span><br><span class="line">        <span class="keyword">if</span> (bits.has_sidetable_rc) &#123;</span><br><span class="line">            rc += sidetable_getExtraRC_nolock();</span><br><span class="line">        &#125;</span><br><span class="line">        sidetable_unlock();</span><br><span class="line">        <span class="keyword">return</span> rc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sidetable_unlock();</span><br><span class="line">    <span class="keyword">return</span> sidetable_retainCount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>objc_object 命名空间的内联函数，当 <code>isa</code> 指针是 Tagged Pointer 时，直接返回该指针的值，因为它不受 ARC 内存管理。当 <code>isa</code> 指针是 <code>nonpointer</code> 时，对象的引用计数为 1 + <code>extra_rc</code>，如果 <code>extra_rc</code> 的地址空间不足以存储对象的引用计数，则用 hash 表存储额外的引用计数，将三部分的结果求和即为对象的引用计数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span></span><br><span class="line">objc_object::sidetable_retainCount()</span><br><span class="line">&#123;</span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> refcnt_result = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != table.refcnts.end()) &#123;</span><br><span class="line">        <span class="comment">// this is valid for SIDE_TABLE_RC_PINNED too</span></span><br><span class="line">        <span class="comment">// 右移是因为设置的时候做了左移操作，我也不知道为什么要左移</span></span><br><span class="line">        refcnt_result += it-&gt;second &gt;&gt; SIDE_TABLE_RC_SHIFT;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    <span class="keyword">return</span> refcnt_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象的引用计数存储在一个以 <code>this</code> 指针为键，引用计数为值的 Map 中，该函数即为获取非 <code>nonpointer</code> 的对象的引用计数。因此，如果 <code>isa</code> 指针是 <code>nonpointer</code>，那么就节省了这个存储引用计数的 Map，同时也减少了管理对象生命周期时查表的时间。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>小小的 <code>isa</code> 指针就做了这么多不可思议的事情，可见 apple 对空间和时间的优化多么登峰造极，当然知道这些并不会提高我们的业务能力，但是我们有必要知道 runtime 动态库为整个 objc 的对象系统提供了多么大的支撑，这也是 objc 的核心能力。</p><h4 id="本文参考"><a href="#本文参考" class="headerlink" title="本文参考"></a>本文参考</h4><p><a href="http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html" target="_blank" rel="noopener">http://www.sealiesoftware.com/blog/archive/2013/09/24/objc_explain_Non-pointer_isa.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;在 objc 的对象系统中，&lt;code&gt;isa&lt;/code&gt; 指针是一个非常重要的角色，每个对象都有一个 &lt;code&gt;isa&lt;/code&gt; 
      
    
    </summary>
    
    
      <category term="内存管理" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>并发编程之进程</title>
    <link href="http://yoursite.com/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/06/12/并发编程之进程/</id>
    <published>2018-06-12T08:49:31.000Z</published>
    <updated>2019-09-01T03:37:02.778Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机的世界中，CPU 是唯一的，内存是唯一的，磁盘是唯一的，大部分资源都是共享的，但是正在运行的应用程序不是唯一的，因此，不同的应用程序可能在会在同一时刻使用 CPU、内存、磁盘等等，这样就会造成操作系统对硬件和软件的管理混乱。进程概念的引入很好的解决了这个问题，进程是对正在运行的应用程序的抽象，它使所有的应用程序都以为自己在独占的使用 CPU 和内存，由于这些抽象的存在，操作系统只需要关心如何正确的调度进程，而不用过多的关心每个进程的细节。</p><h4 id="一、进程模型"><a href="#一、进程模型" class="headerlink" title="一、进程模型"></a>一、进程模型</h4><p>每个进程都由完整的逻辑控制流和虚拟内存构成，逻辑控制流即为正在执行的指令集，虚拟内存同样也是一个抽象概念，他是物理内存和文件的抽象。我们可以拿面向对象的思想看待操作系统相对于进程，对对象来说，我们只需要关心它的部分信息和能力，而不在意它的实现细节。</p><p>进程有三种运行状态：阻塞、就绪、运行，三种状态的转换关系为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-bedc9a2c44438ac7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>进程与应用程序</strong>，应用程序是由代码和数据组成的，它可以作为目标模块被存储在磁盘上， 或者作为段被存储在内存中，而进程是运行中的程序的一个特殊实例，进程的上下文中存储着程序运行的状态、寄存器、堆栈等信息。</p><h4 id="二、多进程模型"><a href="#二、多进程模型" class="headerlink" title="二、多进程模型"></a>二、多进程模型</h4><p>对操作系统而言，多个进程并发的运行是其基本能力之一，但是单核 CPU 在同一时刻只能运行一个进程，因此操作系统会通过进程调度程序实现进程的调度，即调整多个进程运行的先后顺序，让它们能<em>并发的</em>运行。操作系统会维持一张进程表来保存当前被阻塞的进程的一些信息，目的是为了当此进程重新被调度到运行态时，可以继续接着被阻塞时的状态运行，该进程表包含了所有进程运行的程序计数器、堆栈指针、内存分配状况、打开的文件状态、调度信息等，而每个进程的这些信息被称为该进程的<strong>上下文</strong>。进程表的存在可以使操作系统完美的切换进程，操作系统通过不同的调度方式实现并发编程，如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-5608219e35413fa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>如图 a 和图 b，进程通过这个方式让自己看上去独占的使用程序计数器，如图 c，CPU 通过调度程序实现多进程的<em>并发</em>运行。</p><h4 id="三、进程调度"><a href="#三、进程调度" class="headerlink" title="三、进程调度"></a>三、进程调度</h4><p>上面说了，在计算机的世界，CPU 是稀缺资源，当多个进程同时处于就绪态时就会同时抢占 CPU，因此操作系统需要通过调度算法决定下一个使用 CPU 的进程。调度算法不是唯一的，不同的系统和不同应用场景就会产生不同的调度算法。常见的调度算法大致可归为三类：1）批处理（非抢占），2）交互式（抢占），3）实时。</p><h5 id="3-1-批处理（非抢占）"><a href="#3-1-批处理（非抢占）" class="headerlink" title="3.1 批处理（非抢占）"></a>3.1 批处理（非抢占）</h5><p>非抢占式，也就是进程运行的先后顺序由调度算法确定，在当前进程运行完之前，不允许其他进程抢占。</p><ul><li><p><strong>先来先服务</strong>，顾名思义，按照申请使用 CPU 的先后顺序决定进程使用 CPU 的顺序，调度程序会维护一个队列保存使用 CPU 的进程的顺序，从队头到队尾依次使用，并且直到一个进程运行完它期望的时间，才会运行下一个。当某个进程被阻塞时，它就会被排到队尾等待下一次运行。</p></li><li><p><strong>最短作业优先</strong>，运行时间最短的进程优先使用 CPU，例如运行时间分别为：4，1，3，2 分钟的4个进程 A、B、C、D 同时到达，4个进程的运行次序为运行时间最短的到运行时间最长的，即 B、D、C、A 依次运行。注意，只有几个进程同时到达时，这个算法才是最优的。</p></li></ul><h5 id="3-2-交互式（抢占）"><a href="#3-2-交互式（抢占）" class="headerlink" title="3.2 交互式（抢占）"></a>3.2 交互式（抢占）</h5><p>抢占式的概念意味着，当前正在运行的进程还没运行完其期望的运行时间就被其他进程抢占。</p><ul><li><strong>最短剩余时间优先</strong>，该算法是最短作业优先的抢占式版本，该算法总是优先选择剩余运行时间最短的那个进程运行，调度程序会先从到达的进程中选择最短运行时间的进程运行，在运行过程中新到达进程的运行时间如果短于正在运行的进程的剩余时间，那么正在运行的进程就会被挂起，新到达的进程会被运行。当当前运行进程运行完，调度程序会在剩下所有处于就绪状态的进程中选择最短剩余时间的进程运行。</li><li><strong>轮转式调度</strong>，轮转式调度是最古老的、最公平的、使用最多的调度算法，它会为每个进程分配一个运行的时间段，称为<strong>时间片</strong>。 调度程序会维护一张待运行的进程列表，当一个进程用完它的时间片之后，就会被移到队尾，等待下一次运行。如果某个进程在时间片结束之前阻塞或者运行完成，调度程序会立刻切换到下一个进程。</li><li><strong>优先级调度</strong>，轮转式调度默认所有的进程同等重要，而优先级调度则根据每个进程的重要程度分为不同的优先级，优先级高的进程先运行。同等优先级的进程遵循轮转式调度，即同一优先级的进程被放入同一队列中进行轮转调度，只有高优先级的队列为空时，才会运行低优先级队列中的进程。这种调度方法的劣势是低优先级的进程很可能会长期处于<em>饥饿</em>状态。</li></ul><h5 id="3-3-实时"><a href="#3-3-实时" class="headerlink" title="3.3 实时"></a>3.3 实时</h5><p>实时调度是一种受时间主导的调度系统，例如，在某一时间，外部的一种或者多种物理设备给了计算机一个刺激，而计算机必须要在一个确定的时间范围内做出适当的反应。这就要求调度程序马上抢占当前正在运行的进程，并且调度新的进程响应外部刺激，这些进程一般寿命较短，并且很短的时间内就可以运行完成。</p><h4 id="四、进程间的通信（IPC-Inter-Process-Communication）"><a href="#四、进程间的通信（IPC-Inter-Process-Communication）" class="headerlink" title="四、进程间的通信（IPC, Inter Process Communication）"></a>四、进程间的通信（IPC, Inter Process Communication）</h4><p>在多进程并发的环境下，一个进程需要把信息传送给另一个进程是比较常见的应用场景。例如，手机应用中将某个应用的某些信息传送给微信分享给其他人就是一种进程间通信的应用场景。进程间通信的几种情况主要有：1、一个进程将自己私有地址空间（虚拟内存）中的信息传送给另一个进程的虚拟内存；2、两个进程共享一部分内存，而且两个进程都有可能读取和改写共享内存中的某些信息。</p><p>所以，一般的 IPC 主要有以下几种：</p><ul><li><p><strong>管道</strong>，一个进程连接数据流到另一个进程的通道，把一个进程的输出通过管道传递给另一个进程。需要注意的是，通过管道传递信息的进程必须是父进程和子进程的关系，这也是该方法的一个缺陷。</p></li><li><p><strong>命名管道</strong>，也被称为<strong>FIFO文件</strong>，它是一种特殊类型的文件，但是它的作用和管道类似，一个进程可以通过打开它进行读写操作然后传递给另一个进程，两个进程之间可以不是父子关系。</p></li><li><p><strong>socket</strong>，就是我们经常提及的网络编程中的套接字，它通过字节流的形式实现两个进程间的通信，当然这两个进程可以是同一台计算机的两个进程，也可以是通过网络连接的不同计算机的两个进程。</p></li><li><p><strong>消息队列</strong>，一个存放数据块的队列，发送消息的进程将数据块依次添加进队列，接收消息的进程从队列中依次取出数据块。</p></li><li><p><strong>信号</strong>，操作系统会因为响应某些条件而产生事件，信号即为该事件，接收到该事件的进程会处理并完成该事件。例如在任务管理器中强制退出某个进程，操作系统就会给该进程发送一个 <code>kill</code>  信号，退出该进程。另外，某个正在运行的应用程序因为某些原因发生了 crash，这也是因为进程捕获了异常信号导致的进程退出。</p></li><li><p><strong>共享内存</strong>，顾名思义，两个或者几个进程可以共同访问的地址空间被称为共享内存，进程们可以通过修改共享内存中的内容同步信息到其他进程。当然这也会造成多进程同时修改和读取共享内存中的内容，从而导致信息错乱。</p></li><li><p><strong>信号量</strong>，准确的来说，信号量并不是进程通信的手段而是解决进程同步缺陷的手段。要理解信号量的概念必须要知道<strong>竞态条件</strong>和<strong>临界区</strong>的概念：</p><p><strong>竞态条件</strong>：当两个进程同时访问和改写共享内存时，例如共享内存中某个整型变量 <code>i</code> 初始化为 0，当进程 A 和进程 B 对变量 <code>i</code> 加一操作时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">变量i: <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span>  </span><br><span class="line">进程A: <span class="number">0</span>+<span class="number">1</span>     <span class="number">2</span>+<span class="number">1</span>     <span class="number">4</span>+<span class="number">1</span></span><br><span class="line">进程B:     <span class="number">1</span>+<span class="number">1</span>     <span class="number">3</span>+<span class="number">1</span></span><br><span class="line">时间 : <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure><p>进程 A 在 0 时刻读取 <code>i</code> 的值为 0，并且将它加一，此时进程 A 期望得到的结果为 1，但是同时 CPU 切换到进程 B 运行，进程 B 读取 <code>i</code> 的值为 1，然后将它加一，此时 <code>i = 2</code>，切换到进程 A 执行时，进程 A 读取到的值为 2，而不是它期望的结果 1，因此就会产生不可知的错误，像这样两个或者多个进程读写共享数据时，最后的结果取决于进程运行的精确时序，称为竞态条件。</p><p><strong>临界区</strong>，产生竞态条件的共享内存被称为临界区，即可以被多个进程同时读写的共享内存区域被称为临界区。</p><p>信号量就是针对临界区的一种保护手段，它被定义为 0 或者正数，只有保护临界区的信号量的值为正数时，某个进程才可以访问临界区，并且在访问结束时将信号量作减一操作；否则的话，进程即被挂起直到信号量为 0 才能访问临界区。</p></li></ul><h4 id="五、死锁"><a href="#五、死锁" class="headerlink" title="五、死锁"></a>五、死锁</h4><p>上文说到计算机的世界中许多资源都是独占的，例如 CPU，I/O，磁盘等，这些独占的资源就是造成死锁的原因之一。</p><h5 id="5-1-资源"><a href="#5-1-资源" class="headerlink" title="5.1 资源"></a>5.1 资源</h5><p>进程使用资源的状态主要包括：1）请求资源；2）使用资源；3）释放资源。</p><p>资源分为可抢占资源和不可抢占资源，对于可抢占资源来说，可以随时重新分配资源解决进程的调度问题，例如磁盘等。对于不可抢占资源来说，就意味着只有当前使用资源的进程释放了该资源才能分配给其他进程，例如打印机、CPU 等。</p><h5 id="5-2-死锁"><a href="#5-2-死锁" class="headerlink" title="5.2 死锁"></a>5.2 死锁</h5><p>如果一个进程集合中的所有进程都在等待该集合中其他进程运行完成才能运行，则该进程集合处于死锁状态。例如，进程 A 在等待进程 B 的完成，进程 B 在等待进程 C 的完成，进程 C 在等待进程 A 的完成。</p><p>产生死锁的条件：</p><p>1）互斥条件。每个资源都分配给了某个进程或者是可用的。</p><p>2）占有和申请条件。当前进程占有资源并且可以申请新的资源。</p><p>3）不可抢占条件。所有被进程占有的资源都是不可抢占资源。</p><p>4）循环等待条件。就是上文说的，几个进程形成环状的等待关系。</p><p>这四个条件即为产生死锁的必要条件，只有它们同时满足时才会产生死锁。</p><h5 id="5-3-死锁预防"><a href="#5-3-死锁预防" class="headerlink" title="5.3 死锁预防"></a>5.3 死锁预防</h5><p>我们已经知道了产生死锁的四个必要条件，而预防死锁打破其中一个条件即可：</p><p>1）破坏互斥条件。就是让资源可以被多个进程占有，例如打印机的打印机守护进程，它会获得进程的全部要打印的信息时才开始打印，这样就避免了多个进程同时打印。</p><p>2）破坏占有和申请条件。1、禁止已占有资源的进程再去申请其他资源；2、要求进程申请其他资源时先暂时释放其当前占有的所有资源。</p><p>3）破坏不可抢占条件。某些资源可以通过虚拟化的形式被其他进程抢占，例如上面提到的打印机。</p><p>4）破坏循环等待条件。1、禁止已占有资源的进程申请新的资源；2、将所有资源统一编号，进程申请资源的顺序必须是升序。这两种方法都可以破坏循环等待条件。</p><h5 id="5-3-死锁避免"><a href="#5-3-死锁避免" class="headerlink" title="5.3 死锁避免"></a>5.3 死锁避免</h5><p><a href="https://zh.wikipedia.org/wiki/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">银行家算法</a></p><h4 id="六、几个常见的-IPC-问题"><a href="#六、几个常见的-IPC-问题" class="headerlink" title="六、几个常见的 IPC 问题"></a>六、几个常见的 IPC 问题</h4><h5 id="6-1-哲学家就餐问题"><a href="#6-1-哲学家就餐问题" class="headerlink" title="6.1 哲学家就餐问题"></a>6.1 哲学家就餐问题</h5><p><a href="https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">哲学家就餐</a>问题是经典的进程同步问题，当一个进程集中的进程在争夺不可抢占资源时，这种抢占被描述为哲学家占有左手叉子的同时再申请右手的叉子，而且叉子是不可抢占的并且互斥的，如果每个哲学家都占有左手叉子的同时申请右手叉子，就会满足死锁的四个必要条件，从而造成死锁。</p><h5 id="6-2-读者写者问题"><a href="#6-2-读者写者问题" class="headerlink" title="6.2 读者写者问题"></a>6.2 读者写者问题</h5><p>我们平常工作中接触较多的多线程并发编程，很少会设计到多进程编程，但是读者写者问题同样适用于多线程编程，因为对同一个进程的多个线程来说，它们共享该进程的所有地址空间。读者写者问题就是典型的多线程同步问题，假如多个线程同时在读写同一块共享内存，当其中一个线程改写某些数据的时候，而另一个线程正在读取这部分数据，就会造成我们常说的线程安全问题，因为它读取的是错误的数据。读者写者问题的解决方式就是当一个线程（或者进程）在改写临界区数据的时候，其他线程不能访问临界区，如果没有线程在改写临界区，多个线程可以同时读取临界区的数据。</p><p><strong>锁</strong>的概念可以帮助我们解决上述问题。我们会在多线程编程的文章中重点讨论<strong>锁</strong>。</p><h4 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h4><p>充分理解进程、多进程编程、共享内存、临界区等概念可以帮助我们更好的解决并发带来的问题，同时也能帮助我们站在大局观看待整个应用程序的运行和运行过程中产生的问题。更能帮助我们准确分析和定位并发带来的一系列难题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在计算机的世界中，CPU 是唯一的，内存是唯一的，磁盘是唯一的，大部分资源都是共享的，但是正在运行的应用程序不是唯一的，因此，不同的应用程序可能在会在同一时刻使用 CPU、内存、磁盘等等，这样就会造成操作系统对硬件和软件的管理混乱。进程概念的引入很好的解决了这个问题，进程是
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出谈算法</title>
    <link href="http://yoursite.com/2018/06/11/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%B0%88%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/06/11/深入浅出谈算法/</id>
    <published>2018-06-11T06:44:43.000Z</published>
    <updated>2019-09-01T03:37:02.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h3><p>算法无用论和算法重要论一直以来都是程序员界争论不休的话题，至今也没人能给出一个明确的定论。个人认为，解算法或者说刷题的目的不在于我们在工作中使用这个算法，而在于解题的过程能锻炼我们解决问题的思维和扩展思维。这种思维可以给我带来的是：一个复杂的流程可以想到多种解决方法，并且从中选择最优的解法，而不是只有一种解法还是十分垃圾的解法。另外，一个简单的数据结构的使用可能会大大的简化我们代码的时间复杂度（时间复杂度和空间复杂度的概念请自行了解）。下面来看例子吧（以下问题中，所有整数都在32位整型范围内）：</p><h3 id="一、缺少了谁？"><a href="#一、缺少了谁？" class="headerlink" title="一、缺少了谁？"></a>一、缺少了谁？</h3><p>问题一：有n个数 <code>nums</code>，<code>1 &lt;= nums[i] &lt;= n</code>，无序无重复，被拿掉了一个，请找到被拿掉的那个数，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>]; n = <span class="number">6</span>;</span><br><span class="line">result: <span class="number">5.</span></span><br><span class="line"><span class="comment">// 6个数：1-6，被拿掉的那个是5，所以结果就是5。</span></span><br></pre></td></tr></table></figure><p>解法：用等差数列求和公式得到 n 个数的和，然后把数组中的数字挨个减一遍。直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findAbsence</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: nums) &#123;</span><br><span class="line">        sum -= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去也没有什么难度嘛！而且此解法的时间复杂度为 O(N)，空间复杂度为 O(1)，简直完美。</p><p>上面的解法已经是这道题的最优解法，但是它不具备通用性，假如我们遇到的问题不是抽掉一个数字而是两个呢？那么上面的解法就不具备解决这个的问题的能力。</p><p>问题二：在问题一的基础上，扩展为拿掉两个数字或者更多数字，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">1</span>]; n = <span class="number">6</span>;</span><br><span class="line">result: [<span class="number">3</span>,<span class="number">5</span>].</span><br><span class="line"><span class="comment">// 6个数：1-6，被拿掉的那个是5，所以结果就是5。</span></span><br></pre></td></tr></table></figure><p>很显然，问题一的解法显然已经不适用于现在的问题了，有的人可能会想到先排序，然后比较数组的下标和对应的值，当第一次出现不对应的时候就是缺少的值，同样的方法再找到第二个，但是排序的时间复杂度是 O(N*lgN)，该题目可能还会有更好的解法。</p><p>散列法（<a href="https://zhangxiaom.github.io/2018/03/23/%E5%93%88%E5%B8%8C%E8%A1%A8/" target="_blank" rel="noopener">什么是散列表</a>），将数组中的值全部散列到 <code>Map</code> 中，然后将 1 - n 作为键去 <code>Map</code> 中查找，查不到的即为缺少的。代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">findAbsenceWithMap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: nums) &#123;</span><br><span class="line">        map.put(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.get(i) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用了 O(N) 的空间复杂度换取了 O(lgN) 的时间复杂度，同时这种解法好像更容易理解一些。</p><p>这种解法 O(N) 的时间复杂度当然是建立在哈希表没有哈希冲突的情况下，假设在极端情况下哈希表完全冲突，那么该问题的时间复杂度变成了 O(N^2)，好像还不如我们第一次想到的排序算法，当然哈希完全冲突的情况基本上不会出现，作这个假设的目的是为了引出更好的解法：</p><p>申请一个新的数组，数组的长度为 n，将 <code>nums</code> 中的值作为下标，将 <code>nums</code> 中的内容散列到新的数组，标记为 1，最后遍历一遍新数组，未被散列的下标即为我们要查找的目标：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">findAbsenceWithArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：数组的下标从 0 开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: nums) &#123;</span><br><span class="line">        temp[i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就解决了哈希表哈希冲突的问题，同时基础类型的数组要比 <code>Map</code> 这种封装类型对内存的消耗少得多。</p><h3 id="二、多了谁？"><a href="#二、多了谁？" class="headerlink" title="二、多了谁？"></a>二、多了谁？</h3><p>现在问题又变得复杂了：</p><p>问题三：依然是 n 个数，每个数的大小都大于等于1，小于等于 n，但是有的数被拿掉了，有的数出现了两次，请找到出现两次的数。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">2</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>]; n = <span class="number">6</span>;</span><br><span class="line">result: [<span class="number">2</span>,<span class="number">6</span>].</span><br><span class="line"><span class="comment">// 2和6分别出现了两次，缺少了3和5。</span></span><br></pre></td></tr></table></figure><p>经过对问题一和问题二的思考，我们马上就想到了，将所有数以数为键，以出现的次数为值散列一遍，最后找到哈希表中值为 2 的数，emm，是个好解法，但是不幸的是，此时待处理的数组过大，已经没有多余的内存给你申请一个相同内存的数组或者哈希表，也就是说我们必须要在 O(1) 的空间复杂度解决这个问题。同时，由于待处理数组太大，我们设计的算法的时间复杂度不宜过高。</p><p>现在看上去这个问题是有点变态了，但是又确确实实是我们在工作中可能会遇到的问题，因为 4G 内存装满整形数字也就 10亿数量级的数字，好像并不是特别大。</p><p>好在，题目并没有不允许我们修改原始数组，题干中的 1 - n，好像也是解题的关键所在。因此，我们就想到了原地散列的解法，也就是以数组中的值为下标再散列该数组，将该下标下的值乘以 -1，当遍历到某个下标的值小于 0时，则该下标出现两次。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原数组</span></span><br><span class="line">key: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">val: <span class="number">2</span> <span class="number">6</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="comment">// 将第一个 val，数组中的第二个数乘以-1</span></span><br><span class="line">key: <span class="number">0</span>  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">val: <span class="number">2</span> <span class="number">-6</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">1</span>   </span><br><span class="line"><span class="comment">// 将第二个 val，数组中的第六个数乘以-1</span></span><br><span class="line">key: <span class="number">0</span>  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>  <span class="number">5</span></span><br><span class="line">val: <span class="number">2</span> <span class="number">-6</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span> <span class="number">-1</span> </span><br><span class="line"><span class="comment">/* 遍历到第三个val，6时，发现数组中第6个数为负数，说明6是第二次出现，</span></span><br><span class="line"><span class="comment"> * 因此，6为出现两次的数，保存6。</span></span><br><span class="line"><span class="comment"> * 然后将第6个数乘以-1，避免重复，以此类推。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">key: <span class="number">0</span>  <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>  <span class="number">5</span></span><br><span class="line">val: <span class="number">2</span> <span class="number">-6</span> <span class="number">6</span> <span class="number">4</span> <span class="number">2</span>  <span class="number">1</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[index] &lt; <span class="number">0</span>) list.add(Math.abs(index + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        nums[index] = -nums[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就用 O(N) 的时间复杂度和 O(1) 的空间复杂度解决了这个问题。</p><p>经过上面几道题目的锻炼，感觉自己好像掌握了解决这种问题的套路了，自信满满。放马过来吧！🤓🤓</p><p>问题四：这次不再是 n 个数了，而是 n + 1 个数，仍然是大于等于1，小于等于 n，但是这堆数里面出现了一个异类，它出现了两次，并且只有它出现了两次，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]; n = <span class="number">5</span>;</span><br><span class="line">result: <span class="number">1.</span></span><br></pre></td></tr></table></figure><p>条件继承自问题三，没有多余的空间给我们用，时间复杂度不宜过高，但是不同的是，此时你不能再修改数组了。</p><p>假如没有这些条件的话，上面几个问题的解法看起来好像都能解决这个问题，我们的铺垫是有用的，但是假如加了这些限制条件，你还能想到解法吗？要知道永远不会变的是变化，你怎么保证自己的职业生涯中不会遇到这类问题和限制条件呢？</p><p>那么现在就开始解决它吧！</p><p>数组中的值分布在 1 ~ n 之间，除了散列，还能想到什么数据结构能满足这个条件呢？答案是链表。用数组实现的链表，听起来好像有点陌生，那就去翻翻那本叫数据结构与算法的大学课本吧！</p><p>通常数组都是以下标 0 开始的，那么我们先将 1 ~ n 转化为 0 ~ n：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原数组</span></span><br><span class="line">key: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">val: <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="comment">// 转化后</span></span><br><span class="line">key: <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line">val: <span class="number">1</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>现在看上去好多了，数组中存的值可以和下标对应了，我们将转化后的数组写成链表：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-35f2e93ad4eb0dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>是不是看上去大吃一惊，还能这样玩？别着急，好戏还在后面呢。</p><p>现在的目的有点明确了，我们要找的就是这个有环的链表的环开始的地方，就是那个结点 0，当然它在原数组中的大小是 1，将链表中的每个结点转化为原数组中的值只需要将他们的大小加 1 而已，就像我们将数组转换为链表的时候减 1 一样。</p><p>如何找到这个环开始的结点？即，如何找到链表的环开始的结点？</p><p>emm，挨个将每个结点放入 <code>Set</code>，当第一次遇到存放失败，即 <code>Set</code> 中存在该结点的时候，这个结点就是要找的结点。是个好主意，但是，是不是忽略了最初的限制条件？即使现在变成链表的结构了，我们也没有多余的内存去申请一个 <code>Set</code>。</p><p>事情好像又陷入了一个死结。</p><p>那么两个指针呢？一个一次走一步，一个一次走两步，当走的快的指针追上走的慢的指针的时候，是不是就说明链表有环？</p><p>首先我们假设链表有环，并且两个指针能相遇，并且在慢指针走了 k 步后相遇，此时快指针走了 2k 步，那么快指针比慢指针走的多的步数就是环的长度乘以循环的次数。假设环的长度为 r，快指针循环 n 次相遇，那么我们可以得到结果：2k - k = nr，因此当 n 满足 k = nr 时，两个指针相遇，证明了我们的假设。看来这个办法是行得通的，但是，我们没有办法保证此时相遇的结点即为环开始的结点，只能证明它们会在某处相遇而已，即只能证明链表有环。</p><p>那么环开始的结点在哪呢？</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-46acf9b80dc1d072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在上面的基础上继续推导，如上图，设链表的头结点为第 0 步，环的方向为逆时针方向，环开始的结点到头结点的距离为 m 步，快慢指针相遇的结点到头结点的距离为 k 步，m 到 k 的距离为 s 步，所以，我们可得到：s = k - m，即，s = nr - m，即 s = (n - 1)r + r - m，当 n = 1时，s = r - m，即 m = r - s。也就是逆时针方向 k 到 m 的距离等于头结点到环开始的结点的距离，因此，我们让快指针重新回到头结点，慢指针仍然在相遇结点，两个指针都一次走一步，它们相遇的结点即为我们要找的结点。</p><p><strong>Talk is cheap, show you the code</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 不用刻意的去寻找头结点</span></span><br><span class="line"><span class="comment">     * 即使上述推论中 m = 0，也能得到相同的结果。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> slow = nums.length, fast = nums.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为都是从头结点开始的，所以忽略第一步判断</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        slow = nums[slow - <span class="number">1</span>];</span><br><span class="line">        fast = nums[nums[fast - <span class="number">1</span>] - <span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast);</span><br><span class="line"></span><br><span class="line">    slow = nums.length;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = nums[slow - <span class="number">1</span>];</span><br><span class="line">        fast = nums[fast - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想不到吧，一个复杂的问题居然可以用这么少的代码就解决了，所以，算法的优势显而易见，如果此时你还坚持算法无用论的话，那么下面这个问题呢？</p><h3 id="三、谁是单身狗？"><a href="#三、谁是单身狗？" class="headerlink" title="三、谁是单身狗？"></a>三、谁是单身狗？</h3><p>问题五：现在情况又有些不同了，你遇到的问题不再是 1 ~ n 之间的数字了，变成了任意整数，但是这些数中只有一个小伙伴只出现了一次，其他小伙伴都出现了两次，同样你没有多余的内存可用，也就是别想 <code>Map</code> <code>Set</code> 等数据结构会来帮你，如果认为排序是个好办法的话，不好意思，我们最好将算法的时间复杂度控制在线性时间复杂度之内，因为这个数据量可能会超出你所能想象的大小，并且除了某些特殊情况下，修改原数组不是一个很好的解题习惯。</p><p>考验基础牢固不牢固的时候到了，当我们把一个数字转换成二进制的时候，就可以对它进行位操作，比如按位或、按位与、按位异或、左移、右移等等。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span>: <span class="number">1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line">&amp;  <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="comment">// 与</span></span><br><span class="line">|  <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="comment">// 或</span></span><br><span class="line">^  <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="comment">// 异或</span></span><br></pre></td></tr></table></figure><p>那么当两个数相等时，他们的位操作的结果呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span>: <span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line">&amp;  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="comment">// 与</span></span><br><span class="line">|  <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="comment">// 或</span></span><br><span class="line">^  <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="comment">// 异或</span></span><br></pre></td></tr></table></figure><p>问题好像有点眉目了，两个相等的数异或的结果就是 0，我们想一下就能知道，0 与任何数异或的结果都是任何数，因此，<code>3 ^ 3 ^ 5 = 5</code>。有了这个结果，那么写代码吧（假定数组非空）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findSingle</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i: nums) &#123;</span><br><span class="line">        res ^= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请问你现在还抱着算法无用论的心理吗？？</p><h3 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h3><p>多余的话就不用再说了，算法的存在不在于解题，而在于锻炼这种解题的思维。</p><p>另外，如果你也对算法有兴趣的话，来体验解题的快感吧： <a href="https://leetcode.com/problemset/all/" target="_blank" rel="noopener">LeetCode</a>，<a href="https://github.com/ZhangXiaoM/LeetCode" target="_blank" rel="noopener">这里</a> 有我解的一部分问题的 Java 实现，有些可能不是最优解，按题目类型分类，用题目的 title 搜索也能找到哦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h3&gt;&lt;p&gt;算法无用论和算法重要论一直以来都是程序员界争论不休的话题，至今也没人能给出一个明确的定论。个人认为，解算法或
      
    
    </summary>
    
    
      <category term="数据结构和算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>从源码分析block的底层实现</title>
    <link href="http://yoursite.com/2018/05/31/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90block%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2018/05/31/从源码分析block的底层实现/</id>
    <published>2018-05-31T07:19:11.000Z</published>
    <updated>2019-09-01T03:37:02.777Z</updated>
    
    <content type="html"><![CDATA[<p>作为 iOS 开发者，不管是初级还是高级，都应该知道并且熟练应用 OC 中的 block 语法。大多数开发者都知道 block 会造成循环引用，但是很少有人会关心 block 造成循环引用的原理和如何正确的避免，大多数人遇到 block 就用 weak 引用这种简单粗暴的方式来解决循环引用的问题，这种做法并不可取。下面我将从 block 是什么？ block 如何捕获变量？ block 循环引用的原理等几个方面，分析 block 的实质。</p><h3 id="一、Block-是什么？"><a href="#一、Block-是什么？" class="headerlink" title="一、Block 是什么？"></a>一、Block 是什么？</h3><p>runtime 是大家耳熟能详的东西，从 runtime 中可以知道，OC 中所有的类都是用 C 或 C++ 结构体实现的，所有的方法都是通过动态绑定的方式在运行时调用的，具体内容可参见：<a href="https://zhangxiaom.github.io/2018/01/20/%E4%BB%8Eruntime%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E5%AF%B9%E8%B1%A1%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7/" target="_blank" rel="noopener">从runtime源码解析对象发送消息的动态性</a>。其实 block 的实现方式和 OC 类的实现方式是相同的，只不过 block 的实现不会像 OC 对象一样依赖于运行时动态库，它会在编译时被分配到栈内存或者分配到全局和静态数据区，但是运行时仍然会在某些情况下将分配到栈上的 block 拷贝到堆内存，以便于解决 block 被栈内存销毁的问题。以下内容将用 <em>Block</em> 关键字描述 block ”类“（即实现 block 的结构体），用 <em>block</em> 关键字描述 block ”对象“。</p><p>当我们在 main 方法中创建一个 block，并且赋值给某个变量时，通过 <code>clang</code> 将 OC 代码编译成 C 代码，可以找到 Block ”类“中的内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一眼就看到了熟悉的 <code>isa</code> 指针，这是 OC 对象中独有的东西，而且从这个结构体也可以看出，block 并不是一个简简单单的函数指针，而是被包装为 OC 类的 Block 的实例。只不过此时实例化的 block 被分配到栈内存。Block 中包含了一个 <code>isa</code> 指针，指向保存它所有信息的<em>类对象</em>，一个标志位 <code>Flags</code>，一个保留字段 <code>Reserved</code>，当然标志位和保留字段是 OC 源码中的一贯作风，它们没有特别明确的使用场景。<code>FuncPtr</code>  即是 Block 作为匿名函数的真相，它指向的函数即为调用 <code>block()</code> 时实际调用的函数。这是 Block 的通用实现，即所有 block 对象都会有的东西，但是当 block 捕获外部变量，或者被拷贝到堆内存的时候，它还需要一些其他实例和方法完成拷贝和保留被捕获的外部变量。</p><p>所以 Block 被实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，此时 Block 是由 <code>struct __block_impl impl</code> 和 <code>struct __main_block_desc_0* Desc</code> 两个成员变量和一个初始化方法组成的，当 block 捕获不同类型的外部变量时，<code>struct __main_block_impl_0</code>  中会多一个成员用来存储捕获的变量。那么为什么要这样写？而不是将 <code>__block_impl</code> 在 <code>__main_block_impl_0</code>  中展开？我们知道 block 会捕获不同类型的外部变量，有的是引用类型，有的是基础类型，有的是只读的，有的是可变的，所以，假如我们使用了 n 个捕获不同类型的 block，那么就会生成 n 个不同的 <code>__main_block_impl_n</code>，<code>__block_impl</code>的使用可以减少代码的重复性和耦合性。</p><p>再来看 <code>Desc</code> ，这是一个指向 <code>__main_block_desc_0</code> 结构体的指针。它的内容为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0)&#125;;</span><br></pre></td></tr></table></figure><p>emm，一个保留字段，一个保存 block 大小的变量<code>Block_size</code> ，之前说过 block 会在某些情况下被拷贝到堆内存，假如 block 满足一些被拷贝到堆内存的条件时，它捕获的内容也将被拷贝到堆内存， <code>__main_block_desc_0</code> 就会增加 <code>copy</code> 和 <code>dipose</code> 方法，前者用来将 block  捕获的内容拷贝到堆内存，后者用来释放捕获的内容。并且这段代码实例化了一个  <code>struct __main_block_desc_0</code> 类型的静态全局变量 <code>__main_block_desc_0_DATA</code> 。当然每一个 <code>__main_block_impl_n</code>  都会有一个<code>__main_block_desc_n_DATA</code> 用来保存 block 的 size 和实现 <code>copy</code> 方法。</p><p>当我们创建一个 block 时，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^Block)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        Block blk = ^&#123;&#125;;</span><br><span class="line">        blk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它即被 <code>clang</code> 翻译为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        Block blk = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先用指向 <code>__main_block_func_0</code> 函数的函数指针和  <code>__main_block_desc_0_DATA</code>  全局变量初始化 <code>__main_block_impl_0</code>，此即为 block ”对象“。当调用 <code>blk()</code> 时，block 会通过他的成员变量 <code>FuncPtr</code> 实现，参数即为它自身和我们调用 block 时传入的实参。</p><h3 id="二、block-存储位置"><a href="#二、block-存储位置" class="headerlink" title="二、block 存储位置"></a>二、block 存储位置</h3><p>block 在内存中有三个存储域，它的 <code>isa</code> 指针会描述它的存储域，上文中可看到 block 的存储在栈内存中，当我们声明一个全局 block 并且实现它的时候，block 就会被存储在静态和全局区。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^Block)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impl0.isa = &amp;_NSConcreteGlobalBlock;</span><br></pre></td></tr></table></figure><p>当 block 满足一定的条件时，分配在栈上的 block 会在运行时被拷贝到堆内存，并且 ARC 会帮我们管理内存。下面几种情况 block 会被拷贝到堆内存：</p><ul><li>捕获对象时；</li><li>作为函数返回值时；</li><li>捕获 <code>__block</code> 修饰的变量时；</li><li>被赋值给 <code>__strong</code> 修饰的成员变量时；</li><li>主动调用 <code>- copy</code> 方法时。</li></ul><p>等等。</p><h3 id="三、block-捕获外部变量"><a href="#三、block-捕获外部变量" class="headerlink" title="三、block 捕获外部变量"></a>三、block 捕获外部变量</h3><p>理解 block 捕获变量的前提是，我们应该掌握虚拟内存和内存分区的概念，即堆、栈、程序代码和数据区、共享库的代码和数据区、内核虚拟存储区，以及每个分区的工作方式。并且了解全局变量，静态全局变量，静态变量，自动变量等的概念以及它们的存储域和销毁时机。并且了解 OC 的内存管理方式，ARC 和 MRC。还有值类型变量和引用类型变量的存储方式的区别和联系。</p><h4 id="1、捕获自动变量"><a href="#1、捕获自动变量" class="headerlink" title="1、捕获自动变量"></a>1、捕获自动变量</h4><p>如下代码，block 捕获外部变量 <code>x</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">Block blk0 = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, x);</span><br><span class="line">&#125;;</span><br><span class="line">blk0();</span><br></pre></td></tr></table></figure><p>此时，生成的 Block 实现结构体为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> _x, <span class="keyword">int</span> flags=<span class="number">0</span>) : x(_x) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，Block 中多了一个成员变量 <code>x</code>，并且初始化方法中多了一个参数 <code>_x</code>，并且赋值给成员变量 <code>x</code>。因此，当 block 捕获自动变量的时候，会生成一个相同类型的成员变量，用来存储该自动变量的 copy。为什么是 copy，而不是该变量？因为当 block 被赋值为实例变量时，该 block 的调用时机可能出了该自动变量的作用域，那么，该自动变量就会因为被弹出栈而销毁，因此需要 copy 一份，而不是直接访问。并且此时我们仅仅能访问 <code>x</code>，如果尝试改写它，编译器会给你发个 error，因为 <code>x</code>  仅仅是 block 的成员变量和自动变量的 copy，而不是自动变量本身，所以我们没有权利修改它，即使修改了，也是修改的 block 成员变量，而不会同步到外部变量，因为它是值类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = __cself-&gt;x; <span class="comment">// bound by copy</span></span><br><span class="line">    NSLog((NSString*)&amp;__NSConstantStringImpl__var_folders_qd_7zbm76j916n2_dhjbm6nsm480000gn_T_main_19f6cf_mi_0, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，block 中的 <code>FuncPtr</code> 指针指向的函数会通过指向它自身的指针 <code>cself</code> 访问它的成员变量 <code>x</code>。</p><h4 id="2、捕获对象"><a href="#2、捕获对象" class="headerlink" title="2、捕获对象"></a>2、捕获对象</h4><p>关于 block 的循环引用是我们在工作中老生常谈的话题，有一句话大家都不会陌生：因为某个对象强引用了 block，block 又强引用了某个对象，所以会造成循环引用，那么 block 是如何强引用对象的呢？这就要从 block 捕获对象说起了。</p><p>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *foo = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">Block blk0 = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">    [foo addObject:<span class="string">@""</span>];</span><br><span class="line">&#125;;</span><br><span class="line">blk0();</span><br></pre></td></tr></table></figure><p>此时的 Block 结构体为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  NSMutableArray *foo;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, NSMutableArray *_foo, <span class="keyword">int</span> flags=<span class="number">0</span>) : foo(_foo) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Block 结构体中也多了一个变量 <code>foo</code>，就像上文 <strong>1</strong> 一样，Block 中也会多一个变量用来保存它捕获的内容。但是不同的是，对象是引用类型，所以 Block 的中的变量是对指向可变数组的变量的 copy，而不是对对象的 copy，它是 <code>foo</code> 的别名，和 <code>foo</code> 指向同一块堆内存。用 C 语言的语法可表述为：Block 中的成员变量 <code>foo</code> 是对指针 <code>foo</code> 的拷贝，而不是对对象 <code>*foo</code> 的拷贝。</p><p>此时， <code>__main_block_desc_0</code> 结构体为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;</span><br><span class="line">  <span class="keyword">void</span> (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(struct __main_block_impl_0*);</span><br><span class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</span><br></pre></td></tr></table></figure><p>可以看到多了两个成员 <code>copy</code> 和 <code>dispose</code>，说明当 block 捕获对象时，block 会被拷贝到堆内存。</p><p>这两个函数指针的定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;foo, (<span class="keyword">void</span>*)src-&gt;foo, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;foo, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可看出，它们的作用是拷贝 block 捕获的变量和废弃 block 捕获的变量。</p><p>下面的代码可以验证 block 此时被拷贝到堆内存。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *foo = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(foo)));</span><br><span class="line"><span class="keyword">void</span> (^blk0)(<span class="keyword">void</span>) = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(foo)));</span><br><span class="line">&#125;;</span><br><span class="line">blk0();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,blk0);</span><br></pre></td></tr></table></figure><p>log 结果为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-06</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">44.581703</span>+<span class="number">0800</span> XXX[<span class="number">12276</span>:<span class="number">1661853</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-06</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">44.582176</span>+<span class="number">0800</span> XXX[<span class="number">12276</span>:<span class="number">1661853</span>] <span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-06</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">44</span>:<span class="number">44.582949</span>+<span class="number">0800</span> XXX[<span class="number">12276</span>:<span class="number">1661853</span>] &lt;__NSMallocBlock__: <span class="number">0x100745a50</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看出，在被 block 捕获之前对象 <code>foo</code>  的引用计数为 1，被捕获之后，引用计数增加到 3，并且 log 结果可看到 block 被拷贝到堆内存（<em>NSMallocBlock</em>）中，此时我们可以猜测，对象 <code>foo</code> 分别被栈上的 block 强引用一次、堆上的 block 强引用一次，变量 <code>foo</code> 强引用一次，因此，在被 block 捕获之后，它的引用计数为 3。此时内存布局为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-0862ec404f661233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>下面证明我们的猜测，如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *foo = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line"><span class="keyword">void</span> (^blk0)(<span class="keyword">void</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(foo)));</span><br><span class="line">&#123;</span><br><span class="line">    blk0 = ^(<span class="keyword">void</span>)&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(foo)));</span><br><span class="line">    &#125;;</span><br><span class="line">    blk0();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(foo)));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,blk0);</span><br></pre></td></tr></table></figure><p>log 的结果为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-06</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">09.573400</span>+<span class="number">0800</span> XXX[<span class="number">13849</span>:<span class="number">1684686</span>] <span class="number">1</span></span><br><span class="line"><span class="number">2018</span><span class="number">-06</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">09.576588</span>+<span class="number">0800</span> XXX[<span class="number">13849</span>:<span class="number">1684686</span>] <span class="number">3</span></span><br><span class="line"><span class="number">2018</span><span class="number">-06</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">58</span>:<span class="number">09.576820</span>+<span class="number">0800</span> XXX[<span class="number">13849</span>:<span class="number">1684686</span>] <span class="number">2</span></span><br><span class="line"><span class="number">2018</span><span class="number">-06</span><span class="number">-04</span> <span class="number">16</span>:<span class="number">59</span>:<span class="number">57.620217</span>+<span class="number">0800</span> XXX[<span class="number">14913</span>:<span class="number">1696697</span>] &lt;__NSMallocBlock__: <span class="number">0x100616990</span>&gt;</span><br></pre></td></tr></table></figure><p>从结果来看，此时的 block 依然在堆上， <code>foo</code> 变量仍然强引用对象，但是当出了中间的大括号作用域，<code>foo</code> 对象的引用计数变为 2，这说明，分配在栈上的 block 在出了作用域之后被弹出栈，同时栈内存中拷贝的 <code>foo</code> 变量也被废弃（dispose），所以此时栈上的 block 不再强引用对象 <code>foo</code>，所以它的引用计数变为 2。这就是 block 捕获对象的真相。我们可以得出的结论是，被捕获的对象会随着 block 的拷贝而被拷贝到堆内存，随着 block 的销毁而销毁，因此即使 block 不像 OC 对象一样遵循 ARC 的内存管理方式，OC 也会帮我们管理它和它捕获的对象的内存。</p><h4 id="3、捕获全局和静态变量"><a href="#3、捕获全局和静态变量" class="headerlink" title="3、捕获全局和静态变量"></a>3、捕获全局和静态变量</h4><p>注意：全局变量并不是类中的全局变量，类中的全局变量只是属于该类的成员变量，它会在运行时被保存到该对象成员变量列表中，对象是存储在堆内存中的，因此类中的全局变量也是存储在堆内存中的。此处说的全局变量是分配在<em>全局和静态变量区</em>的全局变量，又分为已初始化的全局和静态数据区和未初始化的全局和静态数据区，此处不再多余赘述。</p><p>如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _foo = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^()&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, _foo);</span><br><span class="line">        &#125;;</span><br><span class="line">        blk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，block 不会对全局变量和静态全局变量作任何多余的拷贝，而是在函数中直接访问全局和静态全局变量。因为，静态和全局数据区存储的内容在整个进程的生命周期内都有效，block 不用担心作用域和野指针等等内存问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_qd_7zbm76j916n2_dhjbm6nsm480000gn_T_main_d97d1e_mi_0, _foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block 的实现函数也是直接访问了全局变量 <code>_foo</code> 。</p><p>当捕获静态自动变量时：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> foo = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^()&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, foo);</span><br><span class="line">        &#125;;</span><br><span class="line">        blk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态自动变量和全局变量不同的是：它有作用域的概念，当出了当前作用域的时候，它就不能再被访问，但是它仍然被存储在静态和全局数据区，随着进程的销毁而销毁。因此，block 会生成一份对该变量地址的拷贝。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> *foo;</span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, <span class="keyword">int</span> *_foo, <span class="keyword">int</span> flags=<span class="number">0</span>) : foo(_foo) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">impl.foo = &amp;foo;</span><br></pre></td></tr></table></figure><p>访问的时候也是通过指针访问：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> *foo = __cself-&gt;foo; <span class="comment">// bound by copy</span></span><br><span class="line">  NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_qd_7zbm76j916n2_dhjbm6nsm480000gn_T_main_3b4b26_mi_0, (*foo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、捕获-block-修饰的变量"><a href="#4、捕获-block-修饰的变量" class="headerlink" title="4、捕获 __block 修饰的变量"></a>4、捕获 <code>__block</code> 修饰的变量</h4><p>从上面的分析我们可以得到的结论是，当 block 捕获的内容为对象、全局变量、静态全局变量、静态自动变量时，我们都可以通过指针或者变量本身访问到它们的存储域，并且可以在随意修改它们（上面内容没涉及到在 block 内修改变量，可以自行尝试）。但是对于值类型的自动变量，我们不能在 block 内部修改它，具体原因上面也谈到了。OC 提供了一个 <code>__block</code> 关键字给开发者实现对自动变量的捕获和修改，那么当我们用 <code>__block</code> 修饰自动变量之后，block 对变量做了什么呢？如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// insert code here...</span></span><br><span class="line">        __block <span class="keyword">int</span> foo = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^()&#123;</span><br><span class="line">            foo = <span class="number">4</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        blk();</span><br><span class="line">        foo = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当变量 <code>foo</code> 用 <code>__block</code> 修饰之后，在 block 中修改它，编译器不会报错。</p><p>此时，将上述代码编译成 C 代码后发现 block 的实现中多了一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_foo_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">__Block_byref_foo_0 *__forwarding;</span><br><span class="line"> <span class="keyword">int</span> __flags;</span><br><span class="line"> <span class="keyword">int</span> __size;</span><br><span class="line"> <span class="keyword">int</span> foo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>又看到了老朋友 <code>isa</code>，因此我们可以认为 block 使用了 OC 类的结构来存储它捕获到的 <code>__block</code> 变量。令人诧异的是，这个结构体中多了一个 <code>__forwarding</code> 指针。</p><p>此时的 Block：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">main_block_impl_0</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">main_block_desc_0</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  __Block_byref_foo_0 *foo; <span class="comment">// by ref</span></span><br><span class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, struct __main_block_desc_0 *desc, __Block_byref_foo_0 *_foo, <span class="keyword">int</span> flags=<span class="number">0</span>) : foo(_foo-&gt;__forwarding) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多了一个 <code>struct __Block_byref_foo_0</code> 类型的成员 <code>foo</code>。初始化方法多了一个参数，并且默认将传入参数 <code>_foo</code> 的 <code>__forwarding)</code> 指针赋值给成员变量 <code>foo</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __Block_byref_foo_0 *foo = __cself-&gt;foo; <span class="comment">// bound by ref</span></span><br><span class="line">  (foo-&gt;__forwarding-&gt;foo) = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>block 同样也会用 <code>__forwarding</code> 指针去访问捕获的 <code>foo</code> 变量（注意：C语言中， <code>-&gt;</code> 和 <code>.</code> 的区别，值类型的结构体用点语法，引用类型的结构体用 <code>-&gt;</code>）。</p><p>即使出了 block 的作用域，block 仍然会用 <code>__forwarding</code> 访问 <code>foo</code> 变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* @autoreleasepool */</span> &#123; __AtAutoreleasePool __autoreleasepool; </span><br><span class="line"></span><br><span class="line">        __attribute__((__blocks__(byref))) __Block_byref_foo_0 foo = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_foo_0 *)&amp;foo, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_foo_0), <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_foo_0 *)&amp;foo, <span class="number">570425344</span>));</span><br><span class="line">        ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</span><br><span class="line">        (foo.__forwarding-&gt;foo) = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码首先将 <code>foo</code> 变量封装为 <code>__Block_byref_foo_0</code> 类型的对象 <code>foo</code>，然后用对象 <code>foo</code> 实例化一个 block，从 Block 的初始化方法可看出，此时 block 的成员变量 <code>foo</code> 和对象 <code>foo</code> 的 <code>__forwarding</code> 指针指向同一块内存。令人费解的是这行代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(foo.__forwarding-&gt;foo) = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>因为此时，已经出了 block 的作用域，但是仍然用对象 <code>foo</code> 的 <code>__forwarding</code> 指针访问和修改 <code>foo</code> 变量。而且，和捕获自动变量不同的是，block 的实现中多了 <code>copy</code> 和 <code>dispose</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;foo, (<span class="keyword">void</span>*)src-&gt;foo, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(struct __main_block_impl_0*src) &#123;</span><br><span class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;foo, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前说过，当 block 满足被拷贝进堆内存的条件时，它才会实现这两个方法，来管理被捕获对象的内存。并且此时函数的注释是 <code>BLOCK_FIELD_IS_BYREF</code>，这说明当 block 捕获 <code>__block</code> 修饰的变量时，block 也会被拷贝到堆内存，block 会通过枚举值 <code>BLOCK_FIELD_IS_BYREF</code> 和 <code>BLOCK_FIELD_IS_OBJECT</code> 等等来区分拷贝的内容，并且管理它的内存。从上面的实现代码中，我们大概可以运行时的内存布局如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-b95d42dfdd257763.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>block 被拷贝到堆内存，并且 <code>foo</code> 对象作为 block 的成员也被拷贝到堆内存，此时栈中的 <code>foo</code> 对象和堆中的 <code>foo</code> 对象的 <code>__fowarding</code> 指针都指向了堆中的 <code>foo</code> 对象，block 就是通过这种方式完成对 <code>__block</code> 类型的自动变量的捕获，所以即使自动变量 <code>foo</code> 被弹出栈，block 仍然可以修改它，因为自从 <code>__block</code> 变量被捕获的那一刻起，无论在 block 中，还是 block 外部，对它的访问和修改全部都是堆内存中的那一份，并且栈 block 和堆 block 都会对它强引用，当然它也会服从 ARC 的内存管理方式，当栈 block 和堆 block 都不再强引用它的时候，它就会被释放。</p><h3 id="四、-block-循环引用"><a href="#四、-block-循环引用" class="headerlink" title="四、 block 循环引用"></a>四、 block 循环引用</h3><p>理解 block 循环引用需要熟知 OC 内存管理的方式 ARC，参考：<a href="https://zhangxiaom.github.io/2018/01/02/ARC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/" target="_blank" rel="noopener">ARC内存管理以及循环引用</a>。一个运行中的程序是由它的完整的逻辑控制流和一整块的虚拟内存构成的，因此对内存的理解更优先于对语言语法和 API 的掌握。我们应该从更深层次理解 ARC 的工作方式（包括自动释放池、内存管理关键字、一个对象何时创建、何时释放、何时何地引用计数为何等等），而不是用一句使用自动引用计数的方式管理内存涵盖一切。</p><h4 id="1、何时会产生循环引用"><a href="#1、何时会产生循环引用" class="headerlink" title="1、何时会产生循环引用"></a>1、何时会产生循环引用</h4><p>从上文中可以知道 block 捕获对象的时候，会强引用一次对象，此时假如 block 被赋值为该对象的某一个 <code>strong</code> 修饰的属性或者实例变量时，那么该对象也就会强引用一次 block，因此就造成了它们之间的互相循环引用。ARC 会在一个对象的引用计数为 0 的时候回收一个对象占有的堆内存，而循环引用会导致 block 和对象的引用计数永远都不为 0，从而导致它们占用的内存永远不会被释放。</p><p>那么什么时候对象会强引用 block？如果对内存有一定了解的话，应该知道只有堆内存是需要我们手动管理的，也就是只有堆内存中的数据才遵循自动引用计数的规则，因此只有当 block 被拷贝到堆内存时才会有循环引用的概念。上文中提及的几个 block 会被拷贝到堆内存的情况就是我们需要注意循环引用的地方。当 block 存储在栈内存，例如作为函数的参数并且在函数内不会被函数的调用者强引用，或者存储在全局区都不用担心循环引用的问题。当 block 被赋值给一个 <code>strong</code> 或者 <code>copy</code> 关键字修饰的成员变量时，我们就应该注意使用它的时候是否会产生循环引用，因为此时 block 会被拷贝到堆内存，并且拥有该成员变量的对象会间接地强引用 block，假如此时 block 也强引用该对象的话，就会产生循环引用。这里（<a href="https://zhangxiaom.github.io/2018/01/02/ARC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/" target="_blank" rel="noopener">ARC内存管理以及循环引用</a>）会详细介绍啥叫循环引用。</p><h4 id="2、block-捕获-weak-变量"><a href="#2、block-捕获-weak-变量" class="headerlink" title="2、block 捕获 weak 变量"></a>2、block 捕获 weak 变量</h4><p>使用 <code>weak</code> 关键字解决循环引用是大多数人都掌握的一个手段，但是好像并没有多少人关心 <code>weak</code> 关键字如何解决循环引用的，当然大家可能都会说一个弱引用，像这种问题我们最好不要这样一言以蔽之。</p><p>关于 <code>weak</code> 关键字的特性不是我们本文讨论的重点，下面的论述默认大家对 <code>weak</code> 关键字的特性有一定的了解。上文说了，block 捕获对象的时候会生成一个引用该对象的变量的<a href="https://zh.wikipedia.org/wiki/%E5%88%AB%E5%90%8D_(%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">别名</a> )，此别名和外部变量具有相同的内存管理语义。因此，当 block 捕获 <code>weak</code> 变量引用的对象时，实际上生成的别名仍然是具有 <code>weak</code> 特质的。如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> foo = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">__<span class="keyword">weak</span> <span class="keyword">id</span> bar = foo;</span><br><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^()&#123;</span><br><span class="line">    [bar addObject:<span class="string">@""</span>];</span><br><span class="line">&#125;;</span><br><span class="line">blk();</span><br></pre></td></tr></table></figure><p>此时的内存布局为：</p><p><img src="https://upload-images.jianshu.io/upload_images/5314152-f44da8c134a5824f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因此，此时的 block 不会强引用 <code>NSMutableArray</code> 对象，当变量不再强引用对象时，对象就会被释放。下面的代码可证明上述结论：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> foo = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> bar = foo;</span><br><span class="line">    blk = ^()&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, bar);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">blk();</span><br></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-06</span><span class="number">-06</span> <span class="number">17</span>:<span class="number">44</span>:<span class="number">45.199394</span>+<span class="number">0800</span> XXX[<span class="number">49068</span>:<span class="number">7235369</span>] (null)</span><br></pre></td></tr></table></figure><p>由此可见，当 <code>foo</code> 变量出了其作用域之后（不再强引用对象），<code>NSMutableArray</code> 对象即被释放，证明了我们的结论（注意：不要用类工厂方法创建 <code>NSMutableArray</code> 对象，因为自动释放池会强引用它一次，即使 <code>foo</code> 不再强引用它，它的引用计数仍然为 1）。</p><h4 id="3、关于-weak-strong-dance"><a href="#3、关于-weak-strong-dance" class="headerlink" title="3、关于 weak-strong dance"></a>3、关于 weak-strong dance</h4><p>像上文中的情况，假如我们使用了 <code>weak</code> 解决循环引用，就会造成一些问题，就是被捕获的对象会被释放，那么我们就会得到错误的结果，很多人会告诉我们使用 weak-strong dance 解决这类问题，但是真的有效吗？如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>);</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> foo = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> weak_foo = foo;</span><br><span class="line">    blk = ^()&#123;</span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">id</span> strong_foo = weak_foo;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, strong_foo);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">blk();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,blk);</span><br></pre></td></tr></table></figure><p>程序执行结果为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span><span class="number">-06</span><span class="number">-06</span> <span class="number">18</span>:<span class="number">06</span>:<span class="number">58.564651</span>+<span class="number">0800</span> XXX[<span class="number">49189</span>:<span class="number">7362233</span>] (null)</span><br><span class="line"><span class="number">2018</span><span class="number">-06</span><span class="number">-06</span> <span class="number">18</span>:<span class="number">06</span>:<span class="number">58.565225</span>+<span class="number">0800</span> XXX[<span class="number">49189</span>:<span class="number">7362233</span>] &lt;__NSMallocBlock__: <span class="number">0x100653040</span>&gt;</span><br></pre></td></tr></table></figure><p>好像并没有生效，从理论上来说，block 的执行函数会强引用一次捕获的对象以此来使对象不被释放，但是假如 block 的执行函数执行的时候，对象已经被释放，那么强引用不还是对 <code>nil</code> 强引用的吗？所以，weak-strong dance 只能帮助我们防止在block 执行的过程中捕获的对象被释放，并不能解决 block 执行之前对象被释放的问题，因此请慎用 <code>weak</code> ，weak-strong dance 并不能保证 block 执行时对象不被释放。 所以即使大部分开发者认为 weak-strong dance 能解决这样的问题，我们仍然要抱着质疑的态度去面对这样的观点。</p><h3 id="写在最后的话"><a href="#写在最后的话" class="headerlink" title="写在最后的话"></a>写在最后的话</h3><p>请不要完全相信本文的任何一个观点和结论。尽信书不如无书，请抱着学习的态度研究问题，而不是为了应付面试。</p><p>源码和官方文档会告诉你想知道的一切！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为 iOS 开发者，不管是初级还是高级，都应该知道并且熟练应用 OC 中的 block 语法。大多数开发者都知道 block 会造成循环引用，但是很少有人会关心 block 造成循环引用的原理和如何正确的避免，大多数人遇到 block 就用 weak 引用这种简单粗暴的方
      
    
    </summary>
    
    
      <category term="iOS 内存管理" scheme="http://yoursite.com/tags/iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>揭秘instancetype</title>
    <link href="http://yoursite.com/2018/04/19/%E6%8F%AD%E7%A7%98instancetype/"/>
    <id>http://yoursite.com/2018/04/19/揭秘instancetype/</id>
    <published>2018-04-19T06:37:06.000Z</published>
    <updated>2019-09-01T03:37:02.779Z</updated>
    
    <content type="html"><![CDATA[<p>苹果官方会建议我们用 <code>instancetype</code> 类型代替 <code>id</code> 类型作为某个类的初始化方法的返回值。以下内容摘自<a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html#//apple_ref/doc/uid/TP40014150-CH1-SW11" target="_blank" rel="noopener">Adopting Modern Objective-C</a>:</p><blockquote><p>Use the instancetype keyword as the return type of methods that return an instance of the class they are called on (or a subclass of that class). These methods include alloc, init, and class factory methods.</p></blockquote><h3 id="一、初始化方法为什么用id类型而不是-类名-类型作为返回值类型"><a href="#一、初始化方法为什么用id类型而不是-类名-类型作为返回值类型" class="headerlink" title="一、初始化方法为什么用id类型而不是 [类名] 类型作为返回值类型"></a>一、初始化方法为什么用id类型而不是 [类名] 类型作为返回值类型</h3><p>在 <code>instancetype</code> 关键字出现之前，我们会用 <code>id</code> 作为类初始化方法的返回类型，在 <code>instancetype</code> 关键字出现之后，编译器会主动将 <code>alloc</code> <code>init</code> <code>new</code> 开头的方法的返回值类型替换为 <code>instancetype</code>， 那么在 <code>instancetype</code> 出现之前，为什么不用该类自身的类型而是用 <code>id</code> 类型作为初始化方法的返回值。答案是 OC 的类继承体系。</p><p>假如，有一个类 <code>SuperClass</code>的初始化方法返回类型为它自己的类型，并且不会被编译器替换为 <code>instancetype</code> ：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (SuperClass *)init;</span><br></pre></td></tr></table></figure><p>那么当它的子类重写这个初始化方法的时候，只能返回它自身的实例，而无法返回子类的实例。因为重写父类方法， 必须和被重写的方法有相同的返回类型。所以子类永远无法通过重写这个父类初始化方法初始化自身。所以为了实现重写初始化方法（用父类初始化自身）的继承体系，必须要用一种通用类型，既能表述子类实例也能表述父类实例的类型，刚好 <code>NSObject</code> 是所有类的根类，由于 OC 的多态性，<code>id</code> 类型的变量可以指向任意类型的对象，因此，用 <code>id</code> 类型作为初始化方法的返回类型可以很好的解决类继承的问题。</p><h3 id="二、instancetype-取代-id"><a href="#二、instancetype-取代-id" class="headerlink" title="二、instancetype 取代 id"></a>二、instancetype 取代 id</h3><p>有的人会认为 <code>instancetype</code>类型和 <code>id</code> 类型是一种类型的不同表达方式，其实并不是。 <code>instancetype</code> 顾名思义是当前类的实例类型，听起来好像和类名类型并没有上面区别，实则，它更严谨的遵循 OC 的继承体系。<code>instancetype</code> 类型只表述当前类的继承线，例如 <code>NSMutableString -&gt; NSString -&gt;...-&gt; NSObject</code>，而 <code>id</code> 类型相对来说更博爱一点。</p><p>在适当的地方使用 <code>instancetype</code> 关键字可以提高代码的类型安全。例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface MyObject : <span class="built_in">NSObject</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)factoryMethodA;</span><br><span class="line">+ (<span class="keyword">id</span>)factoryMethodB;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)factoryMethodA &#123; <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init]; &#125;</span><br><span class="line">+ (<span class="keyword">id</span>)factoryMethodB &#123; <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init]; &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> x, y;</span><br><span class="line"> </span><br><span class="line">    x = [[MyObject factoryMethodA] count]; <span class="comment">// Return type of +factoryMethodA is taken to be "MyObject *"</span></span><br><span class="line">    y = [[MyObject factoryMethodB] count]; <span class="comment">// Return type of +factoryMethodB is "id"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类 <code>MyObject</code> 声明并实现了两个相同类工厂方法，用来返回初始化后的 <code>MyObject</code> 对象，只是返回的类型一个是 <code>instancetype</code>，一个是 <code>id</code>。编译器在代码 <code>y</code> 处不会提示任何警告和错误，并且在编译期也没有任何错误，但是当到了运行期就会崩溃。因为此时的 <code>MyObject</code> 实例可能是任意一个类的实例，只要某个类中有 <code>-count</code> 这个方法存在，那么编译器就会认为返回的实例可能是这个有 <code>-count</code> 方法的类，所以它不会报错。但是，当运行期去 <code>MyObject</code> 类中查找这个方法的时候，才会出现找不到这个方法并且发送和转发失败的crash。关于<a href="https://juejin.im/post/5a4c40a35188257d1718e447" target="_blank" rel="noopener">运行时</a>。</p><p>而代码 <code>y</code> 处，该类工厂方法返回的是 <code>instancetype</code> 类型，该类型即为 <code>MyObject</code> 类型，编译器会去它和它的父类中去寻找调用的方法，如果找不到那么就会报错，并且编译失败。</p><p>因此，<code>instancetype</code> 类型比 <code>id</code> 类型有更好的类型安全性，让隐患和错误的暴露提前到代码的编写期，避免了应用的运行时crash。</p><h3 id="三、类工厂方法使用-self-class-实例化而不是类名"><a href="#三、类工厂方法使用-self-class-实例化而不是类名" class="headerlink" title="三、类工厂方法使用[self class]实例化而不是类名"></a>三、类工厂方法使用[self class]实例化而不是类名</h3><p>例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SuperClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)factor;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SuperClass</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)factor &#123;</span><br><span class="line">    <span class="keyword">return</span> [[SuperClass alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>由于类的继承体系，子类也可以调用父类方法，当子类调用父类的这个类工厂方法初始化自身的时候，实际上返回的实例还是父类的实例，而不是子类自身的实例，但是编译器没有办法判断这些，因为它根据类继承体系找到了正确的方法。当向此实例发送子类的消息的时候，会在运行时crash，因为它会从父类实例方法列表中查找这个子类的方法，然而父类并没有这个方法。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([[SubClass factor] <span class="keyword">class</span>]));</span><br><span class="line"><span class="comment">// log: SuperClass</span></span><br></pre></td></tr></table></figure><p>因此，当我们用类工厂方法初始化自身的时候，一定要用 <code>[self class]</code> 实例化自身，而不是类名：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)factor &#123;</span><br><span class="line">    <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子类就可以通过调用这个父类的类工厂方法初始化自己：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([[SubClass factor] <span class="keyword">class</span>]));</span><br><span class="line"><span class="comment">// log: SubClass</span></span><br></pre></td></tr></table></figure><h3 id="四、单例返回类型用类名"><a href="#四、单例返回类型用类名" class="headerlink" title="四、单例返回类型用类名"></a>四、单例返回类型用类名</h3><p>某种程度上来说，单例的初始化方法也是一个类工厂方法，单例使用【类名】类型，而不是 <code>instancetype</code> 的原因是：一般情况下，不会有其他类继承自单例类，因此，单例类在初始化的时候不用考虑对其子类的影响，因此单例类可以肆无忌惮的使用类名类型作为初始化方法的返回值类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;苹果官方会建议我们用 &lt;code&gt;instancetype&lt;/code&gt; 类型代替 &lt;code&gt;id&lt;/code&gt; 类型作为某个类的初始化方法的返回值。以下内容摘自&lt;a href=&quot;https://developer.apple.com/library/content/re
      
    
    </summary>
    
    
      <category term="iOS API 详解" scheme="http://yoursite.com/tags/iOS-API-%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>哈希表</title>
    <link href="http://yoursite.com/2018/03/23/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/03/23/哈希表/</id>
    <published>2018-03-23T06:36:40.000Z</published>
    <updated>2019-09-01T03:37:02.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-哈希表的优势"><a href="#前言-哈希表的优势" class="headerlink" title="前言 哈希表的优势"></a>前言 哈希表的优势</h2><p>数据结构存在的意义是处理数据，对数据的基本处理无非是增删改查，即插入、删除、查找、修改。对线性表（数组）来说，插入和删除的时间复杂度是O(N)，即每次插入和删除都要改变插入位置后面所有元素的个数，从而造成O(N)的时间复杂度，而查找和修改的时间复杂度是O(1)，因为可以直接用下标得到那个位置的元素。对链表来说，插入和删除的时间复杂度为O(1)，而查找和修改的时间复杂度为O(N)，因为必须从头结点开始查找。而哈希表却可以实现增删改查都是O(1)的时间复杂度，只要设计的哈希函数足够合理。如果足够不合理的话，它查找和修改的最坏时间复杂度也是O(N)。因此，哈希表不只是一个简单的键值存储结构，而是结合了顺序表和链表共同优点的高速存取的数据结构。</p><p>哈希表的实质是分布不均匀的线性表，所有元素散列在线性表中，通过哈希函数来计算线性表的索引，通过索引进行存取，存取的数据结构还是基于线性表和链表。同样也会造成不能对线性表空间的利用最大化。</p><h2 id="一、哈希函数和哈希码"><a href="#一、哈希函数和哈希码" class="headerlink" title="一、哈希函数和哈希码"></a>一、哈希函数和哈希码</h2><blockquote><p>A hash function is any function that can be used to map data of arbitrary size to data of fixed size. The values returned by a hash function are called hash values, hash codes, digests, or simply hashes. （来自维基百科）</p></blockquote><blockquote><p>哈希函数就是能将任意长度的数据映射为固定长度的数据的函数。哈希函数返回的值被叫做哈希值、哈希码、散列，或者直接叫做哈希。</p></blockquote><p>固定长度即为所使用的线性表的长度，哈希码即为线性表的索引，通过哈希码直接对数据进行存取。键值对中的键是计算哈希码的主要依据，</p><p>常见的哈希函数有：</p><ul><li>直接寻址法：取keyword或keyword的某个线性函数值为散列地址。即H(key)=key或H(key) = a*key + b，当中a和b为常数（这样的散列函数叫做自身函数）。</li><li>数字分析法：分析一组数据，比方一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体同样，这种话，出现冲突的几率就会非常大，可是我们发现年月日的后几位表示月份和详细日期的数字区别非常大，假设用后面的数字来构成散列地址，则冲突的几率会明显减少。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</li><li><p>平方取中法：取keyword平方后的中间几位作为散列地址。</p></li><li><p>折叠法：将keyword切割成位数同样的几部分，最后一部分位数能够不同，然后取这几部分的叠加和（去除进位）作为散列地址。</p></li><li><p>随机数法：选择一随机函数，取keyword的随机值作为散列地址，通经常使用于keyword长度不同的场合。</p></li><li><p>除留余数法：取keyword被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p, p &lt;=   m。不仅能够对keyword直接取模，也可在折叠、平方取中等运算之后取模。对p的选择非常重要，一般取素数或m，m为线性表的长度。</p></li></ul><p>好的哈希函数会使所有的因素都均匀的分布在线性表中，不会产生哈希冲突，同样，差的哈希函数也会使每个元素都会产生哈希冲突。</p><h2 id="二-哈希表的存取"><a href="#二-哈希表的存取" class="headerlink" title="二 哈希表的存取"></a>二 哈希表的存取</h2><p>假如现在有一组需要存入哈希表的字符串，我们设置的键值对为：<br><code>&quot;1&quot;: A&quot;, &quot;2&quot;: &quot;B&quot;, &quot;3&quot;: &quot;C&quot;, &quot;4&quot;: &quot;D&quot;, &quot;5&quot;: &quot;E&quot;, &quot;6&quot;: &quot;F&quot;, &quot;7&quot;:  &quot;G&quot;, &quot;8&quot;: &quot;H&quot;, &quot;9&quot;: &quot;I&quot;</code>，假设通过键计算得到的哈希码分别是：2，4，6，9，1，3，6，7，9。可以看出，这些数据可以存储到一个长度为10的线性表中(存储的数据类型为结构体或者模型类)：</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/23/16251e4a17cd64b0?w=652&amp;h=130&amp;f=png&amp;s=7216" alt=""></p><p>从上图可看出，线性表下标为6和9的地方产生了哈希冲突，即同一个坑被两个元素占了，这说明我们的哈希函数计算得到的哈希码不是足够均匀。</p><p>当取值的时候，可以直接使用哈希码作为下标直接访问线性表的下标，在访问下标的过程中，会对键进行一次比较，如果当前位置存的键和提供的键是同一个键，则取值，如果不是则根据解决哈希冲突的方法继续寻找。</p><h2 id="三-哈希冲突"><a href="#三-哈希冲突" class="headerlink" title="三 哈希冲突"></a>三 哈希冲突</h2><h3 id="1、线性探测法"><a href="#1、线性探测法" class="headerlink" title="1、线性探测法"></a>1、线性探测法</h3><p>如上文所示，在向哈希表中存值得时候产生了哈希冲突，假设线性表下标为6的位置装填了<code>&quot;3&quot;: &quot;C&quot;</code>，而我想通过键<code>&quot;7&quot;</code>，获取<code>&quot;G&quot;</code>这个值得时候，因为<code>&quot;7&quot;</code>和<code>&quot;3&quot;</code>的哈希码都是6，因此通过<code>&quot;7&quot;</code>访问的线性表下标为6的位置，就会得到错误的结果。</p><p>线性探测法解决哈希冲突的中心思想就是当向线性表中装填键值对的时候，如果当前位置有值存在，则将它装填在线性表当前位置往后的下一个空位，如果当前位置往后都没有位置，那么就从0开始找空位，然后插入。插入的时间复杂度为O(N)，即：</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/23/16251fa4a35a0702?w=652&amp;h=164&amp;f=png&amp;s=9463" alt=""></p><p>当我们通过键<code>&quot;7&quot;</code>，获取<code>&quot;G&quot;</code>这个值得时候，会先通过哈希码6去找线性表中下标6对应的位置，然后比较键<code>&quot;7&quot;</code>和线性表中存储的键，如果相等则取出，如果不相等，则从当前位置开始向后遍历线性表，超过最后一个则从0开始，直到找到为止。因此，这种查找的时间复杂度为O(N)，假如哈希函数足够差，例如所有键的哈希函数都相等，就会造成每一个元素的查找时间复杂度都为O(N)。</p><h3 id="2、链式法"><a href="#2、链式法" class="headerlink" title="2、链式法"></a>2、链式法</h3><p>链式法解决哈希冲突的中心思想为将冲突的元素存入一个链表：</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/23/162522f61b6a4f08?w=652&amp;h=154&amp;f=png&amp;s=9053" alt=""></p><p><code>&quot;3&quot;: &quot;C&quot;</code>为冲突位置链表的头结点，当我们继续插入一个哈希码也为6的键值对<code>10: &quot;J&quot;</code>时，此时：</p><p><img src="https://user-gold-cdn.xitu.io/2018/3/23/16252318a5c3af6e?w=652&amp;h=218&amp;f=png&amp;s=10238" alt=""></p><p>每次装填发生冲突的键值对时，都会将新加入的键值对插入到冲突链表的头结点。此时插入的时间复杂度为O(1)，同理，当通过键<code>&quot;7&quot;</code>的哈希码6取值得时候，会先比较6的位置中存的键和<code>&quot;7&quot;</code>是否相等，如果相等则取出，否则从头结点开始遍历链表直到找到相等的键为止，此时取出的值即为结果，这种查找的时间复杂度也为O(N)，java语言的<code>HashMap</code>就是用这种方法解决的哈希冲突。</p><h2 id="四、其他概念"><a href="#四、其他概念" class="headerlink" title="四、其他概念"></a>四、其他概念</h2><h3 id="1、装填因子"><a href="#1、装填因子" class="headerlink" title="1、装填因子"></a>1、装填因子</h3><p>装填因子 = 当前装填的元素个数 / 线性表的长度；</p><p>每次插入新的元素的时候，我们都会记录当前装填入线性表的元素个数，当装填因子超过某个值得时候，例如0.75，我们就会将线性表的长度进行扩充，然后将线性表中没一个元素都进行重新hash。这样做的目的当然也是为了尽可能的减少哈希冲突，因为装填因子越大，线性表中剩余的位置越少，就越容易产生哈希冲突。</p><h3 id="2、isEqual-amp-hash"><a href="#2、isEqual-amp-hash" class="headerlink" title="2、isEqual() &amp; hash()"></a>2、isEqual() &amp; hash()</h3><p>对于C++、java、OC等语言，任何对象都可以作为哈希表的键。已经有的库中的类，他们会实现对应的<code>hash()</code>函数和<code>isEqual()</code>函数，但是当使用开发者自己实现的类的对象作为键的时候，该类必须重写根类的<code>hash()</code>函数和<code>isEqual()</code>函数，<code>hash()</code>函数是为了计算哈希码，<code>isEqual()</code>是为了当发生哈希冲突的时候，可以通过这个方法找到确定的值，因为键的类型为包装对象而不是基础数据类型，所以不能使用简单的<code>==</code>比较地址。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言-哈希表的优势&quot;&gt;&lt;a href=&quot;#前言-哈希表的优势&quot; class=&quot;headerlink&quot; title=&quot;前言 哈希表的优势&quot;&gt;&lt;/a&gt;前言 哈希表的优势&lt;/h2&gt;&lt;p&gt;数据结构存在的意义是处理数据，对数据的基本处理无非是增删改查，即插入、删除、查找、修
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>类和元类</title>
    <link href="http://yoursite.com/2018/02/09/%E7%B1%BB%E5%92%8C%E5%85%83%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/02/09/类和元类/</id>
    <published>2018-02-09T06:35:45.000Z</published>
    <updated>2019-09-01T03:37:02.779Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/1/9/160d9b1f81329645?w=596&amp;h=620&amp;f=png&amp;s=74424" alt=""></p><p>Objective-C 是一门基于类的对象系统，每一个对象都是某个类的实例；对象的 <code>isa</code> 指针指向它的类。该类描述对象的一些信息：数据占用的空间，变量的类型和布局等。该类也描述对象的一些行为：对象可以响应的选择器（<code>selector</code>）和对象实现的实例方法。</p><p>（注：面向对象的含义，类是一类事物的共有特性的描述，比如：“人”类中的“姓名”，“年龄”等属性，“吃饭”、“喝水”等行为，所有的人都具备，所以类是对象的属性和行为的描述）</p><p>类中的方法列表是实例方法（对象可以响应的选择子）的集合。当你向对象发送一个消息的时候，<code>objc_msgSend()</code> 会通过查询该对象的类（和父类）中的方法列表来决定调用什么方法。</p><p>每一个 Objective-C 的类也是一个对象。它也有自己的 <code>isa</code> 指针、数据以及它可以响应的选择子。当你调用一个类方法的时候，例如 <code>[NSObject alloc]</code>，实际上你是向这个类对象（<code>NSObject</code>）发送了一条消息。</p><p>由于类也是对象，那么它一定也是某一个类的实例，即元类。就像类是普通对象的描述一样，元类是类对象的描述。值得一提的是，元类的方法列表中存的是类方法：类对象可以响应的选择子。当你向一个类对象（元类的实例）发送消息（调用类方法）的时候，<code>objc_msgSend()</code> 会通过查询该类对象的元类（和父元类）中的方法列表来决定调用什么方法。就像实例方法是类对对象的行为的描述一样，类方法是元类对类对象的行为的描述（有点拗口）。</p><p>那么元类呢？是最底层的吗？不，元类是根类（<code>NSObject</code>）的元类的实例，根元类是根元类自己的实例，<code>isa</code> 指针链在一个循环处结束：对象 -&gt; 类对象 -&gt; 元类 -&gt; 根元类 -&gt; 根元类自身（-&gt; 指向）。元类的 <code>isa</code> 指针的行为很少受到关注，因为在现实中没有人可以向元类对象发送消息。</p><p>那么元类的父类是谁呢？元类的父类链平行于类的父类链，所以类方法的继承关系和实例方法是一样的。并且根元类的父类是根类（即，<code>NSObject</code> 的元类的父类是它自己）（划重点），所以每一个类对象都可以响应根类的实例方法（即，根类的实例方法其实也是每一个类的类方法）。所以，类对象也和其他对象一样，都是根类的实例，但是类对象也是根类的子类。</p><p>是不是很迷惑，上面这张图可以帮助到你！请记住，当你向一个对象发消息的时候，方法的查找会从对象的 <code>isa</code> 指针开始，然后继续顺着父类链查找。“实例方法”在类中定义，“类方法”在元类和根类中定义。</p><p>（注：方法列表中并没有什么值来规定某一个方法是类方法还是实例方法，一个对象能通过 <code>isa</code> 指针和父类链找到的那个方法就是它能响应的方法，所以，类对象可以通过根元类的父类指针找到根类中的方法，那么它就可以响应这个方法，即使你认为根类中存的应该是“实例方法”。）</p><p>在正式的计算机科学语言中，类和元类的继承制度是更自由的形式，比如，更深层的元类链和很多类是某单一元类的实例。OC相对于 使用元类实现像类方法这样的实际目标，更趋向于隐藏元类。例如： 其实 <code>[NSObject class]</code> 和 <code>[NSObejct self]</code> 是等价的，即使，理论上它应该返回 <code>NSObject -&gt; isa</code> 指向的的元类。 </p><p>本文参考苹果公司 <code>runtime</code> 源码的维护者 <em>Greg Parker</em> 的 blog: <a href="https://user-gold-cdn.xitu.io/2018/1/9/160d9b3483b97e0b" target="_blank" rel="noopener">[objc explain]: Classes and metaclasses</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/1/9/160d9b1f81329645?w=596&amp;amp;h=620&amp;amp;f=png&amp;amp;s=74424&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Objective-C 是一门基于
      
    
    </summary>
    
    
      <category term="iOS 运行时" scheme="http://yoursite.com/tags/iOS-%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>从runtime源码解析消息发送的动态性</title>
    <link href="http://yoursite.com/2018/01/20/%E4%BB%8Eruntime%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7/"/>
    <id>http://yoursite.com/2018/01/20/从runtime源码解析消息发送的动态性/</id>
    <published>2018-01-20T03:30:55.000Z</published>
    <updated>2019-09-01T03:37:02.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>本文不是对runtime的使用的简单的阐述，而是我对runtime中消息发送的一些更深层的理解。</p><p>不要相信任何博客或者文章，apple 的 opensource 源代码会告诉我们想知道的一切，所以善用源码可能会事半功倍。</p><h2 id="一、结构体-vs-类"><a href="#一、结构体-vs-类" class="headerlink" title="一、结构体 vs 类"></a>一、结构体 vs 类</h2><p>我们知道，OC 是 C 语言的超集，是对 C 和 C++ 的进一步封装，一开始学习 OC 这门语言的时候，我们就被灌输过一句话：对象存储在堆内存，变量存储在栈内存，而 runtime 告诉我们类是对 C 和 C++ 中结构体的封装，而结构体是值类型（<a href="https://zhangxiaom.github.io/2018/01/02/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8Swift%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">值类型 vs 引用类型</a>），肯定是存储在栈上的，这不是自相矛盾吗？另外，OC1.0 是完全对 C 语言的封装，C 语言的结构体是不能声明和实现函数的，到底是怎么回事呢？现在我们用结构体实现一个简单的类：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">// 声明一个指针变量 sum，它的类型为具有一个 int 类型返回值，两个 int 类型参数的函数。</span></span><br><span class="line">    <span class="keyword">int</span>(*sum)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>* <span class="title">PFoo</span>;</span> <span class="comment">// PFoo 为一个指向 Foo 结构体的指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个指针指向 Foo 结构体，PFoo就是引用类型，pFoo 就是分配在栈内存的变量</span></span><br><span class="line">    PFoo pFoo; </span><br><span class="line">    <span class="comment">// 相当于 OC 中的alloc，将实例存入堆内存，现在 pFoo 就指向（引用）一个堆内</span></span><br><span class="line">    <span class="comment">// 存的实例</span></span><br><span class="line">    pFoo = (PFoo)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PFoo));</span><br><span class="line">    <span class="comment">// init 初始化操作</span></span><br><span class="line">    pFoo -&gt; val = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 将函数 sum() 赋值给 pFoo 的成员变量 sum</span></span><br><span class="line">    pFoo -&gt; sum = sum;</span><br><span class="line">    <span class="comment">// use</span></span><br><span class="line">    <span class="comment">// 通过函数指针调用函数，pFoo -&gt; sum 是一个指向函数sum的指针</span></span><br><span class="line">    <span class="keyword">int</span> result = (pFoo -&gt; sum)(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, result);</span><br><span class="line">    <span class="comment">// print "result = 9"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(pFoo);</span><br><span class="line">    <span class="comment">// 将 pFoo 设置为空指针</span></span><br><span class="line">    pFoo = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述的代码就是用结构体实现一个简单的类，其实真正的runtime对类的实现比这个要复杂的多的多，函数的调用也不是简单的通过函数指针的成员变量调用，说这个只是想引入一下函数指针对类的意义以及值类型和引用类型的关系。</p><h2 id="二、OC-消息发送的动态性"><a href="#二、OC-消息发送的动态性" class="headerlink" title="二、OC 消息发送的动态性"></a>二、OC 消息发送的动态性</h2><h3 id="1-动态性"><a href="#1-动态性" class="headerlink" title="1. 动态性"></a>1. 动态性</h3><p>提及 OC 及 runtime，我们听到最多的一句话就是 OC 是一门动态类型的语言，所谓的动态和静态的区分主要是指程序的执行是依赖于编译期还是运行期。</p><p>如果一段程序的执行在编译结束后就决定了它的内存分配，那么我们就可以说它是个静态类型的语言，而 OC 的动态性在于，它在编译期只是进行简单的语义语法检查，而不会分配内存。它在编译期只关心某个类型的某个对象能不能调用某个方法，而不会关心这个对象是不是 <code>nil</code>，也不会关心这个方法的实现细节，甚至不关心到底有没有这个方法，这些事都是运行期才会去做的事。</p><p>这就决定了我们可以在运行期对我们的程序做更多的更改，当然也存在很多弊端，有句话说得好：“动态类型一时爽，代码重构火葬场”，运行期分配内存确实会让我们的程序出现很多运行时的错误，比如，访问了野指针、内存泄漏等等，确实会给程序带来很多灾难性的bug，甚至于必须重构代码才能解决。</p><p>因此，对运行时的充分了解能使我们尽最大可能的规避这些错误，从而减少我们踩坑的几率和填坑的时间。</p><h3 id="2-消息发送的动态性"><a href="#2-消息发送的动态性" class="headerlink" title="2. 消息发送的动态性"></a>2. 消息发送的动态性</h3><p>举个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye, world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">(<span class="keyword">int</span> anyState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数的调用由编译时决定，函数的汇编指令是硬编码</span></span><br><span class="line">    <span class="keyword">if</span> (anyState) &#123;</span><br><span class="line">        hello();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bye();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码是一段简单的C语言代码，不管会不会 C 语言，应该都能看得懂，当调用 <code>doSomeThing()</code> 的时候，不管 <code>if</code> 条件是不是成立，程序都会将 <code>hello()</code> 和 <code>bye()</code> 这两个函数的汇编指令硬编码进汇编指令集。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/3/160ba89f6a138776?w=357&amp;h=130&amp;f=png&amp;s=812" alt=""></p><p>假设 <code>hello()</code> 和 <code>bye()</code> 这两个函数在代码区中的存储为上图，则在 <code>doSomeThing()</code> 中，编译器会在编译期，在 <code>if</code> 和 <code>else</code> 中都会将这两块内存生成的汇编指令硬编码进汇编指令集。类似于：<br><img src="https://user-gold-cdn.xitu.io/2018/1/3/160ba950601b8af2?w=142&amp;h=386&amp;f=png&amp;s=5963" alt=""><br>这就是一种静态的调用函数的方式，而动态的调用方法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye, world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">(<span class="keyword">int</span> anyState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译时只获取函数的地址，运行时才发出指令，执行函数</span></span><br><span class="line">    <span class="keyword">void</span> (*func)();</span><br><span class="line">    <span class="keyword">if</span> (anyState) &#123;</span><br><span class="line">        func = hello;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        func = bye;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码和上述代码的差异为，在 <code>if</code> 条件语句中调用函数的方式变成了函数指针而不是简单的函数调用。它的动态性体现在，编译器在编译期仅仅获取函数的首地址，将指向函数的首地址硬编码进汇编指令集，而不是将整个函数的指令全部硬编码，到运行时再去决定调用那个函数（访问哪个函数的内存）。如果你在运行时强制将这个本来指向某个函数的指针指向另一个函数，那么这就是所谓的方法交换。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/3/160baa595f67d978?w=397&amp;h=302&amp;f=png&amp;s=11045" alt=""></p><p>这就是所谓的调用函数的动态性。OC 这门语言就是采用这种函数指针的方式实现消息发送的动态性。当然也不可能实现的这么简单。</p><p>真正的汇编指令集肯定不可能这么简单，只是简单画了一下，更容易理解一点。</p><h2 id="三、将方法存储到类"><a href="#三、将方法存储到类" class="headerlink" title="三、将方法存储到类"></a>三、将方法存储到类</h2><p>OC 的动态性并不仅仅体现在消息发送方面，还有其他的，比如，运行时添加属性、添加成员变量、消息转发等等，其实对属性、变量和方法的封装大同小异，这里仅分析了 runtime 对消息的存储和获取。</p><p>大家都知道的一件事就是，OC 中类的实质是结构体，结构体中存储了所有的成员方法列表、属性列表、协议列表等等。存储结构如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/3/160baf94d0a49b21?w=828&amp;h=563&amp;f=png&amp;s=51340" alt=""></p><p>可以看到一个 <code>method_array_t</code> 类型的变量 <code>methods</code>，这就是类中的方法列表，<code>method_array_t</code> 是一个类，所以 <code>methods</code> 指向一个类实例，它在runtime中的组成为：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/3/160bb0fb7806de8b?w=1034&amp;h=344&amp;f=png&amp;s=31137" alt=""></p><p>可以看到，方法列表最终存储的东西为 <code>method_t</code> 结构体，它有三个成员变量，一个 <code>name</code>，可以理解为方法的签名，OC 会通过方法签名去列表中查找某个方法的实现，runtime 对它的定义为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method selector.</span><br><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure><p>可以看出这是一个指针类型，指向 <code>objc_selector</code> 结构体。另一个成员为：<code>const char *types</code> 常量为 OC 运行时方法的 typeEncoding 集合，它指定了方法的参数类型以及在函数调用时参数入栈所要的内存空间，没有这个标识就无法动态的压入参数 <a href="https://user-gold-cdn.xitu.io/2018/1/3/160bb2b1fa08761a" target="_blank" rel="noopener">Type Encoding</a>。</p><p>而 <code>IMP imp</code> 就是一个指向函数的函数指针，就是一个指向方法的首地址的指针。<code>IMP</code> 类型被定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>可以看出这也是一个指针类型，指向一个函数，即函数指针。当我们向对象的方法列表添加方法的时候，会调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">class_addMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> ! addMethod(cls, name, imp, types ?: <span class="string">""</span>, NO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addMethod()</code> 会返回一个 <code>IMP</code> 类型的函数指针，这个函数会将传入的 <code>imp</code> 添加进类的函数列表，并且更新缓存，最后返回这个 <code>imp</code>。如果 <code>addMethod()</code> 方法返回为空指针，则添加失败，返回 <code>false</code>。<code>addMethod()</code> 方法的具体实现细节为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> IMP </span><br><span class="line">addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="keyword">bool</span> replace)</span><br><span class="line">&#123;</span><br><span class="line">    IMP result = nil;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    assert(types);</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">method_t</span> *m;</span><br><span class="line">    <span class="keyword">if</span> ((m = getMethodNoSuper_nolock(cls, name))) &#123;</span><br><span class="line">        <span class="comment">// already exists  </span></span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">            result = m-&gt;imp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = _method_setImplementation(cls, m, imp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fixme optimize</span></span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">method_list_t</span> *newlist;</span><br><span class="line">        newlist = (<span class="keyword">method_list_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(*newlist), <span class="number">1</span>);</span><br><span class="line">        newlist-&gt;entsizeAndFlags = </span><br><span class="line">            (<span class="keyword">uint32_t</span>)<span class="keyword">sizeof</span>(<span class="keyword">method_t</span>) | fixed_up_method_list;</span><br><span class="line">        newlist-&gt;count = <span class="number">1</span>;</span><br><span class="line">        newlist-&gt;first.name = name;</span><br><span class="line">        newlist-&gt;first.types = strdupIfMutable(types);</span><br><span class="line">        newlist-&gt;first.imp = imp;</span><br><span class="line"></span><br><span class="line">        prepareMethodLists(cls, &amp;newlist, <span class="number">1</span>, NO, NO);</span><br><span class="line">        cls-&gt;data()-&gt;methods.attachLists(&amp;newlist, <span class="number">1</span>);</span><br><span class="line">        flushCaches(cls);</span><br><span class="line"></span><br><span class="line">        result = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释顺序：</p><p>1、加写入锁。</p><p>2、检查类型，检查类是否实现。</p><p>3、声明一个指针变量，指向 <code>method_t</code> 结构体，判断方法是否已经存在。</p><p>4、如果方法已经存在，判断是替换方法还是添加方法，如果不是替换，直接返回已经存在的方法的实现，如果是替换，则直接覆盖原方法。</p><p>5、如果方法不存在，则将其添加进入方法列表。</p><p>更具体的实现：<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime</a>，可以下载最新的 runtime 源码查看。</p><h2 id="四、从类中查找方法"><a href="#四、从类中查找方法" class="headerlink" title="四、从类中查找方法"></a>四、从类中查找方法</h2><p>当我们向对象发送消息的时候：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = [obj doSomeThingWithParams:params];</span><br></pre></td></tr></table></figure><p>编译器会将它编译成原型为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL cmd, ...);</span><br></pre></td></tr></table></figure><p>的 C 函数。所以上面的函数会被翻译成：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = objc_msgSend(obj, <span class="keyword">@selector</span>(doSomeThingWithParams:), params);</span><br></pre></td></tr></table></figure><p>这是一个标准的 C 函数，而且知道运行时的 iOS 开发者大部分都对它有所了解。我们来看一下，runtime 如何通过这个函数实现 <code>doSomeThingWithParams</code> 这个方法的调用。</p><p>当我们使用 <code>objc_msgSend()</code> 调用函数时，函数的调用栈为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 lookUpImpOrForward</span><br><span class="line">1 _class_lookupMethodAndLoadCache3</span><br><span class="line">2 objc_msgSend</span><br><span class="line">3 main</span><br><span class="line">4 start</span><br></pre></td></tr></table></figure><p>可以看到在调用了 <code>objc_msgSend</code> 之后，调用了 <code>class_lookupMethodAndLoadCache3</code> 这个函数，这个函数名的字面意思为：从类中查找方法并且加载缓存。这个函数的实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就调用了一个函数 <code>lookUpImpOrForward()</code>，这个函数名的字面意思是：查找 <code>imp</code> 或者转发，可以看出来，这个方法应该就是从方法列表中查找函数指针的那个方法了。它的实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* lookUpImpOrForward.</span></span><br><span class="line"><span class="comment">* The standard IMP lookup. </span></span><br><span class="line"><span class="comment">* initialize==NO tries to avoid +initialize (but sometimes fails)</span></span><br><span class="line"><span class="comment">* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)</span></span><br><span class="line"><span class="comment">* Most callers should use initialize==YES and cache==YES.</span></span><br><span class="line"><span class="comment">* inst is an instance of cls or a subclass thereof, or nil if none is known. </span></span><br><span class="line"><span class="comment">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span></span><br><span class="line"><span class="comment">* May return _objc_msgForward_impcache. IMPs destined for external use </span></span><br><span class="line"><span class="comment">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span></span><br><span class="line"><span class="comment">*   If you don't want forwarding at all, use lookUpImpOrNil() instead.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class curClass;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    Method meth;</span><br><span class="line">    <span class="keyword">bool</span> triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The lock is held to make method-lookup + cache-fill atomic </span></span><br><span class="line">    <span class="comment">// with respect to method addition. Otherwise, a category could </span></span><br><span class="line">    <span class="comment">// be added but ignored indefinitely because the cache was re-filled </span></span><br><span class="line">    <span class="comment">// with the old value after the cache flush on behalf of the category.</span></span><br><span class="line"> retry:</span><br><span class="line">    runtimeLock.read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try this class's cache.</span></span><br><span class="line"></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try this class's method lists.</span></span><br><span class="line"></span><br><span class="line">    meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">        imp = meth-&gt;imp;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try superclass caches and method lists.</span></span><br><span class="line"></span><br><span class="line">    curClass = cls;</span><br><span class="line">    <span class="keyword">while</span> ((curClass = curClass-&gt;superclass)) &#123;</span><br><span class="line">        <span class="comment">// Superclass cache.</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                <span class="comment">// resolver for this class first.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Superclass method list.</span></span><br><span class="line">        meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中给的注释很清楚，先从优化缓存中查找 <code>imp</code>，如果有直接返回，如果没有，先判断类是否实现，如果没有就去实现类，然后判断类是否初始化，如果没有就去初始化，再然后去类中的缓存列表中查找，找到就返回，如果没找到，再去父类的缓存和父类的方法列表中查找，找到就返回，如果还是没有，则允许一次 <code>resolve</code>，如果还是没有，则进入消息转发。</p><p>然后就可以使用返回的 <code>imp</code> 和汇编指令完成方法的调用了。对汇编精通的可以参考源码中的 <code>objc-msg</code> 模块查看汇编指令对 <code>imp</code> 的使用。</p><h4 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h4><p>runtime 是 objc 的核心动态库，基本涵盖了程序运行之后发生的一切，如果真正想学习它的编程思想的话，还请阅读源码，博客仅有参考和记录的意义，况且还有一些内容为一家之言，不可尽信。源码会告诉我们一切哦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写在前面的话&quot;&gt;&lt;a href=&quot;#写在前面的话&quot; class=&quot;headerlink&quot; title=&quot;写在前面的话&quot;&gt;&lt;/a&gt;写在前面的话&lt;/h2&gt;&lt;p&gt;本文不是对runtime的使用的简单的阐述，而是我对runtime中消息发送的一些更深层的理解。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="iOS 运行时" scheme="http://yoursite.com/tags/iOS-%E8%BF%90%E8%A1%8C%E6%97%B6/"/>
    
  </entry>
  
  <entry>
    <title>适配iPhoneX &amp; iOS11</title>
    <link href="http://yoursite.com/2018/01/02/%E9%80%82%E9%85%8DiPhoneX%20&amp;%20iOS11/"/>
    <id>http://yoursite.com/2018/01/02/适配iPhoneX &amp; iOS11/</id>
    <published>2018-01-02T10:33:55.000Z</published>
    <updated>2019-09-01T03:37:02.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Screen-Size"><a href="#一、Screen-Size" class="headerlink" title="一、Screen Size"></a>一、Screen Size</h2><p>iPhoneX 的屏幕尺寸为 375pt × 812pt @3x，像素为 1125px × 2436px。可以通过判断屏幕的高度来判断设备是否是 iPhoneX，可以在全局宏定义中添加判断设备的宏定义（横竖屏通用）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define IS_IPHONE_X     (( fabs((double)[[UIScreen mainScreen] bounds].size.height - (double)812) <span class="meta-string">&lt; DBL_EPSILON ) || (fabs((double)[[UIScreen mainScreen] bounds].size.width - (double)812) &lt; DBL_EPSILON ))</span></span></span><br></pre></td></tr></table></figure><p>如果在 iPhoneX模拟器运行现有 app，出现上下屏幕没填充满的情况时，说明 app 没有适合 iPhoneX 尺寸的启动图，因此，需要添加一张 1125px × 2436px（@3x）的启动图，或者在项目中添加 LaunchScreen.xib，然后在项目的 target 中，设置启动 Launch Screen File 为 LaunchScreen.xib。</p><h2 id="二、safe-Area"><a href="#二、safe-Area" class="headerlink" title="二、safe Area"></a>二、safe Area</h2><p>官方指出：</p><blockquote><p>When designing for iPhone X, you must ensure that layouts fill the screen and aren’t obscured by the device’s rounded corners, sensor housing, or the indicator for accessing the Home screen.</p></blockquote><p>当我们在设计 iPhoneX app 的时候，必须确保布局充满屏幕，并且布局不会被设备的圆角、传感器外壳或者用于访问主屏幕的指示灯遮挡住。因此，苹果提出了<code>safe area（安全区）</code>的概念，就是上述可能遮挡界面的区域以外的区域被定义为安全区。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b5085834364c7?w=120&amp;h=236&amp;f=png&amp;s=4062" alt="竖屏"><br><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b508586c91670?w=252&amp;h=120&amp;f=png&amp;s=3911" alt="横屏"></p><p>为了尽可能的使布局和手势等不被圆角和传感器遮挡，竖屏情况下，苹果官方建议的安全区大小为上图（竖屏），指定的状态栏高度为 44pt，下方指示灯处的高度为 34pt；横屏情况下为上图（横屏）所示，上下安全边距分别为 0pt/21pt，左右安全边距为 44pt/34pt，如果使用了<code>UINavigationBar</code>和<code>UITabBar</code>，安全区的上边缘会变成导航栏下边缘的位置，如果是自定义的<code>navigationBar</code>，并且还继承于<code>UIView</code>，就需要手动修改状态栏的高度，在我们的项目中，状态栏的高度是用的全局宏定义，因此，修改状态栏高度的宏定义为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define STATUS_HEIGHT   (IS_IPHONE_X?44:20)</span></span><br></pre></td></tr></table></figure><p>增加安全区域下面的区域的高度宏定义为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define BOTTOM_SAFEAREA_HEIGHT (IS_IPHONE_X? 34 : 0)</span></span><br></pre></td></tr></table></figure><p>如果你同时也用了自定义的<code>UITabBar</code>那么就需要修改<code>TABBAR_HEIGHT</code>的宏定义为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define TABBAR_HEIGHT   (IS_IPHONE_X? (49 + 34) : 49)</span></span><br></pre></td></tr></table></figure><p>当需要将整个界面最下方的控件上移或者改变中间滚动视图的高度的时候，使用<code>BOTTOM_SAFEAREA_HEIGHT</code>这个宏，方便后期的统一维护。因为基本上每一个界面都需要下方留白，因此在<code>BaseViewController</code>添加属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *areaBelowSafeArea;</span><br></pre></td></tr></table></figure><p>并且统一添加到<code>view</code>上：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#warning 背景色待定</span></span><br><span class="line"><span class="keyword">if</span> (IS_IPHONE_X) &#123;</span><br><span class="line">   <span class="keyword">self</span>.areaBelowSafeArea = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, SCREEN_HEIGHT - BOTTOM_SAFEAREA_HEIGHT, SCREEN_WIDTH, BOTTOM_SAFEAREA_HEIGHT)];</span><br><span class="line">   <span class="comment">// 尽量使用约束布局</span></span><br><span class="line">   <span class="keyword">self</span>.areaBelowSafeArea.backgroundColor = DefaultTabBarBackgroundColor;</span><br><span class="line">   [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.areaBelowSafeArea];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>也可以在特定的<code>viewController</code>中，自定义它的样式。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.areaBelowSafeArea.backgroundColor = XXX;</span><br></pre></td></tr></table></figure><p>更详细：<a href="https://developer.apple.com/videos/play/fall2017/801/" target="_blank" rel="noopener">Designing for iPhone X</a></p><h2 id="三、UIScrollView及其子类"><a href="#三、UIScrollView及其子类" class="headerlink" title="三、UIScrollView及其子类"></a>三、UIScrollView及其子类</h2><p>在 iOS11 中，决定滚动视图的内容和边缘距离的属性改为<code>adjustedContentInset</code>，而不是原来的<code>contentInsets</code>，在 iOS11 之前，<code>UIViewController</code>有一个<code>automaticallyAdjustsScrollViewInsets</code>属性，并且默认值为<code>YES</code>，这个属性的作用为，当<code>scrollView</code>为控制器根视图的最上层子视图时，如果这个控制器被嵌入到<code>UINavigationController</code>和<code>UITabBarController</code>中，那么，它的<code>contentInsets</code>会自动设置为<code>(64,0,49,0)</code>；这个属性会使滚动视图中的内容不被导航栏和<code>tabBar</code>遮挡。</p><p>iOS11 使用了<code>safeAreaInsets</code>的新属性，这个属性的作用就是规定了视图的安全区的四个边到屏幕的四个边的距离，例如在 iPhoneX 上，如果没使用或者隐藏了<code>UINavigationBar</code>，则<code>safeAreaInsets = (44,0,0,34)</code>，如果既使用了<code>UINavigationBar</code>，又使用了<code>UITabBar</code>，则<code>safeAreaInset = (88,0,0,34+49)</code>。也可以使用<code>additionalSafeAreaInsets</code>属性来为系统默认的<code>safeAreaInsets</code>添加 insets，比如，<code>safeAreaInsets = (44,0,0,34)</code>,设置<code>additionalSafeAreaInsets = UIEdgeInsetsMake(-44, 0, 0, 0);</code>，那么实际上的安全区域到屏幕边缘的insets为<code>(0,0,0,34)</code>。</p><p><code>adjustedContentInset</code>属性的值的确定由 iOS11 API 提供的新的枚举变量<code>contentInsetAdjustmentBehavior</code>决定。这个属性的类型定义为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">UIScrollViewContentInsetAdjustmentBehavior</span>) &#123;</span><br><span class="line">    <span class="built_in">UIScrollViewContentInsetAdjustmentAutomatic</span>, <span class="comment">// Similar to .scrollableAxes, but for backward compatibility will also adjust the top &amp; bottom contentInset when the scroll view is owned by a view controller with automaticallyAdjustsScrollViewInsets = YES inside a navigation controller, regardless of whether the scroll view is scrollable</span></span><br><span class="line">    <span class="built_in">UIScrollViewContentInsetAdjustmentScrollableAxes</span>, <span class="comment">// Edges for scrollable axes are adjusted (i.e., contentSize.width/height &gt; frame.size.width/height or alwaysBounceHorizontal/Vertical = YES)</span></span><br><span class="line">    <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>, <span class="comment">// contentInset is not adjusted</span></span><br><span class="line">    <span class="built_in">UIScrollViewContentInsetAdjustmentAlways</span>, <span class="comment">// contentInset is always adjusted by the scroll view's safeAreaInsets</span></span><br><span class="line">&#125; API_AVAILABLE(ios(<span class="number">11.0</span>),tvos(<span class="number">11.0</span>));</span><br></pre></td></tr></table></figure><p>四个枚举值的意义分别为：</p><p><code>UIScrollViewContentInsetAdjustmentAutomatic</code>：</p><blockquote><p>Content is always adjusted vertically when the scroll view is the content view of a view controller that is currently displayed by a navigation or tab bar controller. If the scroll view is horizontally scrollable, the horizontal content offset is also adjusted when there are nonzero safe area insets.</p></blockquote><p>当滚动视图的父视图所在的控制器嵌入导航控制器和标签控制器的时候，滚动视图的内容总会调整垂直方向上的 insets，如果滚动视图允许水平方向上可滚动，则当水平方向上的安全区 insets 不为 0 的时候，也会调整水平方向上的 insets。即：<code>adjustedContentInset = safeAreaInsets + contentInsets</code>，其中<code>contentInsets</code>为我们设置的滚动视图的<code>contentInsets</code>，下同。如下代码，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.scroll.contentInset = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">100</span>, <span class="number">0</span>, <span class="number">-34</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">    <span class="keyword">self</span>.scroll.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentAutomatic</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.automaticallyAdjustsScrollViewInsets = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加导航栏的情况下，在 iPhoneX 设备上运行打印的 log 为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-10</span><span class="number">-20</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">56.664048</span>+<span class="number">0800</span> TestIphoneX[<span class="number">81880</span>:<span class="number">2541000</span>] contentInset:&#123;<span class="number">100</span>, <span class="number">0</span>, <span class="number">-34</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-10</span><span class="number">-20</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">56.664916</span>+<span class="number">0800</span> TestIphoneX[<span class="number">81880</span>:<span class="number">2541000</span>] adjustedContentInset:&#123;<span class="number">188</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="number">2017</span><span class="number">-10</span><span class="number">-20</span> <span class="number">11</span>:<span class="number">48</span>:<span class="number">56.665220</span>+<span class="number">0800</span> TestIphoneX[<span class="number">81880</span>:<span class="number">2541000</span>] safeAreaInset:&#123;<span class="number">88</span>, <span class="number">0</span>, <span class="number">34</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><p><code>UIScrollViewContentInsetAdjustmentScrollableAxes</code>：</p><blockquote><p>The top and bottom insets include the safe area inset values when the vertical content size is greater than the height of the scroll view itself. The top and bottom insets are also adjusted when the alwaysBounceVertical property is YES. Similarly, the left and right insets include the safe area insets when the horizontal content size is greater than the width of the scroll view.</p></blockquote><p><code>adjustedContentInset = safeAreaInsets + contentInsets</code>，它的成立依赖于滚动轴，当垂直方向上的<code>contentSize</code>大于滚动视图的高度时，那么垂直方向上的 insets 就由<code>safeAreaInsets + contentInsets</code>决定，水平方向上同理。</p><p><code>UIScrollViewContentInsetAdjustmentNever</code>：</p><blockquote><p>Do not adjust the scroll view insets.</p></blockquote><p>顾名思义，<code>adjustedContentInset = contentInsets</code></p><p><code>UIScrollViewContentInsetAdjustmentAlways</code>：</p><blockquote><p>Always include the safe area insets in the content adjustment.</p></blockquote><p>顾名思义，<code>adjustedContentInset = safeAreaInsets + contentInsets</code></p><p>由于我们的 APP 没用系统的导航控制器，但是我们用了系统的标签控制器，所以在项目中会存在 iOS11 下滚动视图的位置不对的情况，那么就可能是因为它的<code>adjustedContentInset = safeAreaInsets + contentInsets</code>造成的，可以这样解决：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (@available(iOS <span class="number">11.0</span>, *)) &#123;</span><br><span class="line">    <span class="keyword">self</span>.scroll.contentInsetAdjustmentBehavior = <span class="built_in">UIScrollViewContentInsetAdjustmentNever</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.automaticallyAdjustsScrollViewInsets = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、UITableView-sectionHeader-和-sectionFooter高度问题"><a href="#四、UITableView-sectionHeader-和-sectionFooter高度问题" class="headerlink" title="四、UITableView sectionHeader 和 sectionFooter高度问题"></a>四、UITableView sectionHeader 和 sectionFooter高度问题</h2><p>iOS11 中 <code>UITableView</code>的 sectionHeader 和 sectionFooter 也启用了 <code>self-sizing</code>，即通过估算的高度乘以个数来确定<code>tableView</code>的<code>contenSize</code>的估算值，然后随着滚动展示 section 和 cell 的过程中更新它的<code>contenSize</code>，iOS11 之前只有 cell 是采用的这个机制，iOS11中 sectionHeader 和 sectionFooter 也采用了这个机制，并且，如果只实现了</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForHeaderInSection:(<span class="built_in">NSInteger</span>)section;</span><br></pre></td></tr></table></figure><p>没实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView viewForHeaderInSection:(<span class="built_in">NSInteger</span>)section;</span><br></pre></td></tr></table></figure><p>那么系统就会直接采用估算的高度，而不是<code>heightForHeaderInSection</code>方法中设置的高度，也就是此时的<code>sectionHeight</code>为</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView estimatedHeightForHeaderInSection:(<span class="built_in">NSInteger</span>)section</span><br></pre></td></tr></table></figure><p>方法，或者<code>estimatedSectionHeaderHeight</code>设置的估算高度，如果没有设置估算高度，则系统默认为<code>UITableViewAutomaticDimension</code>。</p><p>所以必须同时实现<code>heightForHeaderInSection</code>和<code>viewForHeaderInSection</code>方法，可以返回<code>[UIView new]</code>，但是不能不实现。或者只实现<code>heightForHeaderInSection</code>方法，并且设置<code>estimatedSectionHeaderHeight</code>为 0 来关闭估算机制。</p><p>注：如果在 iOS11 中，使用了 self-sizing cell，并且使用了上拉加载更多，并且使用了高度自适应的方式计算 cell 的高度，那么上拉加载更多的时候会发现 tableView 会跳动一下或者滚动一段距离，什么原因呢，这里解释一下可能是由于：假如一个列表有10个 cell，你设置的估算高度是 80，那么整个列表的估算高度为<code>10 * 80 = 800</code>，但是实际高度不是 800，假如是 1000，那么当滚动到最下方的时候，此时的<code>contentOffSet = 1000</code>，然后上拉再加载 10条数据，此时会调用<code>- (void)reloadData;</code>方法，此时，列表的高度仍然会重新使用估算高度计算，<code>80 * 20 = 1600</code>，而<code>contentOffSet = 1000</code>，这个位置已经不是刚才的第 10条数据了，而是第<code>1000 / 80= 12.5</code>条数据了，因此会造成加载更多的时候数据衔接不上的问题。你可能需要设置<code>estimatedRowHeight = 0</code>来关闭它的估算高度解决这个问题，但是如果你非要开启它的估算高度来使 cell 中的约束自适应高度的话，可以通过这种方式计算高度：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> DisplayCell *cell;<span class="comment">//‘static’将cell存储在静态存储区，这里创建的cell仅用来计算高度，因此，内存中只有一份就可以了，因为此方法会调用多次，每次都创建的话即会耗费时间也会耗费空间。</span></span><br><span class="line">    <span class="keyword">if</span> (!cell) &#123;</span><br><span class="line">        cell = [[[<span class="built_in">NSBundle</span> mainBundle] loadNibNamed:kCellNibName owner:<span class="keyword">self</span> options:<span class="literal">nil</span>] lastObject];</span><br><span class="line">    &#125;</span><br><span class="line">    cell.displayLab.text = <span class="keyword">self</span>.data[indexPath.row];<span class="comment">//给cell赋值，赋值是为了通过内容计算高度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> height = [cell systemLayoutSizeFittingSize:<span class="built_in">UILayoutFittingCompressedSize</span>].height;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，如果 cell 中使用了多行 label 的话，注意设置它的换行宽度：<br><code>self.displayLab.preferredMaxLayoutWidth = XXX;//XXX应该和你约束的label宽度相同</code></p><h2 id="五、Tips"><a href="#五、Tips" class="headerlink" title="五、Tips"></a>五、Tips</h2><h3 id="1、每个界面中的控件的位置"><a href="#1、每个界面中的控件的位置" class="headerlink" title="1、每个界面中的控件的位置"></a>1、每个界面中的控件的位置</h3><p>如果项目中用 frame 布局的控件较多，很多控件的位置依赖于<code>self.view</code>的顶部和底部，由于状态栏和底部空间的调整就会造成一部分控件的位置发生变化，修改过程中应该注意和线上 APP 比对。建议能用约束的就别用 frame，依赖上下控件的位置比依赖屏幕的边缘和宽高更好维护一些。autolayout 并不影响写动画！</p><h3 id="2、重新布局"><a href="#2、重新布局" class="headerlink" title="2、重新布局"></a>2、重新布局</h3><p>项目中有些控件的位置会因为响应事件、动画和数据请求等重新布局，因此应该特别注意的地方就是重新布局后控件的位置是否和线上项目一致。另外，还有一些初始化时隐藏的控件，由于某些条件发生后才展示，也要注意其布局。</p><h3 id="3、全屏显示"><a href="#3、全屏显示" class="headerlink" title="3、全屏显示"></a>3、全屏显示</h3><p>全屏显示和横屏模式下的界面，注意横屏之后下方的感应器在安全区之外。</p><h3 id="4、LaunchuImage"><a href="#4、LaunchuImage" class="headerlink" title="4、LaunchuImage"></a>4、LaunchuImage</h3><p>像素为：1125 * 2436<br>并在LaunchImage中的Contents.json文件中增加 JSON：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"extent"</span> : <span class="string">"full-screen"</span>,</span><br><span class="line">    <span class="attr">"idiom"</span> : <span class="string">"iphone"</span>,</span><br><span class="line">    <span class="attr">"subtype"</span> : <span class="string">"2436h"</span>,</span><br><span class="line">    <span class="attr">"filename"</span> : <span class="string">"图片名字.png"</span>,</span><br><span class="line">    <span class="attr">"minimum-system-version"</span> : <span class="string">"11.0"</span>,</span><br><span class="line">    <span class="attr">"orientation"</span> : <span class="string">"portrait"</span>,</span><br><span class="line">    <span class="attr">"scale"</span> : <span class="string">"3x"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、定位"><a href="#5、定位" class="headerlink" title="5、定位"></a>5、定位</h3><p>在 iOS 11 中必须支持 When In Use 授权模式（NSLocationWhenInUseUsageDescription），在 iOS 11 中，为了避免开发者只提供请求 Always 授权模式这种情况，加入此限制，如果不提供When In Use 授权模式，那么 Always 相关授权模式也无法正常使用。（就是为了打倒流氓软件的流氓强制定位）</p><p>如果要支持老版本，即 iOS 11 以下系统版本，那么建议在 info.plist 中配置所有的 Key（即使 NSLocationAlwaysUsageDescription 在 iOS 11及以上版本不再使用）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLocationWhenInUseUsageDescription</span></span><br><span class="line"><span class="built_in">NSLocationAlwaysAndWhenInUseUsageDescription</span></span><br><span class="line"><span class="built_in">NSLocationAlwaysUsageDescription</span></span><br></pre></td></tr></table></figure><p><code>NSLocationAlwaysAndWhenInUseUsageDescription</code>为 iOS 11 中新引入的一个 Key。<br>参考：<a href="https://developer.apple.com/videos/play/wwdc2017/713/" target="_blank" rel="noopener">WWDC17: What’s New in Location Technologies ?</a><br><strong>(这是一个带简体中文字幕的视频，我并没有看！！！)</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、Screen-Size&quot;&gt;&lt;a href=&quot;#一、Screen-Size&quot; class=&quot;headerlink&quot; title=&quot;一、Screen Size&quot;&gt;&lt;/a&gt;一、Screen Size&lt;/h2&gt;&lt;p&gt;iPhoneX 的屏幕尺寸为 375pt × 812
      
    
    </summary>
    
    
      <category term="iOS 新特性" scheme="http://yoursite.com/tags/iOS-%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>ARC内存管理以及循环引用</title>
    <link href="http://yoursite.com/2018/01/02/ARC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/02/ARC内存管理以及循环引用/</id>
    <published>2018-01-02T08:25:52.000Z</published>
    <updated>2019-09-01T03:37:02.775Z</updated>
    
    <content type="html"><![CDATA[<p>ARC:”Automatic Reference Counting”，自动引用计数。Swift语言延续了OC的做法，也是利用ARC机制进行内存管理，和OC的ARC一样，当一些类的实例不在需要的时候，ARC会释放它们的内存。但是，在少数情况下，ARC需要知道你的代码之间的关系才能更好的为你管理内存，和OC一样，Swift中的ARC也存在循环引用导致内存泄露的情况。    </p><h2 id="一、ARC的工作机制"><a href="#一、ARC的工作机制" class="headerlink" title="一、ARC的工作机制"></a>一、ARC的工作机制</h2><p>每当我们创建一个类的新的实例的时候，ARC会从堆中分配一块内存用来存储有关该实例的信息。这块内存将持有这个实例的类型信息以及和它关联的属性的值。另外，当这个实例不再被需要的时候，ARC将回收这个实例所占有的内存并且将这部分内存给其他需要的实例用。这样就能保证不再被需要的实例不占用多余的内存。<br>但是，如果ARC释放了正在使用的实例，那么该实例的属性将不能被访问，方法将不能被调用，如果你访问它的属性或者调用它的方法时，应用会崩溃，因为你访问了一个野指针。<br>为了解决上述问题，ARC会跟踪每个类的实例正在被多少个属性、常量或者变量引用，每当你将类实例赋值给属性，常量或者变量的时候它就会被”强”引用一次，当它的引用计数为0时，表明它不再被需要，ARC就会销毁它。<br>下面举个例子介绍ARC是如何工作的<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being initialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码创建了一个名为<code>Person</code>的类，该类声明了一个非可选的类型的<code>name</code>常量，一个给<code>name</code>赋值的初始化方法，并且打印了一句话，用来标注初始化成功，同时声明了一个析构函数，打印了一句标志此实例被销毁的信息。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reference1: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference2: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> reference3: <span class="type">Person</span>?</span><br></pre></td></tr></table></figure></p><p>上述代码声明了三个<code>Person?</code>类型的变量，这三个变量为可选类型，所以被自动初始化为<code>nil</code>，此时三个实例都没有指向任何一个<code>Person</code>类的实例。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line"><span class="comment">// Prints "John Appleseed is being initialized"</span></span><br></pre></td></tr></table></figure></p><p>现在创建一个<code>Person</code>类的实例，并且赋值给<code>reference1</code>，此时控制台会打印<code>&quot;John Appleseed is being initialized&quot;</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference2 = reference1</span><br><span class="line">reference3 = reference1</span><br></pre></td></tr></table></figure></p><p>然后将该实例赋值给<code>reference2</code>和<code>reference3</code>。现在该实例被三个”强”类型的指针引用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference1 = <span class="literal">nil</span></span><br><span class="line">reference2 = <span class="literal">nil</span></span><br></pre></td></tr></table></figure></p><p>如上所示，当我们将其中两个引用赋值给<code>nil</code>的时候，这两个”强”引用被打破，但是这个<code>Person</code>的实例并没有被释放（释放信息未打印），因为还存在一个对这个实例的强引用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference3 = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints "John Appleseed is being deinitialized"</span></span><br></pre></td></tr></table></figure></p><p>当我们将第三个”强”引用打破的时候（赋值为<code>nil</code>），可以看到控制台打印的<code>&quot;John Appleseed is being deinitialized&quot;</code>析构信息。</p><h2 id="二、两个类实例之间的循环引用"><a href="#二、两个类实例之间的循环引用" class="headerlink" title="二、两个类实例之间的循环引用"></a>二、两个类实例之间的循环引用</h2><p>上述的例子中，ARC可以很好的获取一个实例的引用计数，并且当它的引用计数为0的时候释放它。但是在实际的开发过程中，会存在一些特殊情况，使ARC没办法得到引用计数为0这个关键点，就会造成这个实例的内存一直不被释放，两个类的实例相互”强”引用就会造成这种情况，就是”循环引用”。<br>苹果官方提供了两种方法来解决两个实例之间的循环引用，<code>unowned</code>引用和<code>weak</code>引用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(unit: <span class="type">String</span>) &#123; <span class="keyword">self</span>.unit = unit &#125;</span><br><span class="line">    <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Apartment <span class="subst">\(unit)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子，定义了一个<code>Person</code>类和一个<code>Apartment</code>类。每一个<code>Person</code>的实例都有一个<code>name</code>的属性和一个<code>apartment</code>的可选属性，初始化为<code>nil</code>，因为并不是每一个人都拥有一个公寓，所以是可选属性。同样的，每一个<code>Apartment</code>实例都有一个<code>unit</code>属性和一个<code>tenant</code>的可选属性，初始化为<code>nil</code>，同理，不是每一个公寓都有人租。同时，两个类都定义了<code>deinit</code>方法，并且打印一段信息，用来让我们清楚这个实例何时被销毁。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br></pre></td></tr></table></figure></p><p>分别定义一个<code>Person</code>类型和<code>Apartment</code>的变量，定义为<code>optional</code>（可选类型），初始化为<code>nil</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">unit4A = <span class="type">Apartment</span>(unit: <span class="string">"4A"</span>)</span><br></pre></td></tr></table></figure></p><p>然后分别创建一个<code>Person</code>类的实例和<code>Apartment</code>类的实例，并且分别赋值给上面的定义的变量。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b4e8fb4d8b351?w=1240&amp;h=373&amp;f=png&amp;s=13249" alt=""><br>上图为此时变量和实例之间的强引用关系。<br>然后<code>john</code>将拥有一座公寓<code>unit4A</code>，公寓<code>unit4A</code>将被<code>john</code>承租。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john!.apartment = unit4A</span><br><span class="line">unit4A!.tenant = john</span><br></pre></td></tr></table></figure></p><p>因为可以确定两个变量都被赋值为相应类型的实例，所以此处用<code>!</code>对可选属性强解包。<br>此时，两个变量和实例以及两个实例之间的”强”引用关系如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b4e8fb5f4f8e6?w=1240&amp;h=396&amp;f=png&amp;s=17746" alt=""><br>从图中可以看到两个实例互相”强”引用，也就是说这两个实例的引用计数永远不会为0，ARC也不会释放这两个实例的内存。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line">unit4A = <span class="literal">nil</span></span><br></pre></td></tr></table></figure></p><p>当我们将两个变量设置为<code>nil</code>，切断他们与实例之间的”强”引用关系，此时两个实例之间的”强”引用关系为：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b4e8fb5d5a579?w=1240&amp;h=396&amp;f=png&amp;s=16319" alt=""><br>从图中可以看出，这两个实例的引用计数仍然不为0，它们占用的内存还是得不到释放，因此就会造成内存泄露。</p><h2 id="三、解决两个类实例之间的循环引用"><a href="#三、解决两个类实例之间的循环引用" class="headerlink" title="三、解决两个类实例之间的循环引用"></a>三、解决两个类实例之间的循环引用</h2><p>Swift提供了两种办法解决类实例之间的循环引用。<code>weak</code>引用和<code>unowned</code>引用。这两种方法都可以使一个实例引用另一个实例的时候，不用保持”强”引用。<code>weak</code>一般应用于其中一个实例具有更短的生命周期，或者可以随时设置为<code>nil</code>的情况下；<code>unowned</code>用于两个实例具有差不多长的生命周期，或者说两个实例都不能被设置为<code>nil</code>。</p><h3 id="1-weak引用"><a href="#1-weak引用" class="headerlink" title="(1) weak引用"></a>(1) weak引用</h3><p><code>weak</code>引用对所引用的实例不会保持”强”引用的关系。假如一个实例同时被若干个”强引用”和一个<code>weak</code>引用引用时，当所有其他的”强”引用都被打破时该实例就会被ARC释放，并且ARC会自动将这个<code>weak</code>引用置为<code>nil</code>。因此，<code>weak</code>引用一般被声明为<code>var</code>，因为它会被ARC设置为<code>nil</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123; <span class="keyword">self</span>.name = name &#125;</span><br><span class="line">    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apartment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> unit: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(unit: <span class="type">String</span>) &#123; <span class="keyword">self</span>.unit = unit &#125;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> tenant: <span class="type">Person</span>?</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Apartment <span class="subst">\(unit)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们将<code>Apartment</code>类中的<code>tenant</code>变量声明为<code>weak</code>引用（在<code>var</code>关键字前加<code>weak</code>关键字），表明某公寓的承租人并不一定一直都是同一个人。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Person</span>?</span><br><span class="line"><span class="keyword">var</span> unit4A: <span class="type">Apartment</span>?</span><br><span class="line"> </span><br><span class="line">john = <span class="type">Person</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">unit4A = <span class="type">Apartment</span>(unit: <span class="string">"4A"</span>)</span><br><span class="line"> </span><br><span class="line">john!.apartment = unit4A</span><br><span class="line">unit4A!.tenant = john</span><br></pre></td></tr></table></figure></p><p>然后和上文一样，将两个变量和实例关联。此时，它们之间的引用关系如下图。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b4e8fb5e115f7?w=1240&amp;h=391&amp;f=png&amp;s=18061" alt=""><br><code>Person</code>实例仍然”强”引用<code>Apartment</code>实例，但是<code>Apartment</code>实例’weak’引用<code>Person</code>实例。<code>john</code>和<code>unit4A</code>两个变量仍然”强”引用两个实例。当我们把<code>john</code>变量对<code>Person</code>实例的”强”引用打破的时候，即将<code>john</code>设置为<code>nil</code>，就没有其他的”强”引用引用<code>Person</code>实例，此时，<code>Person</code>实例被ARC释放，同时<code>Apartment</code>实例的<code>tenant</code>变量被设置为<code>nil</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints "John Appleseed is being deinitialized"</span></span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b4e8fb66e2c4a?w=1240&amp;h=373&amp;f=png&amp;s=12990" alt=""><br>然后将变量<code>unit4A</code>设为<code>nil</code>，可以看到<code>Apartment</code>实例也被销毁。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unit4A = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints "Apartment 4A is being deinitialized"</span></span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b4e8fb6247120?w=1240&amp;h=373&amp;f=png&amp;s=10562" alt=""></p><h3 id="2-unowned引用"><a href="#2-unowned引用" class="headerlink" title="(2) unowned引用"></a>(2) unowned引用</h3><p>和<code>weak</code>引用一样，<code>unowned</code>引用也不会保持它和它所引用实例之间的”强”引用关系，而是保持一种非拥有（或未知）的关系，使用的时候也是用<code>unowned</code>关键字修饰声明的变量。不同的是，两个互相引用的对象具有差不多长的生命周期，而不是其中一个可以提前被释放（<code>weak</code>），有点患难与共的意思。<br>Swift要求<code>unowned</code>修饰的变量必须一直指向一个实例，而不是有些时候为<code>nil</code>，因此，ARC也不会将这个变量设置为<code>nil</code>，所以我们一般将这个引用声明为非可选类型。PS：请确保你声明的变量一直指向一个实例，如果这个实例被释放了，而<code>unowned</code>变量还在引用它的话，你会得到一个运行时错误，因为，这个变量是非可选类型的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> card: <span class="type">CreditCard</span>?</span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> number: <span class="type">UInt64</span></span><br><span class="line">    <span class="keyword">unowned</span> <span class="keyword">let</span> customer: <span class="type">Customer</span></span><br><span class="line">    <span class="keyword">init</span>(number: <span class="type">UInt64</span>, customer: <span class="type">Customer</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number = number</span><br><span class="line">        <span class="keyword">self</span>.customer = customer</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"Card #<span class="subst">\(number)</span> is being deinitialized"</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面这个例子定义了两个类：<code>Customer</code>和<code>CreditCard</code>，每个顾客都可能会有一张信用卡（可选类型），每个信用卡都一定会有一个持有他们的顾客（非可选类型，卡片为顾客定制）。因此，<code>Customer</code>类有一个<code>CreditCard?</code>类型的属性，<code>CreditCard</code>类也有一个<code>Customer</code>类型的属性，并且被声明为<code>unowned</code>，以此来打破循环引用。每张信用卡初始化的时候都需要一名持有它的顾客，因为信用卡本身就是为顾客定制的。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> john: <span class="type">Customer</span>?</span><br></pre></td></tr></table></figure></p><p>然后声明一个<code>Customer?</code>类型的变量<code>john</code>，初始化为<code>nil</code>。接着创建一个<code>Customer</code>的实例，并且将它赋值给<code>john</code>（让<code>john</code>引用它、指向它都是一个意思）。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="type">Customer</span>(name: <span class="string">"John Appleseed"</span>)</span><br><span class="line">john!.card = <span class="type">CreditCard</span>(number: <span class="number">1234_5678_9012_3456</span>, customer: john!)</span><br></pre></td></tr></table></figure></p><p>（第一句代码赋值之后，我们知道<code>john</code>肯定不是<code>nil</code>，所以用<code>!</code>解包不会有问题）<br>然后，两个实例之间的引用关系为：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b4e8fdb0430e7?w=1240&amp;h=391&amp;f=png&amp;s=17512" alt=""><br><code>Customer</code>实例”强”引用<code>CreditCard</code>实例，<code>CreditCard</code>实例’unowned’引用<code>Customer</code>实例，接着，我们将<code>john</code>对<code>Customer</code>实例的”强”引用打破，即将<code>john</code>设置为<code>nil</code>。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">john = <span class="literal">nil</span></span><br><span class="line"><span class="comment">// Prints "John Appleseed is being deinitialized"</span></span><br><span class="line"><span class="comment">// Prints "Card #1234567890123456 is being deinitialized"</span></span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b4e8fdc54bb51?w=1240&amp;h=391&amp;f=png&amp;s=17585" alt=""><br>可以看到<code>Customer</code>实例和<code>CreditCard</code>实例都被销毁了。<code>john</code>被设置为<code>nil</code>之后，就没有”强”引用引用<code>Customer</code>实例，所以，<code>Customer</code>实例被释放，也就没有”强”引用引用<code>CreditCard</code>实例，因此<code>CreditCard</code>实例也被释放。<br><strong>以上例子证明，两种方式都可以解决循环引用的问题，但是要注意它们使用的范围。<code>weak</code>修饰的变量可以被设置为<code>nil</code>（引用的实例的生命周期短于另一个实例），<code>unowned</code>修饰的变量必须要指向一个实例（造成循环引用的两实例的生命周期差不多长，不会出现一方被提前释放的情况），一旦它被释放了，就千万别再使用了。</strong></p><h2 id="四、闭包引起的循环引用"><a href="#四、闭包引起的循环引用" class="headerlink" title="四、闭包引起的循环引用"></a>四、闭包引起的循环引用</h2><p>Swift中的闭包是一种独立的函数代码块，它可以像一个类的实例一样在代码中赋值、调用和传递，也可以被认为某个匿名函数的实例，其实就是OC中的<em>block</em>。它和类一样也是引用类型的，所以它的函数体中使用的引用都是”强”引用。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HTMLElement</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> text: <span class="type">String</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> asHTML: () -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(name: <span class="type">String</span>, text: <span class="type">String</span>? = <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">        <span class="keyword">self</span>.text = text</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"<span class="subst">\(name)</span> is being deinitialized"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述例子中，闭包被赋值给<code>asHTML</code>变量，所以闭包被<code>HTMLElement</code>实例”强”引用，而闭包又捕获（关于闭包捕获变量，参考官方文档<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html#//apple_ref/doc/uid/TP40014097-CH11-ID103" target="_blank" rel="noopener">Capturing Values</a>）了<code>HTMLElement</code>的实例中的<code>text</code>和<code>name</code>属性，因此它又”强”引用<code>HTMLElement</code>实例，这样就造成了循环引用，因为<code>text</code>属性可能为空，所以定义为可选属性。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paragraph: <span class="type">HTMLElement</span>? = <span class="type">HTMLElement</span>(name: <span class="string">"p"</span>, text: <span class="string">"hello, world"</span>)</span><br><span class="line"><span class="built_in">print</span>(paragraph!.asHTML())</span><br><span class="line"><span class="comment">// Prints "&lt;p&gt;hello, world&lt;/p&gt;"</span></span><br></pre></td></tr></table></figure></p><p>我们创建一个<code>HTMLElement</code>实例，并将它赋值给<code>paragraph</code>变量，然后访问它的<code>asHTML</code>属性。此时的内存示例为下图，可以看到<code>HTMLElement</code>实例和闭包之间的循环引用。<br><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b4e8fdd973a51?w=1240&amp;h=432&amp;f=png&amp;s=14517" alt=""><br>当我们将<code>paragraph</code> 设置为<code>nil</code>时，控制台并没有打印任何销毁信息，因为循环引用。<br><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b4e8fdf266510?w=1240&amp;h=844&amp;f=png&amp;s=115887" alt=""><br>上图为使用<strong>Instruments</strong>分析得到的循环引用以及造成的内存泄漏。</p><h2 id="五、使用unowned和weak解决循环引用"><a href="#五、使用unowned和weak解决循环引用" class="headerlink" title="五、使用unowned和weak解决循环引用"></a>五、使用unowned和weak解决循环引用</h2><p>通过上文（三）的分析，我们知道<code>unowned</code>引用对实例的非拥有关系，因此，我们可以通过如下方式解决循环引用：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> asHTML: () -&gt; <span class="type">String</span> = &#123;</span><br><span class="line">        [<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> text = <span class="keyword">self</span>.text &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;<span class="subst">\(text)</span>&lt;/<span class="subst">\(<span class="keyword">self</span>.name)</span>&gt;"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(<span class="keyword">self</span>.name)</span> /&gt;"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>[unowned self] in</code>，这段代码，代表闭包中的<code>self</code>指针都被<code>unowned</code>修饰。这样就可以使闭包对实例的”强”引用变成’unowned’引用，从而打破循环引用。<br>当HTML的element为标题的时候，此时如果<code>text</code>属性为空，我们想返回一个默认的text作为标题，而不是只有<code>&lt;h/&gt;</code>这种标签。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> heading = <span class="type">HTMLElement</span>(name: <span class="string">"h1"</span>)</span><br><span class="line"><span class="keyword">let</span> defaultText = <span class="string">"some default text"</span></span><br><span class="line">heading.asHTML = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(heading.name)</span>&gt;<span class="subst">\(heading.text ?? defaultText)</span>&lt;/<span class="subst">\(heading.name)</span>&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(heading.asHTML())</span><br><span class="line"><span class="comment">// Prints "&lt;h1&gt;some default text&lt;/h1&gt;"</span></span><br></pre></td></tr></table></figure></p><p>这段代码也会造成<code>HTMLElement</code>对其自身的循环引用。我们仍然可以使用<code>unowned</code>关键字打破循环引用：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">heading.asHTML = &#123;</span><br><span class="line">    [<span class="keyword">unowned</span> heading] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(heading.name)</span>&gt;<span class="subst">\(heading.text ?? defaultText)</span>&lt;/<span class="subst">\(heading.name)</span>&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints "&lt;h1&gt;some default text&lt;/h1&gt;"</span></span><br><span class="line"><span class="comment">// Prints "h1 is being deinitialized"</span></span><br></pre></td></tr></table></figure></p><p><code>unowned</code>会使闭包中对<code>heading</code>的”强”都改为’unowned’引用。<br>或者，可以使用<code>weak</code>属性打破循环引用：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">weak</span> <span class="keyword">var</span> weakHeading = heading</span><br><span class="line">heading.asHTML = &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;<span class="subst">\(weakHeading!.name)</span>&gt;<span class="subst">\(weakHeading!.text ?? defaultText)</span>&lt;/<span class="subst">\(weakHeading!.name)</span>&gt;"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Prints "&lt;h1&gt;some default text&lt;/h1&gt;"</span></span><br><span class="line"><span class="comment">//Prints "h1 is being deinitialized"</span></span><br></pre></td></tr></table></figure></p><p>上文（三）中可知，<code>weak</code>修饰的变量为可选类型，而且，我们对变量进行了一次赋值，就可以确保<code>weakHeading</code>指向<code>heading</code>引用的实例，所以可以放心的使用<code>!</code>对它解包。<br>上面这段代码同样可以使闭包对<code>HTMLElement</code>实例的”强”引用变为<code>weak</code>引用，从而打破循环引用。<br>（ARC会自动回收不被使用的对象，所以不用手动将变量设置为<code>nil</code>）</p><p>本文参考<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/AutomaticReferenceCounting.html#//apple_ref/doc/uid/TP40014097-CH20-ID48" target="_blank" rel="noopener">Automatic Reference Counting</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ARC:”Automatic Reference Counting”，自动引用计数。Swift语言延续了OC的做法，也是利用ARC机制进行内存管理，和OC的ARC一样，当一些类的实例不在需要的时候，ARC会释放它们的内存。但是，在少数情况下，ARC需要知道你的代码之间的关系
      
    
    </summary>
    
    
      <category term="iOS 内存管理" scheme="http://yoursite.com/tags/iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>值类型和引用类型在Swift中的使用</title>
    <link href="http://yoursite.com/2018/01/02/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8Swift%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/01/02/值类型和引用类型在Swift中的使用/</id>
    <published>2018-01-02T06:22:50.000Z</published>
    <updated>2019-09-01T03:37:02.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-值类型-vs-引用类型"><a href="#前言-值类型-vs-引用类型" class="headerlink" title="前言 值类型 vs 引用类型"></a>前言 值类型 vs 引用类型</h2><h3 id="1、什么是值类型"><a href="#1、什么是值类型" class="headerlink" title="1、什么是值类型"></a>1、什么是值类型</h3><p>值类型就是值直接保存在变量中。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>值类型赋新值的时候会直接覆盖旧值。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b5665a4d091ad?w=320&amp;h=94&amp;f=png&amp;s=614" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">int</span> b = a;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">b = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>按注释：</p><p>1.这段代码首先声明了一个<code>int</code>类型的变量<code>b</code>，然后将<code>a</code>中保存的值赋值给<code>b</code>。</p><p>2.给<code>b</code>赋新值，不会影响<code>a</code>中保存的值。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b5665a518e28c?w=527&amp;h=94&amp;f=png&amp;s=858" alt=""></p><h3 id="2、什么是引用类型"><a href="#2、什么是引用类型" class="headerlink" title="2、什么是引用类型"></a>2、什么是引用类型</h3><p>引用类型，变量中保存的是地址，地址指向实际的对象。例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *foo = <span class="string">@"hello"</span>;</span><br><span class="line"><span class="comment">// NSString *foo = [[NSString alloc] initWithString:@"hello"];</span></span><br><span class="line">foo = <span class="string">@"world"</span>;</span><br><span class="line"><span class="comment">// foo = [[NSString alloc] initWithString:@"world"];</span></span><br></pre></td></tr></table></figure><p>引用类型变量重新赋值的时候会改变变量中保存的地址，新的地址会覆盖旧的地址，并且新的地址指向（引用）新创建的对象。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b5665a613c620?w=423&amp;h=294&amp;f=png&amp;s=15000" alt=""></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *foo = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"helllo, "</span>];</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *bar = foo;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">[bar appendString:<span class="string">@"OC"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, foo);</span><br><span class="line"><span class="comment">// print "helllo, OC"</span></span><br></pre></td></tr></table></figure><p>1、声明了一个新的变量<code>bar</code>，<code>bar</code>中保存的地址等于<code>foo</code>中保存的地址，因此它们指向同一个对象。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b5665a4667f6a?w=345&amp;h=203&amp;f=png&amp;s=9695" alt=""></p><p>2、当修改<code>bar</code>指向的对象时，<code>foo</code>指向的对象也被修改，因为它们俩引用的是同一个对象。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b5665a4eee036?w=375&amp;h=203&amp;f=png&amp;s=10760" alt=""></p><h2 id="一、Swift中的值类型和引用类型"><a href="#一、Swift中的值类型和引用类型" class="headerlink" title="一、Swift中的值类型和引用类型"></a>一、Swift中的值类型和引用类型</h2><p>相对于OC，Swift 的优点主要有安全、快速、简洁。Swift的安全性主要体现在，它会在编译时就确定要调用的方法和属性（静态优化），而不是像OC一样到运行时才确定调用哪个方法。Swift会在编译时就告诉你，你的代码是否有bug（比如访问了野指针，数组越界等），而OC会在运行时才发现这些错误并造成APP的crash。</p><p>类似于OC中的类，Swift中的类都是引用类型，结构体、枚举、元组都是值类型。</p><p>值类型的特点就是拷贝，假如我们创建了一个值类型的实例，当它作为参数传递给函数或者赋值给常量或变量时，这个实例就会生成一份它自身的拷贝（unique copy），当对这个实例进行赋值、参数传递等操作时，实际上被赋值或者传递的是拷贝的那一份，无论怎么修改都不会改变该实例本身。而引用类型的实例进行赋值、参数传递等操作时，实际上传递的就是它本身，我们在函数中修改的就是它自身。类似于 C 函数中的值传递和引用传递。</p><h3 id="1、引用类型"><a href="#1、引用类型" class="headerlink" title="1、引用类型"></a>1、引用类型</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reference type example</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123; </span><br><span class="line"><span class="keyword">var</span> data: <span class="type">Int</span> = -<span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x = <span class="type">C</span>()</span><br><span class="line"><span class="keyword">let</span> y = x    <span class="comment">// x is copied to y</span></span><br><span class="line">x.data = <span class="number">42</span><span class="comment">// changes the instance referred to by x (and y)</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(x.data)</span>, <span class="subst">\(y.data)</span>"</span>)<span class="comment">// prints "42, 42"</span></span><br></pre></td></tr></table></figure><p>上述代码的内存如下图所示，变量<code>x</code>和<code>y</code>指向同一个类<code>C</code>的实例。<br><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b564a2543e978?w=384&amp;h=140&amp;f=png&amp;s=6615" alt=""></p><h3 id="2、值类型"><a href="#2、值类型" class="headerlink" title="2、值类型"></a>2、值类型</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value type example</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> </span>&#123; </span><br><span class="line"><span class="keyword">var</span> data: <span class="type">Int</span> = -<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="type">S</span>()</span><br><span class="line"><span class="keyword">var</span> b = a<span class="comment">// a is copied to b</span></span><br><span class="line">a.data = <span class="number">42</span><span class="comment">// Changes a, not b</span></span><br><span class="line"><span class="built_in">println</span>(<span class="string">"<span class="subst">\(a.data)</span>, <span class="subst">\(b.data)</span>"</span>)<span class="comment">// prints "42, -1"</span></span><br></pre></td></tr></table></figure><p>内存如下图所示，对实例进行赋值操作时，<code>b = a</code>，会将<code>a</code>的拷贝赋值给<code>b</code>，而不是<code>a</code>本身，因此，<code>a</code>和<code>b</code>保存了两个不同的实例，对其中一个的修改不会影响另一个（下图箭头并不是指针的意思，为了表示清楚一点用了箭头）。</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b564a1f79f5b2?w=391&amp;h=155&amp;f=png&amp;s=8231" alt=""></p><p>值类型拷贝操作的时间复杂度为基于被拷贝数据量大小的O(n)。当值类型的实例传递到函数中时，实际上是声明了一个局部变量，它的作用域仅仅是函数的内部，所以当出了函数时，这份拷贝的实例就会被释放，因此不用担心它的空间复杂度或者拷贝浪费内存的问题。</p><h3 id="3、可变性"><a href="#3、可变性" class="headerlink" title="3、可变性"></a>3、可变性</h3><p>对于值类型和引用类型，关键字<code>var</code>和<code>let</code>是有区别的。对于引用类型来说，<code>let</code>的意思是，<em>引用</em>必须是常量，换句话你说，你不能修改常量指向其他实例，即不能修改常量中保存的地址，但是你可以修改实例本身。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="type">C</span>()</span><br><span class="line"><span class="keyword">let</span> m = <span class="type">C</span>()</span><br><span class="line">x = m <span class="comment">//ERROR: note: change 'let' to 'var' to make it mutable</span></span><br><span class="line">x.data = <span class="number">55</span> <span class="comment">// It's OK</span></span><br></pre></td></tr></table></figure><p>对于值类型来说，<code>let</code>的意思是<em>实例</em>必须是常量，而常量也是不变的，因此不能修改常量中保存的值，也不能修改值的本身。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">S</span>()</span><br><span class="line">a.data = <span class="number">2</span> <span class="comment">//ERROR: note: change 'let' to 'var' to make it mutable</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="type">S</span>()</span><br><span class="line">a = b <span class="comment">//ERROR: note: change 'let' to 'var' to make it mutable</span></span><br></pre></td></tr></table></figure><p>因此，相对于引用类型来说，值类型能更好控制实例可变和不可变，例如<code>NSString</code>和<code>NSMutableString</code>，只需要将字符串声明为<code>let a = &quot; &quot;</code>，那么它就是不可变类型的字符串，声明为<code>var a: String?</code>，它就是可变字符串。（Swift中的String为值类型）</p><h3 id="4、如何选择"><a href="#4、如何选择" class="headerlink" title="4、如何选择"></a>4、如何选择</h3><blockquote><p>If you always get a unique, copied instance, you can trust that no other part of your app is changing the data under the covers. This is especially helpful in multi-threaded environments where a different thread could alter your data out from under you. This can create nasty bugs that are extremely hard to debug.</p></blockquote><p>如果你一直希望持有一个实例的一份独立的备份，即使APP在其他地方修改了这部分数据，你仍然能访问一份原始数据。这在多线程的环境中特别有用，如果其他子线程在你不知道的情况下修改了这个实例，那么你仍然持有一份最原始的数据的备份。</p><p>使用值类型的情况：</p><ul><li>使用<code>==</code>比较两个实例时</li><li>当你需要一份独立的备份时</li><li>多线程中可能会修改数据时</li></ul><p>使用引用类型的情况：</p><ul><li>使用<code>===</code>比较两个实例时</li><li>你需要共享并且修改这个类型的实例时</li></ul><blockquote><p><code>==(Equal To)</code>表示两个实例的值相等(注意，值类型变量中保存的是值不是地址)；</p></blockquote><blockquote><p><code>===(Identical To)</code>表示两个实例完全相等，包括它们在内存中的地址也相同。</p></blockquote><p>在Swift中，<code>Array `</code>String <code>Dictionary</code>Int<code></code>Bool<code>等数据类型都是值类型，换句话说都是</code>struct<code>而不是</code>class`。因此在对它们赋值、传参等操作时，切记它是值传递，而不是引用传递。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a: [String])</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> b = a</span><br><span class="line">    b.append(<span class="string">"haha"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr: [<span class="type">String</span>] = [<span class="string">"hello"</span>, <span class="string">"world"</span>]</span><br><span class="line">foo(a: arr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"<span class="subst">\(arr)</span>"</span>)</span><br><span class="line"><span class="comment">// ["hello", "world"]</span></span><br></pre></td></tr></table></figure><h2 id="二、enum、struct、class"><a href="#二、enum、struct、class" class="headerlink" title="二、enum、struct、class"></a>二、enum、struct、class</h2><p>Swift的类型系统：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/2/160b564aa578d621?w=480&amp;h=134&amp;f=png&amp;s=12300" alt=""></p><p>Named type（命名类型）是指在定义时，可以使用特定的名字去命名的类型。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let foo: Double = 0.0</span><br><span class="line">// Double: 特定的命名类型</span><br></pre></td></tr></table></figure><p>Named model type（命名模型类型）是指可以在声明的时候可以重写<code>setter</code>或者<code>getter</code>的类型。例如：</p><p>假如你有一个存储<em>半径</em>的变量，然后要声明一个存储<em>直径</em>的变量：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> radius = <span class="number">5.0</span>;</span><br><span class="line"><span class="keyword">var</span> diameter: <span class="type">Double</span> &#123;</span><br><span class="line"><span class="keyword">get</span> &#123;</span><br><span class="line"><span class="keyword">return</span> radius * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">set</span> &#123;</span><br><span class="line">radius = newValue / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Compound type（复合类型）是指没有特定命名的类型。例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declare a tuple </span></span><br><span class="line"><span class="keyword">let</span> foo: (<span class="type">String</span>, [<span class="type">String</span>]) = (<span class="string">"foo"</span>, [<span class="string">"bar"</span>])</span><br><span class="line"><span class="comment">// not</span></span><br><span class="line"><span class="keyword">let</span> foo: <span class="type">Tuple</span> = (<span class="string">"foo"</span>, [<span class="string">"bar"</span>]) </span><br><span class="line"><span class="comment">// error</span></span><br></pre></td></tr></table></figure><h3 id="1、enum"><a href="#1、enum" class="headerlink" title="1、enum"></a>1、enum</h3><h4 id="1-、初始值"><a href="#1-、初始值" class="headerlink" title="(1)、初始值"></a>(1)、初始值</h4><p>枚举类型的每一个选项都可以带有一个初始值，和OC中的枚举类型一样，不同的是，Swift允许你指定这个初始值的类型，并且给每一个选项赋值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> black = <span class="string">"black"</span></span><br><span class="line">    <span class="keyword">case</span> gray  = <span class="string">"gray"</span></span><br><span class="line">    <span class="keyword">case</span> blue  = <span class="string">"blue"</span></span><br><span class="line">    <span class="keyword">case</span> white = <span class="string">"white"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略写法</span></span><br><span class="line"><span class="comment">//enum Color: String &#123;</span></span><br><span class="line"><span class="comment">//    case black ,gray, blue, white</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = <span class="type">Color</span>.black.rawValue</span><br><span class="line"><span class="built_in">print</span>(black)</span><br><span class="line"><span class="comment">// black</span></span><br></pre></td></tr></table></figure><h4 id="2-关联值"><a href="#2-关联值" class="headerlink" title="(2)关联值"></a>(2)关联值</h4><p>Swift中的枚举类型的每一个选项都允许你传入一个变量作为它的关联值，你可以在<code>switch</code>它的时候使用这个变量。例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CSColor</span> </span>&#123;</span><br><span class="line"><span class="comment">// 声明关联值的类型</span></span><br><span class="line">    <span class="keyword">case</span> named(<span class="type">Color</span>)</span><br><span class="line">    <span class="keyword">case</span> rgb(<span class="type">UInt8</span>, <span class="type">UInt8</span>, <span class="type">UInt8</span>) <span class="comment">// 0-255</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// CustomStringConvertible：这个协议的作用就是用字面量来描述一个类、结构体或者枚举</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CSColor</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> .named(<span class="keyword">let</span> name):</span><br><span class="line">                <span class="keyword">return</span> name.rawValue</span><br><span class="line">            <span class="keyword">case</span> .rgb(<span class="keyword">let</span> r, <span class="keyword">let</span> g, <span class="keyword">let</span> b):</span><br><span class="line">                <span class="keyword">return</span> <span class="type">String</span>.<span class="keyword">init</span>(format: <span class="string">"0x%02X%02X%02X"</span>, r, g, b)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> color = <span class="type">CSColor</span>.rgb(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>)</span><br><span class="line"><span class="comment">// 0xFFFFFF</span></span><br></pre></td></tr></table></figure><h4 id="（3）Optional"><a href="#（3）Optional" class="headerlink" title="*（3）Optional"></a>*（3）Optional</h4><p><code>Optional</code>在Swift中首先是个神奇的东西，其次是个非常重要的东西，理解它对于学习Swift重中之重。<br>它的声明：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">none</span>      <span class="comment">// 没有值</span></span><br><span class="line">    <span class="keyword">case</span> some(<span class="type">T</span>)   <span class="comment">// 有类型为T的某个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Optional</code>类型其实是一个枚举类型，它只有两个选项，要么是<code>none</code>，要么是某个<code>T</code>类型的值<code>some</code>。</p><h5 id="（I）关于"><a href="#（I）关于" class="headerlink" title="（I）关于?"></a>（I）关于<code>?</code></h5><p><code>?</code>的意思是声明的变量是个<code>Optional</code>类型。例如：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo: <span class="type">Double</span>？</span><br></pre></td></tr></table></figure><p>声明一个Double类型的变量，可以不赋值或者赋初值为<code>nil</code>，否则必须初始化它，如果一个变量不是<code>Optional</code>类型，那它永远不可能是<code>nil</code>。</p><p>当我们在使用<code>?</code>解包的时候，它的执行过程应该为（伪代码）：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> bar: <span class="type">String</span>? = <span class="string">"BAR"</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">let</span> x = bar?.lowercased</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 伪代码</span></span><br><span class="line"><span class="keyword">var</span> bar: <span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = <span class="string">"bar"</span></span><br><span class="line"><span class="comment">// 2 ?的作用</span></span><br><span class="line"><span class="keyword">switch</span> bar &#123;</span><br><span class="line"><span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">    bar = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> .some(<span class="keyword">let</span> xx):</span><br><span class="line">    bar = xx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> bar == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bar.lowercased</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>bar = nil</code>，则返回<code>nil</code>，如果<code>bar != nil</code>，则返回<code>bar</code>的值，并且调用<code>lowercased</code>方法。当然返回值赋值给<code>x</code>，<code>x</code>也是<code>Optional</code>类型，因为它也可能为<code>nil</code>。</p><h5 id="（II）关于"><a href="#（II）关于" class="headerlink" title="（II）关于!"></a>（II）关于<code>!</code></h5><p><code>!</code>的作用是强制解包的意思（unwrap），即，将<code>Optional</code>类型的变量强制解包为某个类型的值。如果这个值为<code>nil</code>，仍然强制解包的话，应用将会在运行时crash。所以如果不能确定变量的值是一定不是<code>nil</code>的话，千万不要用<code>!</code>解包。这种方式可以保证应用不会crash：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bar: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">var</span> x: <span class="type">String</span>?</span><br><span class="line"><span class="keyword">if</span> bar != <span class="literal">nil</span> &#123;</span><br><span class="line">    x = bar!.lowercased</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(x)</span><br></pre></td></tr></table></figure><h5 id="（III）关于nil"><a href="#（III）关于nil" class="headerlink" title="（III）关于nil"></a>（III）关于<code>nil</code></h5><p>OC中的<code>nil</code>代表空指针的意思，就是C中的<code>NULL</code>，它的定义为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MacType.h</span></span><br><span class="line">#ifndef <span class="type">NULL</span></span><br><span class="line">#define <span class="type">NULL</span>    __DARWIN_NULL</span><br><span class="line">#endif <span class="comment">/* ! NULL */</span></span><br><span class="line">#ifndef <span class="literal">nil</span></span><br><span class="line">  #<span class="keyword">if</span> defined(__has_feature) </span><br><span class="line">    #<span class="keyword">if</span> __has_feature(cxx_nullptr)</span><br><span class="line">      #define <span class="literal">nil</span> nullptr <span class="comment">// nullptr 空指针常量</span></span><br><span class="line">    #<span class="keyword">else</span></span><br><span class="line">      #define <span class="literal">nil</span> __DARWIN_NULL</span><br><span class="line">    #endif</span><br><span class="line">  #<span class="keyword">else</span></span><br><span class="line">    #define <span class="literal">nil</span> __DARWIN_NULL</span><br><span class="line">  #endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL (void *)0</span></span><br></pre></td></tr></table></figure><p>在OC中我们可以向<code>nil</code>发送消息（调用方法），因为OC是一门动态的语言，在编译期它并不关心一个对象是不是<code>nil</code>，它只关心这个类型的对象能不能接收这条消息。它会在运行时判断消息的接收者是不是<code>nil</code>，如果是<code>nil</code>，它会根据消息的返回类型返回对应的值，例如要求返回<code>int</code>类型，返回值就是<code>0</code>，<code>BOOL</code>类型，返回值就是<code>NO</code>，<code>id</code>类型，返回值就是<code>nil</code>，函数将直接返回。</p><p>Swift中的<code>nil</code>，并不是空指针的意思，因为Swift并不是一门纯面向对象的语言，大大减少了对引用类型的依赖，使用较多的是值类型，因此空指针对值类型来说，并没有什么意义。因此，<code>nil</code>表示的是<em>没有值</em>（the absence of a value）即，这块内存的这个变量中没有保存任何值。所以它在Swift中的定义为：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="literal">nil</span> = <span class="type">Optional</span>.<span class="keyword">none</span></span><br></pre></td></tr></table></figure><h3 id="2、struct-amp-class"><a href="#2、struct-amp-class" class="headerlink" title="2、struct &amp; class"></a>2、struct &amp; class</h3><p>Swift中的类都是引用类型，结构体都是值类型。</p><blockquote><p>Comparing Classes and Structures (类和结构体的异同点)</p></blockquote><blockquote><p>Classes and structures in Swift have many things in common. Both can (共同点):</p></blockquote><blockquote><p>Define properties to store values. (声明属性)</p></blockquote><blockquote><p>Define methods to provide functionality. (声明方法)</p></blockquote><blockquote><p>Define subscripts to provide access to their values using subscript syntax. (使用点语法)</p></blockquote><blockquote><p>Define initializers to set up their initial state. (使用构造方法初始化)</p></blockquote><blockquote><p>Be extended to expand their functionality beyond a default<br>implementation. (扩展默认实现以外的功能)</p></blockquote><blockquote><p>Conform to protocols to provide standard functionality of a certain kind. (使用协议)</p></blockquote><blockquote><p>For more information, see <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html#//apple_ref/doc/uid/TP40014097-CH14-ID254" target="_blank" rel="noopener">Properties</a>, <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Methods.html#//apple_ref/doc/uid/TP40014097-CH15-ID234" target="_blank" rel="noopener">Methods</a>, <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Subscripts.html#//apple_ref/doc/uid/TP40014097-CH16-ID305" target="_blank" rel="noopener">Subscripts</a>, <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-ID203" target="_blank" rel="noopener">Initialization</a>, <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151" target="_blank" rel="noopener">Extensions</a>, and <a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html#//apple_ref/doc/uid/TP40014097-CH25-ID267" target="_blank" rel="noopener">Protocols</a>. (更多信息)</p></blockquote><blockquote><p>Classes have additional capabilities that structures do not (类比结构体多的能力):</p></blockquote><blockquote><p>Inheritance enables one class to inherit the characteristics of another. (类可以继承)</p></blockquote><blockquote><p>Type casting enables you to check and interpret the type of a class instance at runtime. (类型转换使您能够在运行时检查和解释实例的类型)</p></blockquote><blockquote><p>Deinitializers enable an instance of a class to free up any resources it has assigned. (提供析构方法来释放一个类占用的资源)</p></blockquote><blockquote><p>Reference counting allows more than one reference to a class instance. (引用计数允许存在多个对实例的引用)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言-值类型-vs-引用类型&quot;&gt;&lt;a href=&quot;#前言-值类型-vs-引用类型&quot; class=&quot;headerlink&quot; title=&quot;前言 值类型 vs 引用类型&quot;&gt;&lt;/a&gt;前言 值类型 vs 引用类型&lt;/h2&gt;&lt;h3 id=&quot;1、什么是值类型&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="iOS 内存管理" scheme="http://yoursite.com/tags/iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Swift集合函数:Reduce、Map、FlatMap、Filter详解</title>
    <link href="http://yoursite.com/2018/01/02/Swift%E9%9B%86%E5%90%88%E5%87%BD%E6%95%B0-Reduce%E3%80%81Map%E3%80%81FlatMap%E3%80%81Filter%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/01/02/Swift集合函数-Reduce、Map、FlatMap、Filter详解/</id>
    <published>2018-01-02T03:20:58.000Z</published>
    <updated>2019-09-01T03:37:02.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h2><p>声明<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduce</span>&lt;Result&gt;<span class="params">(<span class="number">_</span> initialResult: Result, <span class="number">_</span> nextPartialResult: <span class="params">(Result, Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">Result</span></span><br></pre></td></tr></table></figure></p><blockquote><p>Returns the result of combining the elements of the sequence using the given closure.</p></blockquote><blockquote><p>使用给定的block来组合集合中的元素，并且返回组合后的结果</p></blockquote><p>参数</p><blockquote><p>initialResult</p></blockquote><blockquote><p>The value to use as the initial accumulating value. initialResult is passed to nextPartialResult the first time the closure is executed.</p></blockquote><blockquote><p>初始值</p></blockquote><blockquote><p>nextPartialResult</p></blockquote><blockquote><p>A closure that combines an accumulating value and an element of the sequence into a new accumulating value, to be used in the next call of the nextPartialResult closure or returned to the caller.</p></blockquote><blockquote><p>带有两个参数的block，block的第一个参数为之前的计算结果，如果是第一次计算，则默认为initialResult。第二个参数为集合中的下一个元素。返回值为遍历完整个集合后的组合结果。block中可以定义两个参数的组合规则。</p></blockquote><p>例如<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> da = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> sum = da.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; (result: <span class="type">Int</span>, ele: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line"><span class="keyword">return</span> result + ele</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sum = 15</span></span><br></pre></td></tr></table></figure></p><p>对数组<code>da</code>中的元素求和，第一个参数<code>0</code>为初始值，当数组第一次执行<code>result + ele //ele = data[0]</code>时，此时的<code>result</code>即为初始值。</p><p>可简写为<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> da = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> sum = da.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> $<span class="number">0</span> + $<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sum = 15</span></span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> da = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> sum = da.<span class="built_in">reduce</span>(<span class="number">0</span>, +)</span><br><span class="line"><span class="comment">// sum = 15</span></span><br></pre></td></tr></table></figure></p><p>注：Swift中操作符为函数，函数允许使用和block具有相同参数的函数作为参数代替block</p><p>上述代码的作用相当于<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> da = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;da.<span class="built_in">count</span> &#123;</span><br><span class="line">sum += da[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sum = 15</span></span><br></pre></td></tr></table></figure></p><h2 id="Map-amp-FlatMap"><a href="#Map-amp-FlatMap" class="headerlink" title="Map &amp; FlatMap"></a>Map &amp; FlatMap</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><blockquote><p>Returns an array containing the results of mapping the given closure over the sequence’s elements.</p></blockquote><blockquote><p>使用给定的block将数组映射为一个新的数组。新的数组元素为block中设置的映射规则确定。 </p></blockquote><p>参数：</p><blockquote><p>transform</p></blockquote><blockquote><p>A mapping closure. transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type.</p></blockquote><blockquote><p>一个block，参数为数组中的一个元素，block返回一个使用映射规则转换之后的元素。</p></blockquote><p>例如<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cast = [<span class="string">"Vivien"</span>, <span class="string">"Marlon"</span>, <span class="string">"Kim"</span>, <span class="string">"Karl"</span>]</span><br><span class="line"><span class="keyword">let</span> lowercaseNames = cast.<span class="built_in">map</span> &#123; $<span class="number">0</span>.lowercased() &#125;</span><br><span class="line"><span class="comment">// 'lowercaseNames' == ["vivien", "marlon", "kim", "karl"]</span></span><br><span class="line"><span class="keyword">let</span> letterCounts = cast.<span class="built_in">map</span> &#123; $<span class="number">0</span>.<span class="built_in">count</span> &#125;</span><br><span class="line"><span class="comment">// 'letterCounts' == [6, 6, 3, 4]</span></span><br></pre></td></tr></table></figure></p><h3 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h3><p><code>flatMap(_:)</code>和<code>map(_:)</code>一样，也是可以将一个集合通过某种映射规则映射为另一个集合，不同的地方是，<code>flatMap(_:)</code>会将映射之后的元素强解包（unwraped），如果遇到<code>nil</code>，则将其过滤到，返回的新集合为过滤掉<code>nil</code>之后的集合；<code>map(_:)</code>返回的元素为<code>Optional</code>类型元素，如果集合中有<code>nil</code>，则返回的集合中也包·括<code>nil</code>，其他元素均为<code>Optional</code>类型。<br>例如：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cast = [<span class="literal">nil</span>, <span class="string">"Marlon"</span>, <span class="string">"Kim"</span>, <span class="string">"Karl"</span>]</span><br><span class="line"><span class="keyword">let</span> uppercaseNames = cast.<span class="built_in">map</span> &#123; $<span class="number">0</span>?.uppercased() &#125; <span class="comment">//1</span></span><br><span class="line"><span class="comment">// 'uppercaseNames' = [nil, Optional("MARLON"), Optional("KIM"), Optional("KARL")]</span></span><br><span class="line"><span class="keyword">let</span> foo = cast.flatMap &#123; $<span class="number">0</span>?.uppercased() &#125;<span class="comment">//2</span></span><br><span class="line"><span class="comment">// 'foo' = ["MARLON", "KIM", "KARL"]</span></span><br></pre></td></tr></table></figure></p><p>1、将数组<code>cast</code>映射为一个新的数组，给定的映射规则是<code>$0?.uppercased()</code>，即将数组中的字符串全部转换成大写的形式，返回的新数组的元素为<code>optional</code>类型。</p><p>2、将数组<code>cast</code>映射为一个新的数组，给定的映射规则是<code>$0?.uppercased()</code>，即将数组中的字符串全部转换成大写的形式，并且将返回的数组元素解包， 如果元素为<code>nil</code>，则过滤掉。</p><h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><blockquote><p>Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.</p></blockquote><blockquote><p>返回一个数组，该数组按顺序包含满足给定谓词的序列元素。</p></blockquote><p>参数</p><blockquote><p>isIncluded</p></blockquote><blockquote><p>A closure that takes an element of the sequence as its argument and returns a Boolean value indicating whether the element should be included in the returned array.</p></blockquote><blockquote><p>一个block，将集合的元素作为参数，并返回一个Boolean，用来指示这个元素是否包含在返回的数组中，如果包括，则将其添加入数组。</p></blockquote><p>例如<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cast = [<span class="string">"Vivien"</span>, <span class="string">"Marlon"</span>, <span class="string">"Kim"</span>, <span class="string">"Karl"</span>]</span><br><span class="line"><span class="keyword">let</span> shortNames = cast.<span class="built_in">filter</span> &#123; $<span class="number">0</span>.<span class="built_in">count</span> &lt; <span class="number">5</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(shortNames)</span><br><span class="line"><span class="comment">// Prints "["Kim", "Karl"]"</span></span><br></pre></td></tr></table></figure></p><p>上述代码的作用为：筛选出名字的字数小于5的名字，<code>{ $0.count &lt; 5 }</code>这个block为筛选的谓词，<code>$0</code>为block的参数，即<code>shortNames</code>的元素。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Reduce&quot;&gt;&lt;a href=&quot;#Reduce&quot; class=&quot;headerlink&quot; title=&quot;Reduce&quot;&gt;&lt;/a&gt;Reduce&lt;/h2&gt;&lt;p&gt;声明&lt;br&gt;&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="iOS API 详解" scheme="http://yoursite.com/tags/iOS-API-%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>深入理解copy关键字</title>
    <link href="http://yoursite.com/2017/08/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3copy%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2017/08/30/深入理解copy关键字/</id>
    <published>2017-08-30T02:26:27.000Z</published>
    <updated>2019-09-01T03:37:02.779Z</updated>
    
    <content type="html"><![CDATA[<p>我们在声明 <code>NSString</code>、<code>NSArray</code>等具有可变子类的属性时，一般都会用 <code>copy</code> 关键字来指定它的特质。</p><h2 id="为什么要用-copy"><a href="#为什么要用-copy" class="headerlink" title="为什么要用 copy"></a>为什么要用 copy</h2><blockquote><p><code>copy</code> 关键字的解释是：此特质所表达的所属关系与 <code>strong</code>（为属性设置新值时，先保留新值，并释放旧值，然后再将新值设置上去）类似。不同的是，设置新值时，不保留新值，而是将其“拷贝”。</p></blockquote><p>看上去并没有什么大不了的，拷贝与否好像和设置成功不成功的关系不大！但是，传递给设置方法的新值可能是一个可变类的实例（父类指针指向子类对象），例如，给类型为 <code>NSString</code> 的属性设置新值时，可能会传递一个<code>NSMutableString</code>的实例。此时如果不拷贝字符串，设置完属性后，字符串的值可能会在对象不知道的情况下遭人更改。所以要拷贝一份”不可变”的字符串，确保对象中的字符串不会无意间被改变。</p><h2 id="理解copy的作用"><a href="#理解copy的作用" class="headerlink" title="理解copy的作用"></a>理解copy的作用</h2><p>举个例子来说：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *aString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.aString = <span class="string">@"test string"</span>;</span><br><span class="line"><span class="built_in">NSMutableString</span> *mutableString = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"hello world"</span>];</span><br><span class="line"><span class="keyword">self</span>.aString = mutableString;</span><br><span class="line">[mutableString setString:<span class="string">@"hahaha"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,_aString);</span><br><span class="line"><span class="comment">//print: hahaha</span></span><br></pre></td></tr></table></figure></p><p>我们首先声明了一个不可变字符串类型的属性 <code>aString</code>，并且给它赋了一个值，然后初始化了一个可变的字符串 <code>mutableString</code>，由于OC这门语言的多态性，即<strong>父类指针可以指向子类对象</strong>，因为 <code>NSMutableString</code> 是 <code>NSString</code> 的子类，所以，我们可以将不可变字符串类型的指针 <code>self.aString</code> 指向可变字符串类型的对象 <code>mutableString</code>，然后当我们改变 <code>mutableString</code> 的值的时候，此时不可变字符串 <code>self.aString</code> 的值也随之改变，假如我们再其他较多的地方也使用了 <code>self.aString</code> 这个对象，那么该对象的值就会在我们不知情的情况下遭到修改，然后就会造成多处使用错误。<br>下面我们对上述代码稍作修改：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.aString = <span class="string">@"test string"</span>;</span><br><span class="line"><span class="built_in">NSMutableString</span> *mutableString = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"hello world"</span>];</span><br><span class="line"><span class="keyword">self</span>.aString = [mutableString <span class="keyword">copy</span>];</span><br><span class="line">[mutableString setString:<span class="string">@"hahaha"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,_aString);</span><br><span class="line"><span class="comment">//print: hello world</span></span><br></pre></td></tr></table></figure></p><p>在将可变字符串赋值给  <code>self.aString</code>  的时候，进行一步copy的操作，此时可以看到打印的信息为 <code>hello world</code> ，这就说明，当我们修改可变对象的时候没对不可变对象造成任何影响。<br>为了避免每次赋值都进行一次 copy 操作，有的时候也会遗漏，我们可以在声明属性的时候，使用 <code>copy</code> 关键字，<code>copy</code> 关键字的作用就是每当该属性被赋值的时候，都进行一次拷贝，这样就可以保证这个对象永远不会因为其可变子类对象的修改而被修改。例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *aString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.aString = <span class="string">@"test string"</span>;</span><br><span class="line"><span class="built_in">NSMutableString</span> *mutableString = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"hello world"</span>];</span><br><span class="line"><span class="keyword">self</span>.aString = mutableString;</span><br><span class="line">[mutableString setString:<span class="string">@"hahaha"</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,_aString);</span><br><span class="line"><span class="comment">//print: hello world</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>copy</code> 关键字就可以保证该属性指向的值永远为不可变对象。</p><h2 id="copy-的原理"><a href="#copy-的原理" class="headerlink" title="copy 的原理"></a>copy 的原理</h2><p>那么 <code>copy</code> 关键字怎么保证我们每次辅助的时候都进行一次拷贝的n呢？</p><p>假如我们声明一个 <code>strong</code> 修饰的属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *aString;</span><br></pre></td></tr></table></figure><p>那么它被合成的 <code>-setter</code> 方法为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARC 下</span></span><br><span class="line">- (<span class="keyword">void</span>)setAString:(<span class="built_in">NSString</span> *)aString &#123;</span><br><span class="line">    _aString = aString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MRC 下</span></span><br><span class="line">- (<span class="keyword">void</span>)setAString:(<span class="built_in">NSString</span> *)aString &#123;</span><br><span class="line">    <span class="comment">// 释放旧值</span></span><br><span class="line">    [_aString release];</span><br><span class="line">    <span class="comment">// retain 新值</span></span><br><span class="line">    _aString = [aString <span class="keyword">retain</span>];</span><br><span class="line">    <span class="comment">// release 新值</span></span><br><span class="line">    [aString release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MRC 下的 <code>-setter</code> 方法可以让我们清晰的看到 <code>strong</code> 关键字的作用。那么 <code>copy</code> 和 <code>strong</code> 的不同点在哪呢?</p><p>如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *aString;</span><br></pre></td></tr></table></figure><p>它被合成的 <code>-setter</code> 方法为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ARC</span></span><br><span class="line">- (<span class="keyword">void</span>)setAString:(<span class="built_in">NSString</span> *)aString &#123;</span><br><span class="line">    _aString = [aString <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MRC</span></span><br><span class="line">- (<span class="keyword">void</span>)setAString:(<span class="built_in">NSString</span> *)aString &#123;</span><br><span class="line">    <span class="comment">// 释放旧值</span></span><br><span class="line">    [_aString release];</span><br><span class="line">    <span class="comment">// 拷贝新值</span></span><br><span class="line">    _aString = [aString <span class="keyword">copy</span>];</span><br><span class="line">    <span class="comment">// release 新值</span></span><br><span class="line">    [aString release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同点在于它会将新值的拷贝设置给属性，而不是直接 <code>retain</code>。这就可以确保该属性持有的那一份一直都是被设置的对象的拷贝，所以无论怎么修改被设置的对象，都不会影响它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在声明 &lt;code&gt;NSString&lt;/code&gt;、&lt;code&gt;NSArray&lt;/code&gt;等具有可变子类的属性时，一般都会用 &lt;code&gt;copy&lt;/code&gt; 关键字来指定它的特质。&lt;/p&gt;
&lt;h2 id=&quot;为什么要用-copy&quot;&gt;&lt;a href=&quot;#为什么要用-c
      
    
    </summary>
    
    
      <category term="iOS 内存管理" scheme="http://yoursite.com/tags/iOS-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>NSURLSession</title>
    <link href="http://yoursite.com/2015/08/21/NSURLSession/"/>
    <id>http://yoursite.com/2015/08/21/NSURLSession/</id>
    <published>2015-08-21T09:19:55.000Z</published>
    <updated>2019-09-01T03:37:02.775Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自 <a href="https://www.raywenderlich.com/110458/nsurlsession-tutorial-getting-started" target="_blank" rel="noopener">https://www.raywenderlich.com/110458/nsurlsession-tutorial-getting-started</a>   </p><p>原作者：<a href="https://www.raywenderlich.com/u/kentoh" target="_blank" rel="noopener">Ken Toh</a>    </p><p>译者：X.M.Zhang       </p><hr><p>当一个app从服务端获取用户数据更新社交媒体信息和下载远程的文件到磁盘的时候，就会用到移动应用的核心技术：HTTP网络请求。为了帮助开发者处理大量的网络请求，Apple提供了<code>NSURLSession</code>，这是一套通过HTTP请求来完成上传和下载的完整的API。  </p><p>在本教程中，你将学会怎样去用<code>NSURLSession</code>来创建一个Half Tunes应用，这个应用的作用是接入<a href="https://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html" target="_blank" rel="noopener">iTunes Search API</a>，搜索API提供的30s的预览音乐，并且下载你选择的音乐。完成后的app将提供后台传输，让用户暂停、继续、取消正在下载的音乐等功能。   </p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Starter.zip" target="_blank" rel="noopener">点击此处下载项目</a>  </p><p>项目包含搜索歌曲、播放歌曲的用户界面，和一些解析JSON、播放路径的帮助方法，可以让你专心的去实现app的网络部分。  </p><p>运行你下载的项目，将会看到如下的界面： </p><p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2015/08/Simulator-Screen-Shot-12-Aug-2015-11.10.57-pm-281x500.png" alt=""> </p><p>在搜索框输入一个想搜索的内容，点击搜索按钮。仍然是空的界面，不要方，你将通过<code>NSURLSession</code>的调用来完善他的功能。  </p><h2 id="NSURLSession概述"><a href="#NSURLSession概述" class="headerlink" title="NSURLSession概述"></a>NSURLSession概述</h2><p>在开始之前，让我们先了解一下<code>NSURLSession</code>和他的组成类。   </p><p><code>NSURLSession</code>既使用一个类，又使用一整套类去完成基于HTTP/HTTPS的请求   </p><p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2015/08/Screen-Shot-2015-08-20-at-12.27.21-am.png" alt="">  </p><p><code>NSURLSession</code>是响应发送和接收HTTP请求的关键对象，使用<code>NSURLSessionConfiguration</code>来创建它。三种配置：    </p><ul><li><code>defaultSessionConfiguration</code>:创建一个默认配置的session对象，可以访问永久的全部的磁盘缓存、证书和保存的cookie对象。    </li><li><code>ephemeralSessionConfiguration</code>:除了只能在内存中保存和这个session有关的数据之外，其他的和默认配置相同，可以理解为“私有的”session。    </li><li><code>backgroundSessionConfiguration</code>:用这个配置创建的session对象，可以在后台进行下载和上传操作，即使app暂停或者终止。 </li></ul><p>你也可以使用<code>NSURLSessionConfiguration</code>配置session的其他属性，比如：超时、缓存策略、附加的HTTP头部等。<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSURLSessionConfiguration_class/index.html#//apple_ref/occ/cl/NSURLSessionConfiguration" target="_blank" rel="noopener">所有的配置选项</a>  </p><p><code>NSURLSessionTask</code>是一个抽象类，session用来生成task去做实际的工作，比如：获取数据、下载和上传文件等。   </p><p>Apple提供了三种task：  </p><ul><li><code>NSURLSessionDataTask</code>:通过HTTP GET方法，从服务端获取数据。</li><li><code>NSURLSessionUploadTask</code>:顾名思义，用来向web服务器上传文件，一般使用HTTP POST和PUT方法。</li><li><code>NSURLSessionDownloadTask</code>:从远程服务器下载文件到一个临时的本地路径。</li></ul><p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/08/Screen-Shot-2015-08-20-at-12.27.27-am.png" alt="">   </p><p>你可以随时暂停、继续、取消任务。<code>NSURLSessionDownloadTask</code>支持断点续传。  </p><p>一般来说，<code>NSURLSession</code>可以通过两种方式（完成block和代理）进行任务完成成功或者报错的回调。</p><p>现在，你已经了解了<code>NSURLSession</code>的主要功能，可以进行理论与实践相结合了。  </p><h2 id="查询跟踪"><a href="#查询跟踪" class="headerlink" title="查询跟踪"></a>查询跟踪</h2><p>你将在之前下载的项目内添加一些代码，当用户搜索一些内容的时候，查询iTunes Search API。  </p><p>在<code>SearchViewController.swift</code>类的顶部添加下面的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> defaultSession = <span class="type">NSURLSession</span>(configuration: <span class="type">NSURLSessionConfiguration</span>.defaultSessionConfiguration())</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> dataTask: <span class="type">NSURLSessionDataTask</span>?</span><br></pre></td></tr></table></figure><p>这两行代码的作用是：</p><p>&emsp;1.创建了<code>NSURLSession</code>，并且使用默认的配置初始化。<br>&emsp;2.声明了一个<code>NSURLSessionDataTask</code>变量，将用它来向iTunes Search web服务器进行HTTP GET请求实现用户的搜索。当用户每次重新输入内容搜索的时候，这个task都会被重新初始化并且利用。    </p><p>现在，用下面的代码替换<code>searchBarSearchButtonClicked(_:)</code>这个方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">searchBarSearchButtonClicked</span><span class="params">(searchBar: UISearchBar)</span></span> &#123;</span><br><span class="line">  dismissKeyboard()</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> !searchBar.text!.isEmpty &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> dataTask != <span class="literal">nil</span> &#123;</span><br><span class="line">      dataTask?.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="type">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">let</span> expectedCharSet = <span class="type">NSCharacterSet</span>.<span class="type">URLQueryAllowedCharacterSet</span>()</span><br><span class="line">    <span class="keyword">let</span> searchTerm = searchBar.text!.stringByAddingPercentEncodingWithAllowedCharacters(expectedCharSet)!</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: <span class="string">"https://itunes.apple.com/search?media=music&amp;entity=song&amp;term=<span class="subst">\(searchTerm)</span>"</span>)</span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    dataTask = defaultSession.dataTaskWithURL(url!) &#123;</span><br><span class="line">      data, response, error <span class="keyword">in</span></span><br><span class="line">      <span class="comment">// 6</span></span><br><span class="line">      dispatch_async(dispatch_get_main_queue()) &#123;</span><br><span class="line">        <span class="type">UIApplication</span>.sharedApplication().networkActivityIndicatorVisible = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 7</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">        <span class="built_in">print</span>(error.localizedDescription)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> httpResponse = response <span class="keyword">as</span>? <span class="type">NSHTTPURLResponse</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> httpResponse.statusCode == <span class="number">200</span> &#123;</span><br><span class="line">          <span class="keyword">self</span>.updateSearchResults(data)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 8</span></span><br><span class="line">    dataTask?.resume()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照注释数字的顺序看：     </p><p>&emsp;1.每当用户点击搜索的时候，检查data task是不是已经初始化，如果是，取消这个task，因为我们在重用同一个task，取消的task是上次搜索的task。<br>&emsp;2.开启状态栏的网络活动指示，告诉用户已经在搜索。<br>&emsp;3.在把用户的输入字符串作为参数进行请求之前，对字符串调用<code>stringByAddingPercentEncodingWithAllowedCharacters(_:)</code>方法，确保是正确的字符格式。<br>&emsp;4.使用转化格式后的字符拼接字符串构造了一个<code>NSURL</code>，作为请求的url。<br>&emsp;5.通过之前创建的<code>defaultSession</code>实例化一个<code>NSURLSessionDataTask</code>，去执行HTTP GET请求。这个方法传入了之前构造的<code>url</code>和一个完成回调block。<br>&emsp;6.在task的完成回调中，回到主线程隐藏网络活动知识器。<br>&emsp;7.如果请求成功，调用<code>updateSearchResults(_:)</code>将响应的NSData数据解析成<code>track</code>(model)。<br>&emsp;8.调用<code>resume()</code>，开始task。   </p><p>运行你的app，搜索一些歌曲，你将看到表视图显示了和搜索内容相关的结果。如下所示：     </p><p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2015/08/Simulator-Screen-Shot-12-Aug-2015-11.02.34-pm-281x500.png" alt="">    </p><p>因为添加了一些magic <code>NSURLSession</code>代码，Half Tunes现在总算是有点功能了。    </p><h2 id="下载搜索结果"><a href="#下载搜索结果" class="headerlink" title="下载搜索结果"></a>下载搜索结果</h2><p>可以看到歌曲的搜索结果是很nice，但是如果可以点击下载的话，是不是会更加nice，这是我们接下来该做的事。   </p><p>为了轻轻松松的执行多个下载，首先要创建一个类，去控制下载任务的状态。   </p><p>创建一个新的文件，命名为<code>Download.swift</code>在<code>Data Objects</code>文件夹中。   </p><p>打开<code>Download.swift</code>添加下面的实现：   </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Download</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> url: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> isDownloading = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> progress: <span class="type">Float</span> = <span class="number">0.0</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> downloadTask: <span class="type">NSURLSessionDownloadTask</span>?</span><br><span class="line">  <span class="keyword">var</span> resumeData: <span class="type">NSData</span>?</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">init</span>(url: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.url = url</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<code>Download</code>这个类的属性的解释：   </p><ul><li><code>url</code>:被下载文件的URL，这也是不同的<code>Download</code>的唯一标识符。    </li><li><code>isDownloading</code>:是否正在下载。</li><li><code>progress</code>:下载进度，float类型，0.0 - 1.0。</li><li><code>downloadTask</code>:<code>NSURLSessionDownloadTask</code>用来下载任务。</li><li><code>resumeData</code>:在暂停下载的时候，保存已经下载的数据。用来实现断点续传。   </li></ul><p>切换到<code>SearchViewController.swift</code>，在类的顶部添加如下代码：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var activeDownloads = [String: Download]()</span><br></pre></td></tr></table></figure><p>这样就可以很简单的通过一个字典来标识<code>url</code>对应的下载任务    </p><h2 id="创建一个下载任务"><a href="#创建一个下载任务" class="headerlink" title="创建一个下载任务"></a>创建一个下载任务</h2><p>根据我们的任务清单，现在要做的是实现文件的下载功能，首先，要创建一个专用的session去处理下载任务。    </p><p>在<code>SearchViewController.swift</code>文件中，<code>viewDidLoad():</code>方法之前的合适的位置添加下面的代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> downloadsSession: <span class="type">NSURLSession</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> configuration = <span class="type">NSURLSessionConfiguration</span>.defaultSessionConfiguration()</span><br><span class="line">  <span class="keyword">let</span> session = <span class="type">NSURLSession</span>(configuration: configuration, delegate: <span class="keyword">self</span>, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">return</span> session</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></p><p>我们使用默认的<code>defaultSessionConfiguration</code>创建了一个单独的session来处理所有的下载任务。同时指定一个<code>delegate</code>，用来接收<code>NSURLSession</code>的回调，比如：完成回调，下载进度回调等。    </p><p><code>delegateQueue</code>设置为<code>nil</code>，会为我们创建一个默认的串行队列执行所有的代理回调和完成block的回调。   </p><p>注意，懒加载<code>downloadsSession:</code>会让我们在需要的时候再创建session，更值得注意的是，我们将传<code>self</code>作为代理的参数初始化session，即使<code>self</code>没有被初始化。   </p><p>在<code>SearchViewController.swift</code>文件中，添加<code>NSURLSessionDownloadDelegate</code>扩展：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SearchViewController</span>: <span class="title">NSURLSessionDownloadDelegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">URLSession</span><span class="params">(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Finished downloading."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>NSURLSessionDownloadDelegate</code>定义了当你使用<code>NSURLSessionDownloadTask</code>的时候要实现的代理方法，唯一的必须实现的方法为：<code>URLSession(_:downloadTask:didFinishDownloadingToURL:)</code>，每当下载完成的时候回调用它，每当下载完成的时候，你可以实现这个方法来打印一些简单的信息。   </p><p>完成session和代理的配置，接下来我们要准备创建一个下载任务，当用户点击下载的时候。   </p><p>在<code>SearchViewController.swift</code>文件中,用下面的代码替换<code>startDownload(_:)</code>的实现代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startDownload</span><span class="params">(track: Track)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> urlString = track.previewUrl, url =  <span class="type">NSURL</span>(string: urlString) &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">let</span> download = <span class="type">Download</span>(url: urlString)</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    download.downloadTask = downloadsSession.downloadTaskWithURL(url)</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    download.downloadTask!.resume()</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    download.isDownloading = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    activeDownloads[download.url] = download</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当用户点击下载按钮的时候，就会调用上面的方法，下载相应的内容，按照代码中的数字标记来看：</p><p>&emsp;1.首先使用<code>track</code>的<code>previewURL</code>实例化一个<code>Download</code>对象。<br>&emsp;2.然后用刚才懒加载的session创建一个<code>NSURLSessionDownloadTask</code>，并将它赋值给<code>Download</code>的<code>downloadTask</code>属性。<br>&emsp;3.调用<code>resume()</code>方法开始下载任务。<br>&emsp;4.将<code>isDownloading</code>设置为<code>true</code>标记正在下载。<br>&emsp;5.以<code>url</code>为键，<code>download</code>为值，存入<code>activeDownloads</code>字典中。      </p><p>运行你的app，输入一个关键字搜索，然后点击<code>cell</code>上面的<code>Download</code>按钮，过一会就会看到控制台上打印的信息：<code>Finished downloading.</code>，代表下载完成了。    </p><h2 id="保存并且播放"><a href="#保存并且播放" class="headerlink" title="保存并且播放"></a>保存并且播放</h2><p>当一个下载任务完成的时候，<code>URLSession(_:downloadTask:didFinishDownloadingToURL:)</code>代理方法会提供一个临时的路径保存下载的数据，我们的工作是把它移动带app的沙盒中的不变位置，并且把这个下载任务从<code>activeDownloads</code>字典中移除。   </p><p>我们需要添加一些帮助方法让事情更轻松一些，在<code>SearchViewController.swift</code>类中，添加如下方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">trackIndexForDownloadTask</span><span class="params">(downloadTask: NSURLSessionDownloadTask)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> url = downloadTask.originalRequest?.<span class="type">URL</span>?.absoluteString &#123;</span><br><span class="line">    <span class="keyword">for</span> (index, track) <span class="keyword">in</span> searchResults.<span class="built_in">enumerate</span>() &#123;</span><br><span class="line">      <span class="keyword">if</span> url == track.previewUrl! &#123;</span><br><span class="line">        <span class="keyword">return</span> index</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每一个<code>track</code>都有一个唯一的<code>url</code>标识，这个方法仅仅返回了给定的<code>url</code>标记的<code>track</code>在<code>searchResults</code>数组中的<code>index</code>。   </p><p>然后，用下面的代码代替<code>URLSession(_:downloadTask:didFinishDownloadingToURL:)</code>方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">URLSession</span><span class="params">(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didFinishDownloadingToURL location: NSURL)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> originalURL = downloadTask.originalRequest?.<span class="type">URL</span>?.absoluteString,</span><br><span class="line">    destinationURL = localFilePathForUrl(originalURL) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">print</span>(destinationURL)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">let</span> fileManager = <span class="type">NSFileManager</span>.defaultManager()</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> fileManager.removeItemAtURL(destinationURL)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">// Non-fatal: file probably doesn't exist</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> fileManager.copyItemAtURL(location, toURL: destinationURL)</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error <span class="keyword">as</span> <span class="type">NSError</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"Could not copy file to disk: <span class="subst">\(error.localizedDescription)</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> url = downloadTask.originalRequest?.<span class="type">URL</span>?.absoluteString &#123;</span><br><span class="line">    activeDownloads[url] = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> trackIndex = trackIndexForDownloadTask(downloadTask) &#123;</span><br><span class="line">      dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">        <span class="keyword">self</span>.tableView.reloadRowsAtIndexPaths([<span class="type">NSIndexPath</span>(forRow: trackIndex, inSection: <span class="number">0</span>)], withRowAnimation: .<span class="type">None</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键步骤：    </p><p>&emsp;1.获取<code>task</code>的<code>url</code>，并且把它作为<code>localFilePathForUrl(_:)</code>的参数。<code>localFilePathForUrl(_:)</code>把传入的<code>url</code>作为文件名拼接到沙盒的<code>Documents</code>路径。<br>&emsp;2.在把数据从临时路径拷贝到期望的目标路径之前，使用<code>NSFileManager</code>把目标路径中已经存在的缓存删除掉。<br>&emsp;3.在完成拷贝之后，找到字典中相应的task，把它设置为<code>nil</code>。<br>&emsp;4.找到表视图中的显示这首歌曲的<code>cell</code>，更新它。   </p><p>运行你的app，搜索一些内容并且下载它，你将会在控制台看到打印的路径信息。  </p><p><code>Download</code>按钮也会隐藏，这首歌曲现在在你的设备中，点击<code>cell</code>，就可以跳转到<code>MPMoviePlayerViewController</code>播放，如下所示：   </p><p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2015/08/Simulator-Screen-Shot-17-Aug-2015-1.45.28-am-281x500.png" alt="">         </p><p>##监听下载进度<br>到目前为止，我们没有做任何事监听下载进度，为了提高用户体验，我们将做一些事监听下载进度，并且显示到<code>cell</code>上。<br>打开<code>SearchViewController.swift</code>找到<code>NSURLSessionDownloadDelegate</code>的扩展，实现下面的代理方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">URLSession</span><span class="params">(session: NSURLSession, downloadTask: NSURLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64)</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> downloadUrl = downloadTask.originalRequest?.<span class="type">URL</span>?.absoluteString,</span><br><span class="line">      download = activeDownloads[downloadUrl] &#123;</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      download.progress = <span class="type">Float</span>(totalBytesWritten)/<span class="type">Float</span>(totalBytesExpectedToWrite)</span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">let</span> totalSize = <span class="type">NSByteCountFormatter</span>.stringFromByteCount(totalBytesExpectedToWrite, countStyle: <span class="type">NSByteCountFormatterCountStyle</span>.<span class="type">Binary</span>)</span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> trackIndex = trackIndexForDownloadTask(downloadTask), <span class="keyword">let</span> trackCell = tableView.cellForRowAtIndexPath(<span class="type">NSIndexPath</span>(forRow: trackIndex, inSection: <span class="number">0</span>)) <span class="keyword">as</span>? <span class="type">TrackCell</span> &#123;</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">          trackCell.progressView.progress = download.progress</span><br><span class="line">          trackCell.progressLabel.text =  <span class="type">String</span>(format: <span class="string">"%.1f%% of %@"</span>,  download.progress * <span class="number">100</span>, totalSize)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一步一步的来看这个代理方法：   </p><p>&emsp;1.用方法提供的<code>downloadTask</code>参数，获取它的<code>url</code>，利用<code>url</code>在<code>activeDownloads</code>字典中取出相应的<code>Download</code>。<br>&emsp;2.这个方法也会返回已经下载的字节数和文件的总字节数，我们将计算这两个数的比值，赋值给<code>Download</code>的<code>progress</code>属性，我们将用这个值来更新<code>cell</code>上的<code>progress view</code>。<br>&emsp;3.调用了<code>NSByteCountFormatter</code>的类方法将文件的内存大小从字节数转化为人类可读的字符串，在<code>progress label</code>上显示。<br>&emsp;4.最后，找到和这首歌曲对应的<code>cell</code>，回到主线程更新他的<code>progress view</code>和<code>progress label</code>。     </p><p>然后，当下载进行中的时候，配置<code>cell</code>，显示相应的下载进度和状态。    </p><p>在<code>tableView(_:cellForRowAtIndexPath:):</code>方法中，找到：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> downloaded = localFileExistsForTrack(track)</span><br></pre></td></tr></table></figure></p><p>在这行代码的前面添加：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showDownloadControls = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> download = activeDownloads[track.previewUrl!] &#123;</span><br><span class="line">  showDownloadControls = <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">  cell.progressView.progress = download.progress</span><br><span class="line">  cell.progressLabel.text = (download.isDownloading) ? <span class="string">"Downloading..."</span> : <span class="string">"Paused"</span></span><br><span class="line">&#125;</span><br><span class="line">cell.progressView.hidden = !showDownloadControls</span><br><span class="line">cell.progressLabel.hidden = !showDownloadControls</span><br></pre></td></tr></table></figure></p><p>添加了一个布尔类型的变量<code>showDownloadControls</code>，作为标记来更新<code>progress view</code>和<code>progress label</code>的显示内容和是否隐藏。   </p><p>当暂停下载的时候显示<code>Paused</code>，正在下载的时候显示<code>Downloading...</code>。    </p><p>然后，把下面一行代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.downloadButton.hidden = downloaded</span><br></pre></td></tr></table></figure></p><p>替换为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cell.downloadButton.hidden = downloaded || showDownloadControls</span><br></pre></td></tr></table></figure></p><p>当我们正在下载的时候，把<code>Download</code>按钮隐藏。    </p><p>运行你的app，随便下载一首歌曲，就会看到我们已经完成了对下载进度的监听以及相关状态的改变。    </p><h2 id="暂停、继续、取消下载"><a href="#暂停、继续、取消下载" class="headerlink" title="暂停、继续、取消下载"></a>暂停、继续、取消下载</h2><p>假如用户需要暂停或者取消下载会怎么样？在这一部分，我们将实现下载的暂停、继续和取消功能。    </p><p>我们从允许用户取消正在下载的任务开始。    </p><p>替换<code>cancelDownload(_:)</code>方法为：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancelDownload</span><span class="params">(track: Track)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> urlString = track.previewUrl,</span><br><span class="line">    download = activeDownloads[urlString] &#123;</span><br><span class="line">      download.downloadTask?.cancel()</span><br><span class="line">      activeDownloads[urlString] = <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们从<code>activeDownloads</code>字典中取出相应的<code>download</code>，然后调用<code>cancel()</code>方法，取消这个任务。然后把这个<code>download</code>从字典中移除。    </p><p>暂停下载和取消下载在概念上是非常相似的，不同的地方是，暂停下载的会生成<code>resume data</code>，<code>resume data</code>包含接下来继续任务时的信息，需要服务端提供此功能。    </p><p>用下面的代码替换<code>pauseDownload(_:)</code>方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pauseDownload</span><span class="params">(track: Track)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> urlString = track.previewUrl,</span><br><span class="line">    download = activeDownloads[urlString] &#123;</span><br><span class="line">      <span class="keyword">if</span>(download.isDownloading) &#123;</span><br><span class="line">        download.downloadTask?.cancelByProducingResumeData &#123; data <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">if</span> data != <span class="literal">nil</span> &#123;</span><br><span class="line">            download.resumeData = data</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        download.isDownloading = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和取消方法的不同点是，这里调用了<code>cancelByProducingResumeData(_:)</code>方法，而不是<code>cancel()</code>。我们在暂停下载的时候，生成了<code>resume data</code>,并且取出赋值给<code>download</code>的<code>resumeData</code>属性。    </p><p>同时设置<code>isDownloading</code>为<code>false</code>标记下载暂停。    </p><p>接下来要做的是从暂停的地方继续下载任务。     </p><p>用下面的代码代替<code>resumeDownload(_:)</code>方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">resumeDownload</span><span class="params">(track: Track)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> urlString = track.previewUrl,</span><br><span class="line">    download = activeDownloads[urlString] &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> resumeData = download.resumeData &#123;</span><br><span class="line">        download.downloadTask = downloadsSession.downloadTaskWithResumeData(resumeData)</span><br><span class="line">        download.downloadTask!.resume()</span><br><span class="line">        download.isDownloading = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> url = <span class="type">NSURL</span>(string: download.url) &#123;</span><br><span class="line">        download.downloadTask = downloadsSession.downloadTaskWithURL(url)</span><br><span class="line">        download.downloadTask!.resume()</span><br><span class="line">        download.isDownloading = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们首先判断，要继续的任务的<code>resumeData</code>是否为<code>nil</code>，以便于决定是从断点处继续下载，还是从头开始下载。如果不为空，则调用<code>downloadTaskWithResumeData(_:)</code>方法、使用<code>resume data</code>创建一个新的任务，并且调用<code>resume()</code>执行任务。如果<code>resume data</code>为空，则创建一个新的任务，传入<code>url</code>，重新开始下载。    </p><p>在这两种情况下，都要把<code>isDownloading</code>设置为<code>true</code>，标记为正在下载。    </p><p>接下来还有一件事要去做，就是在合适的时间显示和隐藏<code>Pause</code>、<code>Cancel</code>和<code>Resume</code>按钮。    </p><p>找到<code>tableView(_:cellForRowAtIndexPath:)</code>方法，找到下面的代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> download = activeDownloads[track.previewUrl!] &#123;</span><br></pre></td></tr></table></figure></p><p>在条件语句的最后加入下面两行代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> title = (download.isDownloading) ? <span class="string">"Pause"</span> : <span class="string">"Resume"</span></span><br><span class="line">cell.pauseButton.setTitle(title, forState: <span class="type">UIControlState</span>.<span class="type">Normal</span>)</span><br></pre></td></tr></table></figure></p><p>这两行代码的作用就是让按钮的<code>titleLabel</code>在正确的状态显示正确的标识(<code>Pause</code>or<code>Resume</code>)。    </p><p>接下来，在<code>reture</code>之前加入下面的代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cell.pauseButton.hidden = !showDownloadControls</span><br><span class="line">cell.cancelButton.hidden = !showDownloadControls</span><br></pre></td></tr></table></figure></p><p>这两句就是实现了是否显示这两个按钮。   </p><p>运行你的app，同时下载几首歌曲，你可以暂停、继续和取消他们，like this：<br><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2015/08/Simulator-Screen-Shot-18-Aug-2015-10.14.38-pm-281x500.png" alt="">  </p><h2 id="实现后台下载"><a href="#实现后台下载" class="headerlink" title="实现后台下载"></a>实现后台下载</h2><p>现在，我们的app已经初具雏形了，但是，我们还需要添加一些更优雅的东西使用户体验更好。如果因为一些原因app进入后台或者崩溃的时候，让正在下载的任务继续下载。   </p><p>如果我们的app没有运行，怎么能继续下载工作呢？有一个单独的后台进程在app的外部运行，并且管理后台的传输任务。在app运行的时候，它会向app发送合适的代理信息。当app在运行的时候突然中止，任务会在后台继续进行。   </p><p>当任务完成的时候，后台进程会在后台重新打开app。重新打开的app会重新链接和之前相同的会话、接收相关的完成代理信息和执行一些动作，比如：存储文件到本地磁盘。   </p><p>仍然打开<code>SearchViewController.swift</code>，在<code>downloadsSession</code>的初始化中，找到下面的代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = <span class="type">NSURLSessionConfiguration</span>.defaultSessionConfiguration()</span><br></pre></td></tr></table></figure></p><p>用下面的代码替换它：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = <span class="type">NSURLSessionConfiguration</span>.backgroundSessionConfigurationWithIdentifier(<span class="string">"bgSessionConfiguration"</span>)</span><br></pre></td></tr></table></figure></p><p>将默认的session配置用特殊的<code>backgroundSessionConfiguration</code>替换，并且为它设置一个identifier，目的是为了实现上文中提到的重新连接会话。   </p><p>然后在<code>viewDidLoad()</code>，添加下面代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">_</span> = <span class="keyword">self</span>.downloadsSession</span><br></pre></td></tr></table></figure></p><p>这行代码的作用是保证<code>SearchViewController</code>初始化的同时懒加载一个<code>downloadsSession</code>对象。   </p><p>当后台的任务完成的时候，而app没有在运行，app将在后台重新启动，我们将在app delegate里面完成这个操作。   </p><p>切换到<code>AppDelegate.swift</code>，在这个类的顶部添加下面代码：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> backgroundSessionCompletionHandler: (() -&gt; <span class="type">Void</span>)?</span><br></pre></td></tr></table></figure></p><p>然后添加下面的方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  backgroundSessionCompletionHandler = completionHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们在app delegate中保存了一个<code>completionHandler</code>block变量，以便后面使用。    </p><p><code>application(_:handleEventsForBackgroundURLSession:)</code>方法会唤醒app去处理完成的后台任务，我们需要在这个事件处理两个东西：<br>&emsp;1.首先，app需要通过代理方法提供的标识符(identifier)重新链接相关的后台会话，但是因为每次创建和使用后台会话的时候都要实例化<code>SearchViewController</code>，此时就已经重新链接了。<br>&emsp;2.我们需要捕获代理方法提供的完成回调block，调用完成回调block使系统把更新的UI快照显示在app切换器上，同时，告诉系统关于当前会话的所有后台活动都已经完成。   </p><p>但是，我们什么时候调用这个完成处理block呢？   </p><p><code>URLSessionDidFinishEventsForBackgroundURLSession(_:)</code>方法会是一个好的选择，它是<code>NSURLSessionDelegate</code>代理方法，当所有的后台会话完成的时候会被调用。    </p><p>在<code>SearchViewController.swift</code>中实现这个方法：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SearchViewController</span>: <span class="title">NSURLSessionDelegate</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">URLSessionDidFinishEventsForBackgroundURLSession</span><span class="params">(session: NSURLSession)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> appDelegate = <span class="type">UIApplication</span>.sharedApplication().delegate <span class="keyword">as</span>? <span class="type">AppDelegate</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> completionHandler = appDelegate.backgroundSessionCompletionHandler &#123;</span><br><span class="line">        appDelegate.backgroundSessionCompletionHandler = <span class="literal">nil</span></span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), &#123;</span><br><span class="line">          completionHandler()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码抓取了存在app delegate中的完成回调block，并且在主线程调用它。    </p><p>运行你的app。同时开始几个下载任务，然后按下<code>Home</code>键，使app在后台运行，等到你认为下载任务完成的时候，双击<code>Home</code>键，显示app切换器。   </p><p>下载任务应该已经完成了，并且可以在屏幕上看到新的关于下载完成的状态：<br><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2015/08/Simulator-Screen-Shot-19-Aug-2015-1.06.24-am-281x500.png" alt=""><br>现在，你拥有了一个完整功能的音乐流媒体app，移动的<code>Apple Music</code>！:]   </p><h2 id="接下来该做什么"><a href="#接下来该做什么" class="headerlink" title="接下来该做什么"></a>接下来该做什么</h2><p>你可以在<a href="http://www.raywenderlich.com/wp-content/uploads/2016/01/HalfTunes-Final.zip" target="_blank" rel="noopener">这里</a>下载本教程完整的项目。   </p><p>恭喜，你现在可以很好的处理你的app中一般网络请求，当然还有很多比本教程更详细的<code>NSURLSession</code>应用，比如，上传任务，设置会话的配置（超时，缓存策略等）。   </p><p>通过如下资源学习更多的特性吧：<br><em>Apple的<a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSession_class/" target="_blank" rel="noopener">官方文档</a>包含了所有API提供的方法的详细信息。     </em>我们自己的书：<a href="http://www.raywenderlich.com/store/ios-7-by-tutorials" target="_blank" rel="noopener">iOS7教程</a>，其中包含了两个章节专门讲解<code>NSURLSession</code>，你也可以阅读我们的<a href="http://www.raywenderlich.com/51127/nsurlsession-tutorial" target="_blank" rel="noopener">NSURLSession教程</a>。<br>*<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">AlamoFire</a>也是非常流行的第三方网络库，我们在<a href="http://www.raywenderlich.com/85080/beginning-alamofire-tutorial" target="_blank" rel="noopener">Begining AlamoFire</a>教程中讲解了它的基础内容。   </p><p>希望这篇教程能对你有用，参与下方讨论吧！    </p><hr><p>译者注：欢迎转载，但请一定要注明出处！谢谢！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文翻译自 &lt;a href=&quot;https://www.raywenderlich.com/110458/nsurlsession-tutorial-getting-started&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.ray
      
    
    </summary>
    
    
      <category term="iOS API 详解" scheme="http://yoursite.com/tags/iOS-API-%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
</feed>
