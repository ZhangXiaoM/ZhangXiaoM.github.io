<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 从runtime源码解析消息发送的动态性 · zmc的技术博客</title><meta name="description" content="从runtime源码解析消息发送的动态性 - zmc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="zmc的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ZhangXiaoM" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">从runtime源码解析消息发送的动态性</h1><div class="post-info">Jan 20, 2018</div><div class="post-content"><h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>本文不是对runtime的使用的简单的阐述，而是我对runtime中消息发送的一些更深层的理解。</p>
<p>不要相信任何博客或者文章，apple 的 opensource 源代码会告诉我们想知道的一切，所以善用源码可能会事半功倍。</p>
<h2 id="一、结构体-vs-类"><a href="#一、结构体-vs-类" class="headerlink" title="一、结构体 vs 类"></a>一、结构体 vs 类</h2><p>我们知道，OC 是 C 语言的超集，是对 C 和 C++ 的进一步封装，一开始学习 OC 这门语言的时候，我们就被灌输过一句话：对象存储在堆内存，变量存储在栈内存，而 runtime 告诉我们类是对 C 和 C++ 中结构体的封装，而结构体是值类型（<a href="https://zhangxiaom.github.io/2018/01/02/%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%9C%A8Swift%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">值类型 vs 引用类型</a>），肯定是存储在栈上的，这不是自相矛盾吗？另外，OC1.0 是完全对 C 语言的封装，C 语言的结构体是不能声明和实现函数的，到底是怎么回事呢？现在我们用结构体实现一个简单的类：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="comment">// 声明一个指针变量 sum，它的类型为具有一个 int 类型返回值，两个 int 类型参数的函数。</span></span><br><span class="line">    <span class="keyword">int</span>(*sum)(<span class="keyword">int</span>,<span class="keyword">int</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Foo</span>* <span class="title">PFoo</span>;</span> <span class="comment">// PFoo 为一个指向 Foo 结构体的指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个指针指向 Foo 结构体，PFoo就是引用类型，pFoo 就是分配在栈内存的变量</span></span><br><span class="line">    PFoo pFoo; </span><br><span class="line">    <span class="comment">// 相当于 OC 中的alloc，将实例存入堆内存，现在 pFoo 就指向（引用）一个堆内</span></span><br><span class="line">    <span class="comment">// 存的实例</span></span><br><span class="line">    pFoo = (PFoo)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PFoo));</span><br><span class="line">    <span class="comment">// init 初始化操作</span></span><br><span class="line">    pFoo -&gt; val = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 将函数 sum() 赋值给 pFoo 的成员变量 sum</span></span><br><span class="line">    pFoo -&gt; sum = sum;</span><br><span class="line">    <span class="comment">// use</span></span><br><span class="line">    <span class="comment">// 通过函数指针调用函数，pFoo -&gt; sum 是一个指向函数sum的指针</span></span><br><span class="line">    <span class="keyword">int</span> result = (pFoo -&gt; sum)(<span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, result);</span><br><span class="line">    <span class="comment">// print "result = 9"</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="built_in">free</span>(pFoo);</span><br><span class="line">    <span class="comment">// 将 pFoo 设置为空指针</span></span><br><span class="line">    pFoo = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述的代码就是用结构体实现一个简单的类，其实真正的runtime对类的实现比这个要复杂的多的多，函数的调用也不是简单的通过函数指针的成员变量调用，说这个只是想引入一下函数指针对类的意义以及值类型和引用类型的关系。</p>
<h2 id="二、OC-消息发送的动态性"><a href="#二、OC-消息发送的动态性" class="headerlink" title="二、OC 消息发送的动态性"></a>二、OC 消息发送的动态性</h2><h3 id="1-动态性"><a href="#1-动态性" class="headerlink" title="1. 动态性"></a>1. 动态性</h3><p>提及 OC 及 runtime，我们听到最多的一句话就是 OC 是一门动态类型的语言，所谓的动态和静态的区分主要是指程序的执行是依赖于编译期还是运行期。</p>
<p>如果一段程序的执行在编译结束后就决定了它的内存分配，那么我们就可以说它是个静态类型的语言，而 OC 的动态性在于，它在编译期只是进行简单的语义语法检查，而不会分配内存。它在编译期只关心某个类型的某个对象能不能调用某个方法，而不会关心这个对象是不是 <code>nil</code>，也不会关心这个方法的实现细节，甚至不关心到底有没有这个方法，这些事都是运行期才会去做的事。</p>
<p>这就决定了我们可以在运行期对我们的程序做更多的更改，当然也存在很多弊端，有句话说得好：“动态类型一时爽，代码重构火葬场”，运行期分配内存确实会让我们的程序出现很多运行时的错误，比如，访问了野指针、内存泄漏等等，确实会给程序带来很多灾难性的bug，甚至于必须重构代码才能解决。</p>
<p>因此，对运行时的充分了解能使我们尽最大可能的规避这些错误，从而减少我们踩坑的几率和填坑的时间。</p>
<h3 id="2-消息发送的动态性"><a href="#2-消息发送的动态性" class="headerlink" title="2. 消息发送的动态性"></a>2. 消息发送的动态性</h3><p>举个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye, world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">(<span class="keyword">int</span> anyState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 函数的调用由编译时决定，函数的汇编指令是硬编码</span></span><br><span class="line">    <span class="keyword">if</span> (anyState) &#123;</span><br><span class="line">        hello();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        bye();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码是一段简单的C语言代码，不管会不会 C 语言，应该都能看得懂，当调用 <code>doSomeThing()</code> 的时候，不管 <code>if</code> 条件是不是成立，程序都会将 <code>hello()</code> 和 <code>bye()</code> 这两个函数的汇编指令硬编码进汇编指令集。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/3/160ba89f6a138776?w=357&amp;h=130&amp;f=png&amp;s=812" alt=""></p>
<p>假设 <code>hello()</code> 和 <code>bye()</code> 这两个函数在代码区中的存储为上图，则在 <code>doSomeThing()</code> 中，编译器会在编译期，在 <code>if</code> 和 <code>else</code> 中都会将这两块内存生成的汇编指令硬编码进汇编指令集。类似于：<br><img src="https://user-gold-cdn.xitu.io/2018/1/3/160ba950601b8af2?w=142&amp;h=386&amp;f=png&amp;s=5963" alt=""><br>这就是一种静态的调用函数的方式，而动态的调用方法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bye</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Goodbye, world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomeThing</span><span class="params">(<span class="keyword">int</span> anyState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译时只获取函数的地址，运行时才发出指令，执行函数</span></span><br><span class="line">    <span class="keyword">void</span> (*func)();</span><br><span class="line">    <span class="keyword">if</span> (anyState) &#123;</span><br><span class="line">        func = hello;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        func = bye;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码和上述代码的差异为，在 <code>if</code> 条件语句中调用函数的方式变成了函数指针而不是简单的函数调用。它的动态性体现在，编译器在编译期仅仅获取函数的首地址，将指向函数的首地址硬编码进汇编指令集，而不是将整个函数的指令全部硬编码，到运行时再去决定调用那个函数（访问哪个函数的内存）。如果你在运行时强制将这个本来指向某个函数的指针指向另一个函数，那么这就是所谓的方法交换。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/3/160baa595f67d978?w=397&amp;h=302&amp;f=png&amp;s=11045" alt=""></p>
<p>这就是所谓的调用函数的动态性。OC 这门语言就是采用这种函数指针的方式实现消息发送的动态性。当然也不可能实现的这么简单。</p>
<p>真正的汇编指令集肯定不可能这么简单，只是简单画了一下，更容易理解一点。</p>
<h2 id="三、将方法存储到类"><a href="#三、将方法存储到类" class="headerlink" title="三、将方法存储到类"></a>三、将方法存储到类</h2><p>OC 的动态性并不仅仅体现在消息发送方面，还有其他的，比如，运行时添加属性、添加成员变量、消息转发等等，其实对属性、变量和方法的封装大同小异，这里仅分析了 runtime 对消息的存储和获取。</p>
<p>大家都知道的一件事就是，OC 中类的实质是结构体，结构体中存储了所有的成员方法列表、属性列表、协议列表等等。存储结构如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/3/160baf94d0a49b21?w=828&amp;h=563&amp;f=png&amp;s=51340" alt=""></p>
<p>可以看到一个 <code>method_array_t</code> 类型的变量 <code>methods</code>，这就是类中的方法列表，<code>method_array_t</code> 是一个类，所以 <code>methods</code> 指向一个类实例，它在runtime中的组成为：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/3/160bb0fb7806de8b?w=1034&amp;h=344&amp;f=png&amp;s=31137" alt=""></p>
<p>可以看到，方法列表最终存储的东西为 <code>method_t</code> 结构体，它有三个成员变量，一个 <code>name</code>，可以理解为方法的签名，OC 会通过方法签名去列表中查找某个方法的实现，runtime 对它的定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/// An opaque type that represents a method selector.</span><br><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>
<p>可以看出这是一个指针类型，指向 <code>objc_selector</code> 结构体。另一个成员为：<code>const char *types</code> 常量为 OC 运行时方法的 typeEncoding 集合，它指定了方法的参数类型以及在函数调用时参数入栈所要的内存空间，没有这个标识就无法动态的压入参数 <a href="https://user-gold-cdn.xitu.io/2018/1/3/160bb2b1fa08761a" target="_blank" rel="noopener">Type Encoding</a>。</p>
<p>而 <code>IMP imp</code> 就是一个指向函数的函数指针，就是一个指向方法的首地址的指针。<code>IMP</code> 类型被定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A pointer to the function of a method implementation. </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !OBJC_OLD_DISPATCH_PROTOTYPES</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*IMP)</span><span class="params">(<span class="keyword">void</span> <span class="comment">/* id, SEL, ... */</span> )</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">id</span> <span class="params">(*IMP)</span><span class="params">(id, SEL, ...)</span></span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>可以看出这也是一个指针类型，指向一个函数，即函数指针。当我们向对象的方法列表添加方法的时候，会调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">class_addMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">    <span class="keyword">return</span> ! addMethod(cls, name, imp, types ?: <span class="string">""</span>, NO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>addMethod()</code> 会返回一个 <code>IMP</code> 类型的函数指针，这个函数会将传入的 <code>imp</code> 添加进类的函数列表，并且更新缓存，最后返回这个 <code>imp</code>。如果 <code>addMethod()</code> 方法返回为空指针，则添加失败，返回 <code>false</code>。<code>addMethod()</code> 方法的具体实现细节为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> IMP </span><br><span class="line">addMethod(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types, <span class="keyword">bool</span> replace)</span><br><span class="line">&#123;</span><br><span class="line">    IMP result = nil;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    runtimeLock.assertWriting();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    assert(types);</span><br><span class="line">    assert(cls-&gt;isRealized());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">method_t</span> *m;</span><br><span class="line">    <span class="keyword">if</span> ((m = getMethodNoSuper_nolock(cls, name))) &#123;</span><br><span class="line">        <span class="comment">// already exists  </span></span><br><span class="line">        <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">            result = m-&gt;imp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = _method_setImplementation(cls, m, imp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fixme optimize</span></span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">method_list_t</span> *newlist;</span><br><span class="line">        newlist = (<span class="keyword">method_list_t</span> *)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(*newlist), <span class="number">1</span>);</span><br><span class="line">        newlist-&gt;entsizeAndFlags = </span><br><span class="line">            (<span class="keyword">uint32_t</span>)<span class="keyword">sizeof</span>(<span class="keyword">method_t</span>) | fixed_up_method_list;</span><br><span class="line">        newlist-&gt;count = <span class="number">1</span>;</span><br><span class="line">        newlist-&gt;first.name = name;</span><br><span class="line">        newlist-&gt;first.types = strdupIfMutable(types);</span><br><span class="line">        newlist-&gt;first.imp = imp;</span><br><span class="line"></span><br><span class="line">        prepareMethodLists(cls, &amp;newlist, <span class="number">1</span>, NO, NO);</span><br><span class="line">        cls-&gt;data()-&gt;methods.attachLists(&amp;newlist, <span class="number">1</span>);</span><br><span class="line">        flushCaches(cls);</span><br><span class="line"></span><br><span class="line">        result = nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释顺序：</p>
<p>1、加写入锁。</p>
<p>2、检查类型，检查类是否实现。</p>
<p>3、声明一个指针变量，指向 <code>method_t</code> 结构体，判断方法是否已经存在。</p>
<p>4、如果方法已经存在，判断是替换方法还是添加方法，如果不是替换，直接返回已经存在的方法的实现，如果是替换，则直接覆盖原方法。</p>
<p>5、如果方法不存在，则将其添加进入方法列表。</p>
<p>更具体的实现：<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">runtime</a>，可以下载最新的 runtime 源码查看。</p>
<h2 id="四、从类中查找方法"><a href="#四、从类中查找方法" class="headerlink" title="四、从类中查找方法"></a>四、从类中查找方法</h2><p>当我们向对象发送消息的时候：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = [obj doSomeThingWithParams:params];</span><br></pre></td></tr></table></figure>
<p>编译器会将它编译成原型为：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL cmd, ...);</span><br></pre></td></tr></table></figure>
<p>的 C 函数。所以上面的函数会被翻译成：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> returnValue = objc_msgSend(obj, <span class="keyword">@selector</span>(doSomeThingWithParams:), params);</span><br></pre></td></tr></table></figure>
<p>这是一个标准的 C 函数，而且知道运行时的 iOS 开发者大部分都对它有所了解。我们来看一下，runtime 如何通过这个函数实现 <code>doSomeThingWithParams</code> 这个方法的调用。</p>
<p>当我们使用 <code>objc_msgSend()</code> 调用函数时，函数的调用栈为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 lookUpImpOrForward</span><br><span class="line">1 _class_lookupMethodAndLoadCache3</span><br><span class="line">2 objc_msgSend</span><br><span class="line">3 main</span><br><span class="line">4 start</span><br></pre></td></tr></table></figure>
<p>可以看到在调用了 <code>objc_msgSend</code> 之后，调用了 <code>class_lookupMethodAndLoadCache3</code> 这个函数，这个函数名的字面意思为：从类中查找方法并且加载缓存。这个函数的实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就调用了一个函数 <code>lookUpImpOrForward()</code>，这个函数名的字面意思是：查找 <code>imp</code> 或者转发，可以看出来，这个方法应该就是从方法列表中查找函数指针的那个方法了。它的实现为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* lookUpImpOrForward.</span></span><br><span class="line"><span class="comment">* The standard IMP lookup. </span></span><br><span class="line"><span class="comment">* initialize==NO tries to avoid +initialize (but sometimes fails)</span></span><br><span class="line"><span class="comment">* cache==NO skips optimistic unlocked lookup (but uses cache elsewhere)</span></span><br><span class="line"><span class="comment">* Most callers should use initialize==YES and cache==YES.</span></span><br><span class="line"><span class="comment">* inst is an instance of cls or a subclass thereof, or nil if none is known. </span></span><br><span class="line"><span class="comment">*   If cls is an un-initialized metaclass then a non-nil inst is faster.</span></span><br><span class="line"><span class="comment">* May return _objc_msgForward_impcache. IMPs destined for external use </span></span><br><span class="line"><span class="comment">*   must be converted to _objc_msgForward or _objc_msgForward_stret.</span></span><br><span class="line"><span class="comment">*   If you don't want forwarding at all, use lookUpImpOrNil() instead.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class curClass;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    Method meth;</span><br><span class="line">    <span class="keyword">bool</span> triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">        <span class="comment">// If sel == initialize, _class_initialize will send +initialize and </span></span><br><span class="line">        <span class="comment">// then the messenger will send +initialize again after this </span></span><br><span class="line">        <span class="comment">// procedure finishes. Of course, if this is not being called </span></span><br><span class="line">        <span class="comment">// from the messenger then it won't happen. 2778172</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The lock is held to make method-lookup + cache-fill atomic </span></span><br><span class="line">    <span class="comment">// with respect to method addition. Otherwise, a category could </span></span><br><span class="line">    <span class="comment">// be added but ignored indefinitely because the cache was re-filled </span></span><br><span class="line">    <span class="comment">// with the old value after the cache flush on behalf of the category.</span></span><br><span class="line"> retry:</span><br><span class="line">    runtimeLock.read();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try this class's cache.</span></span><br><span class="line"></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try this class's method lists.</span></span><br><span class="line"></span><br><span class="line">    meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">        imp = meth-&gt;imp;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try superclass caches and method lists.</span></span><br><span class="line"></span><br><span class="line">    curClass = cls;</span><br><span class="line">    <span class="keyword">while</span> ((curClass = curClass-&gt;superclass)) &#123;</span><br><span class="line">        <span class="comment">// Superclass cache.</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                <span class="comment">// Found the method in a superclass. Cache it in this class.</span></span><br><span class="line">                log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Found a forward:: entry in a superclass.</span></span><br><span class="line">                <span class="comment">// Stop searching, but don't cache yet; call method </span></span><br><span class="line">                <span class="comment">// resolver for this class first.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Superclass method list.</span></span><br><span class="line">        meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found. Try method resolver once.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        <span class="comment">// Don't cache the result; we don't hold the lock so it may have </span></span><br><span class="line">        <span class="comment">// changed already. Re-do the search from scratch instead.</span></span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码中给的注释很清楚，先从优化缓存中查找 <code>imp</code>，如果有直接返回，如果没有，先判断类是否实现，如果没有就去实现类，然后判断类是否初始化，如果没有就去初始化，再然后去类中的缓存列表中查找，找到就返回，如果没找到，再去父类的缓存和父类的方法列表中查找，找到就返回，如果还是没有，则允许一次 <code>resolve</code>，如果还是没有，则进入消息转发。</p>
<p>然后就可以使用返回的 <code>imp</code> 和汇编指令完成方法的调用了。对汇编精通的可以参考源码中的 <code>objc-msg</code> 模块查看汇编指令对 <code>imp</code> 的使用。</p>
<h4 id="One-More-Thing"><a href="#One-More-Thing" class="headerlink" title="One More Thing"></a>One More Thing</h4><p>runtime 是 objc 的核心动态库，基本涵盖了程序运行之后发生的一切，如果真正想学习它的编程思想的话，还请阅读源码，博客仅有参考和记录的意义，况且还有一些内容为一家之言，不可尽信。源码会告诉我们一切哦。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/02/09/类和元类/" class="prev">上一篇</a><a href="/2018/01/02/适配iPhoneX &amp; iOS11/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">zmc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>