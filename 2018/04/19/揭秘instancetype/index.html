<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 揭秘instancetype · zmc的技术博客</title><meta name="description" content="揭秘instancetype - zmc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="zmc的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ZhangXiaoM" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">揭秘instancetype</h1><div class="post-info">Apr 19, 2018</div><div class="post-content"><p>苹果官方会建议我们用 <code>instancetype</code> 类型代替 <code>id</code> 类型作为某个类的初始化方法的返回值。以下内容摘自<a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/ModernizationObjC/AdoptingModernObjective-C/AdoptingModernObjective-C.html#//apple_ref/doc/uid/TP40014150-CH1-SW11" target="_blank" rel="noopener">Adopting Modern Objective-C</a>:</p>
<blockquote>
<p>Use the instancetype keyword as the return type of methods that return an instance of the class they are called on (or a subclass of that class). These methods include alloc, init, and class factory methods.</p>
</blockquote>
<h3 id="一、初始化方法为什么用id类型而不是-类名-类型作为返回值类型"><a href="#一、初始化方法为什么用id类型而不是-类名-类型作为返回值类型" class="headerlink" title="一、初始化方法为什么用id类型而不是 [类名] 类型作为返回值类型"></a>一、初始化方法为什么用id类型而不是 [类名] 类型作为返回值类型</h3><p>在 <code>instancetype</code> 关键字出现之前，我们会用 <code>id</code> 作为类初始化方法的返回类型，在 <code>instancetype</code> 关键字出现之后，编译器会主动将 <code>alloc</code> <code>init</code> <code>new</code> 开头的方法的返回值类型替换为 <code>instancetype</code>， 那么在 <code>instancetype</code> 出现之前，为什么不用该类自身的类型而是用 <code>id</code> 类型作为初始化方法的返回值。答案是 OC 的类继承体系。</p>
<p>假如，有一个类 <code>SuperClass</code>的初始化方法返回类型为它自己的类型，并且不会被编译器替换为 <code>instancetype</code> ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (SuperClass *)init;</span><br></pre></td></tr></table></figure>
<p>那么当它的子类重写这个初始化方法的时候，只能返回它自身的实例，而无法返回子类的实例。因为重写父类方法， 必须和被重写的方法有相同的返回类型。所以子类永远无法通过重写这个父类初始化方法初始化自身。所以为了实现重写初始化方法（用父类初始化自身）的继承体系，必须要用一种通用类型，既能表述子类实例也能表述父类实例的类型，刚好 <code>NSObject</code> 是所有类的根类，由于 OC 的多态性，<code>id</code> 类型的变量可以指向任意类型的对象，因此，用 <code>id</code> 类型作为初始化方法的返回类型可以很好的解决类继承的问题。</p>
<h3 id="二、instancetype-取代-id"><a href="#二、instancetype-取代-id" class="headerlink" title="二、instancetype 取代 id"></a>二、instancetype 取代 id</h3><p>有的人会认为 <code>instancetype</code>类型和 <code>id</code> 类型是一种类型的不同表达方式，其实并不是。 <code>instancetype</code> 顾名思义是当前类的实例类型，听起来好像和类名类型并没有上面区别，实则，它更严谨的遵循 OC 的继承体系。<code>instancetype</code> 类型只表述当前类的继承线，例如 <code>NSMutableString -&gt; NSString -&gt;...-&gt; NSObject</code>，而 <code>id</code> 类型相对来说更博爱一点。</p>
<p>在适当的地方使用 <code>instancetype</code> 关键字可以提高代码的类型安全。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface MyObject : <span class="built_in">NSObject</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)factoryMethodA;</span><br><span class="line">+ (<span class="keyword">id</span>)factoryMethodB;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)factoryMethodA &#123; <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init]; &#125;</span><br><span class="line">+ (<span class="keyword">id</span>)factoryMethodB &#123; <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init]; &#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> x, y;</span><br><span class="line"> </span><br><span class="line">    x = [[MyObject factoryMethodA] count]; <span class="comment">// Return type of +factoryMethodA is taken to be "MyObject *"</span></span><br><span class="line">    y = [[MyObject factoryMethodB] count]; <span class="comment">// Return type of +factoryMethodB is "id"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类 <code>MyObject</code> 声明并实现了两个相同类工厂方法，用来返回初始化后的 <code>MyObject</code> 对象，只是返回的类型一个是 <code>instancetype</code>，一个是 <code>id</code>。编译器在代码 <code>y</code> 处不会提示任何警告和错误，并且在编译期也没有任何错误，但是当到了运行期就会崩溃。因为此时的 <code>MyObject</code> 实例可能是任意一个类的实例，只要某个类中有 <code>-count</code> 这个方法存在，那么编译器就会认为返回的实例可能是这个有 <code>-count</code> 方法的类，所以它不会报错。但是，当运行期去 <code>MyObject</code> 类中查找这个方法的时候，才会出现找不到这个方法并且发送和转发失败的crash。关于<a href="https://juejin.im/post/5a4c40a35188257d1718e447" target="_blank" rel="noopener">运行时</a>。</p>
<p>而代码 <code>y</code> 处，该类工厂方法返回的是 <code>instancetype</code> 类型，该类型即为 <code>MyObject</code> 类型，编译器会去它和它的父类中去寻找调用的方法，如果找不到那么就会报错，并且编译失败。</p>
<p>因此，<code>instancetype</code> 类型比 <code>id</code> 类型有更好的类型安全性，让隐患和错误的暴露提前到代码的编写期，避免了应用的运行时crash。</p>
<h3 id="三、类工厂方法使用-self-class-实例化而不是类名"><a href="#三、类工厂方法使用-self-class-实例化而不是类名" class="headerlink" title="三、类工厂方法使用[self class]实例化而不是类名"></a>三、类工厂方法使用[self class]实例化而不是类名</h3><p>例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SuperClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)factor;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SuperClass</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)factor &#123;</span><br><span class="line">    <span class="keyword">return</span> [[SuperClass alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>由于类的继承体系，子类也可以调用父类方法，当子类调用父类的这个类工厂方法初始化自身的时候，实际上返回的实例还是父类的实例，而不是子类自身的实例，但是编译器没有办法判断这些，因为它根据类继承体系找到了正确的方法。当向此实例发送子类的消息的时候，会在运行时crash，因为它会从父类实例方法列表中查找这个子类的方法，然而父类并没有这个方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([[SubClass factor] <span class="keyword">class</span>]));</span><br><span class="line"><span class="comment">// log: SuperClass</span></span><br></pre></td></tr></table></figure>
<p>因此，当我们用类工厂方法初始化自身的时候，一定要用 <code>[self class]</code> 实例化自身，而不是类名：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)factor &#123;</span><br><span class="line">    <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子类就可以通过调用这个父类的类工厂方法初始化自己：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="built_in">NSStringFromClass</span>([[SubClass factor] <span class="keyword">class</span>]));</span><br><span class="line"><span class="comment">// log: SubClass</span></span><br></pre></td></tr></table></figure>
<h3 id="四、单例返回类型用类名"><a href="#四、单例返回类型用类名" class="headerlink" title="四、单例返回类型用类名"></a>四、单例返回类型用类名</h3><p>某种程度上来说，单例的初始化方法也是一个类工厂方法，单例使用【类名】类型，而不是 <code>instancetype</code> 的原因是：一般情况下，不会有其他类继承自单例类，因此，单例类在初始化的时候不用考虑对其子类的影响，因此单例类可以肆无忌惮的使用类名类型作为初始化方法的返回值类型。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/05/31/从源码分析block的底层实现/" class="prev">PREV</a><a href="/2018/03/23/哈希表/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">zmc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>