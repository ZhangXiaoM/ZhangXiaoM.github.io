<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 类和元类 · zmc的技术博客</title><meta name="description" content="类和元类 - zmc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="zmc的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ZhangXiaoM" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">类和元类</h1><div class="post-info">Feb 9, 2018</div><div class="post-content"><p><img src="https://user-gold-cdn.xitu.io/2018/1/9/160d9b1f81329645?w=596&amp;h=620&amp;f=png&amp;s=74424" alt=""></p>
<p>Objective-C 是一门基于类的对象系统，每一个对象都是某个类的实例；对象的 <code>isa</code> 指针指向它的类。该类描述对象的一些信息：数据占用的空间，变量的类型和布局等。该类也描述对象的一些行为：对象可以响应的选择器（<code>selector</code>）和对象实现的实例方法。</p>
<p>（注：面向对象的含义，类是一类事物的共有特性的描述，比如：“人”类中的“姓名”，“年龄”等属性，“吃饭”、“喝水”等行为，所有的人都具备，所以类是对象的属性和行为的描述）</p>
<p>类中的方法列表是实例方法（对象可以响应的选择子）的集合。当你向对象发送一个消息的时候，<code>objc_msgSend()</code> 会通过查询该对象的类（和父类）中的方法列表来决定调用什么方法。</p>
<p>每一个 Objective-C 的类也是一个对象。它也有自己的 <code>isa</code> 指针、数据以及它可以响应的选择子。当你调用一个类方法的时候，例如 <code>[NSObject alloc]</code>，实际上你是向这个类对象（<code>NSObject</code>）发送了一条消息。</p>
<p>由于类也是对象，那么它一定也是某一个类的实例，即元类。就像类是普通对象的描述一样，元类是类对象的描述。值得一提的是，元类的方法列表中存的是类方法：类对象可以响应的选择子。当你向一个类对象（元类的实例）发送消息（调用类方法）的时候，<code>objc_msgSend()</code> 会通过查询该类对象的元类（和父元类）中的方法列表来决定调用什么方法。就像实例方法是类对对象的行为的描述一样，类方法是元类对类对象的行为的描述（有点拗口）。</p>
<p>那么元类呢？是最底层的吗？不，元类是根类（<code>NSObject</code>）的元类的实例，根元类是根元类自己的实例，<code>isa</code> 指针链在一个循环处结束：对象 -&gt; 类对象 -&gt; 元类 -&gt; 根元类 -&gt; 根元类自身（-&gt; 指向）。元类的 <code>isa</code> 指针的行为很少受到关注，因为在现实中没有人可以向元类对象发送消息。</p>
<p>那么元类的父类是谁呢？元类的父类链平行于类的父类链，所以类方法的继承关系和实例方法是一样的。并且根元类的父类是根类（即，<code>NSObject</code> 的元类的父类是它自己）（划重点），所以每一个类对象都可以响应根类的实例方法（即，根类的实例方法其实也是每一个类的类方法）。所以，类对象也和其他对象一样，都是根类的实例，但是类对象也是根类的子类。</p>
<p>是不是很迷惑，上面这张图可以帮助到你！请记住，当你向一个对象发消息的时候，方法的查找会从对象的 <code>isa</code> 指针开始，然后继续顺着父类链查找。“实例方法”在类中定义，“类方法”在元类和根类中定义。</p>
<p>（注：方法列表中并没有什么值来规定某一个方法是类方法还是实例方法，一个对象能通过 <code>isa</code> 指针和父类链找到的那个方法就是它能响应的方法，所以，类对象可以通过根元类的父类指针找到根类中的方法，那么它就可以响应这个方法，即使你认为根类中存的应该是“实例方法”。）</p>
<p>在正式的计算机科学语言中，类和元类的继承制度是更自由的形式，比如，更深层的元类链和很多类是某单一元类的实例。OC相对于 使用元类实现像类方法这样的实际目标，更趋向于隐藏元类。例如： 其实 <code>[NSObject class]</code> 和 <code>[NSObejct self]</code> 是等价的，即使，理论上它应该返回 <code>NSObject -&gt; isa</code> 指向的的元类。 </p>
<p>本文参考苹果公司 <code>runtime</code> 源码的维护者 <em>Greg Parker</em> 的 blog: <a href="https://user-gold-cdn.xitu.io/2018/1/9/160d9b3483b97e0b" target="_blank" rel="noopener">[objc explain]: Classes and metaclasses</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/23/哈希表/" class="prev">PREV</a><a href="/2018/01/20/从runtime源码解析消息发送的动态性/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">zmc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>