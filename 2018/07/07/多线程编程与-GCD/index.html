<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 多线程编程与 GCD · zmc的技术博客</title><meta name="description" content="多线程编程与 GCD - zmc"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.jpeg"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="zmc的技术博客"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.jpeg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ZhangXiaoM" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">多线程编程与 GCD</h1><div class="post-info">Jul 7, 2018</div><div class="post-content"><p>如果你还不了解进程的话，请参考：<a href="https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">并发编程之进程</a>，进程是由完整的逻辑控制流和独立的地址空间构成的，一个线程就是进程中一个单一顺序的逻辑控制流，由进程调度的线程被称为用户级线程，由内核调度的被称为内核线程（轻量级进程），这里仅讨论用户级线程。多个进程可以被操作系统调度而组成多进程程序，同样的，多个线程也可以被进程调度而组成多线程编程，同一进程的多个线程共享该进程的地址空间，也就是整个进程的虚拟内存都是该进程内所有线程的共享内存。</p>
<h3 id="一、几个概念"><a href="#一、几个概念" class="headerlink" title="一、几个概念"></a>一、几个概念</h3><h4 id="1-1-同步-vs-异步"><a href="#1-1-同步-vs-异步" class="headerlink" title="1.1 同步 vs 异步"></a>1.1 同步 vs 异步</h4><p>同步和异步的概念是针对指令，不针对线程，也就是仅用主线程也能进行异步操作，所以异步的并不一定是多线程的，同步的指令也不一定只是主线程执行的。假如将一个同步或者异步任务视为一个指令集的话，执行同步任务的线程会等待该指令集执行完再去执行该指令集的下一条指令，而异步任务会直接跳过当前指令集去执行下一条指令，当执行该指令集的线程空闲的时候才会执行该指令集。所以异步任务不会阻塞当前线程。</p>
<h4 id="1-2-并发-vs-并行"><a href="#1-2-并发-vs-并行" class="headerlink" title="1.2 并发 vs 并行"></a>1.2 并发 vs 并行</h4><p>这两个概念是很多人比较容易混淆的概念，有人会说并发是并行的子集，只要是并行的，一定是并发的，但是并发的不一定是并行的，因为牵扯到线程调度（单核 CPU 的情况下，多个线程交替使用 CPU）的问题。那么有个问题请思考一下，假设我们的程序运行在一个四核 CPU 的设备上，也就是此时操作系统是支持并行的，但是我们设计的程序仅仅使用的主线程，比如说打印了一个 Hello world，那么此时能说并行的一定是并发的吗？</p>
<p>其实这两个概念相关联但是又不是那么关联，并行表述的是能力，并发表述的是程序结构，也就是具有双核以上 CPU 的系统具有并行的能力，我们写的代码是支持并发的程序结构。在具有并行能力的系统上执行的并发结构的程序一定是并发的，即使在不具有并行能力的系统（单核）上执行的并发结构的程序仍然是并发的。</p>
<h4 id="1-3-线程-vs-队列"><a href="#1-3-线程-vs-队列" class="headerlink" title="1.3 线程 vs 队列"></a>1.3 线程 vs 队列</h4><p>对 iOS 来说，特别是习惯使用 GCD 的开发者，线程和队列也是需要区分的概念，队列和线程本质上并不是一一对应的关系（其实主线程不一定只执行主队列的指令）。GCD 会为我们的程序提供几种类型的队列（主队列，全局并发队列，串行队列，并发队列），我们只需要将任务以同步或者异步的形式添加进队列，GCD 会调度需要的线程帮我们依次执行队列中的任务。</p>
<h4 id="1-4-context（上下文）"><a href="#1-4-context（上下文）" class="headerlink" title="1.4 context（上下文）"></a>1.4 context（上下文）</h4><p><strong>context</strong> 一般被翻译为上下文，是一个抽象的概念，在 iOS 中也经常出现（CGContext），其实我们可以将它理解为一个作为数据模型的结构体，它保存了当前对象此时所有的状态信息，比如要绘制一个 <code>UILabel</code>，此时绘制对象的 <code>context</code> 里就会保存我们为 <code>UILabel</code> 设置的信息，比如背景颜色、字体、字号等等，然后负责绘制的对象会从 <code>context</code> 中取出这些属性完成绘制。对进程和线程来说是一样的，当进程被抢占时，它的 <code>context</code> 中就会保存进程此时的状态信息，等进程重新进入运行状态时，调度程序就会将进程信息恢复。</p>
<h3 id="二、线程调度"><a href="#二、线程调度" class="headerlink" title="二、线程调度"></a>二、线程调度</h3><p>和进程一样，线程也有一个上下文保存它当前执行的状态信息，比如堆栈信息、PC、寄存器等等，当该线程被抢占挂起时，上下文就会保存此时线程执行的栈帧、寄存器状态等等，线程的调度也被称为<strong>上下文切换</strong>。就像进程一样，线程也是交替使用 CPU 的，因为对于交互式程序来说，runloop 的存在就造成主线程一直占有 CPU 资源，线程的调度可以避免其他子线程<strong>饿死</strong>。</p>
<p>当多进程和多线程共存的情况下，对于线程的调度就分为两种情况。</p>
<ul>
<li><p>由进程调度</p>
<p>调度程序将时间片分配给进程，进程通过调度算法将时间片分配给线程，此时线程的上下文切换由进程决定，比如一个进程得到 10 ms 的时间片，它会根据自身的调度算法将时间片分配给线程，等时间片用完，调度程序会将该进程挂起，进程内正在执行的线程也会挂起，进程会保存所有线程的上下文，这是用户级线程常用的调度方式。</p>
</li>
<li><p>由调度程序调度</p>
<p>调度程序负责调度线程，比如进程 A 和进程 B 分别有三个线程 A1, A2, A3, B1, B2, B3，调度程序分配 10ms 的时间片给线程 A1，10ms 过后分配 10ms 的时间片给 B1，此时既要切换进程的上下文，也要切换线程的上下文，因此，这种调度方式会带来更大的开销。线程的上下文由内核保存，一般来说，内核级线程会使用这种调度方式。</p>
</li>
</ul>
<p>图示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5314152-ebe04302a61f6c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="三、线程同步—锁"><a href="#三、线程同步—锁" class="headerlink" title="三、线程同步—锁"></a>三、线程同步—锁</h3><p>同一进程的多个线程会共享该进程的地址空间，比如数据段、文本段、堆等。当多个线程并发的访问同一块内存段时，就会产生竞态条件导致的线程安全问题。锁就是为了解决这些问题，也填一下<a href="https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">并发编程之进程</a>里进程同步问题留下的坑。</p>
<p><strong>临界区：</strong></p>
<p>理解临界区的概念是解决线程安全和并发编程模型的重要依据。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5314152-efac21c2f2657b32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上图即为并发的情况下，临界区不安全的示例，T2 ~ T3 时间段 线程 A 和线程 B 同时访问临界区。我们可能会疑惑的地方是，单核 CPU 的系统中，存在这种并行的情况吗？其实即使在不支持并行的系统中，同样会有这种并发问题：在时间 T2，线程 A 的时间片用完，线程 A 挂起，此时 A 的上下文中记录它的执行状态，切换到线程 B 执行，线程 B 用完时间片记录执行状态，切换回线程 A，此时调度程序读取的线程 A 的执行状态为时间点 T2，因此此时相当于线程 A 回到时间点 T2 继续执行，直到下一次切换。所以我们可以把这种上下文切换的情况描述为上图中的<strong>并行</strong>，实则为<strong>并发</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量 _sum</span></span><br><span class="line"><span class="keyword">int</span> _sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 并发执行函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start %d\n"</span>, _sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        _sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum of 0 ~ 9999 is %d\n"</span>, _sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// insert code here...</span></span><br><span class="line">    <span class="comment">// 创建两个线程，执行 thr_fn</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> ntid;</span><br><span class="line">        pthread_create(&amp;ntid, <span class="literal">NULL</span>, thr_fn, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>log 的结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个结果不是唯一的，因为结果取决于线程切换的时机(竞态条件)</span></span><br><span class="line">start <span class="number">0</span></span><br><span class="line">start <span class="number">1021735</span></span><br><span class="line">sum of <span class="number">0</span> ~ <span class="number">9999</span> is <span class="number">46697501</span></span><br><span class="line">sum of <span class="number">0</span> ~ <span class="number">9999</span> is <span class="number">84364406</span></span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>我们可以计算得到 0~9999 的和为 49995000，因此两个子线程的执行的结果都不是我们想要的结果，其实上图很好的解释这段代码的执行过程，线程 B 迭代之前获取的初始值并不是我们想要的线程 A 的执行结果，是因为在时间点 T2，线程 B 读取的临界区的值为线程 A 的 T1 ~ T2 时间段的执行结果，此时我们得到的结果就是竞态条件造成的。</p>
<p>锁能帮助我们解决这个问题，当这段代码加锁后的执行过程为：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5314152-a6f1fe1e040563fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在时间 T2 线程 B 试图进入临界区时，由于临界区被加锁，所以线程 B 被阻塞，当线程 A 将临界区解锁后，线程 B 才能进入临界区。加锁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_fn</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"> 	pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start %d\n"</span>, _sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        _sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"sum of 0 ~ 10000 is %d\n"</span>, _sum);</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>log 结果：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start <span class="number">0</span></span><br><span class="line">sum of <span class="number">1</span> ~ <span class="number">10000</span> is <span class="number">49995000</span></span><br><span class="line">start <span class="number">49995000</span></span><br><span class="line">sum of <span class="number">1</span> ~ <span class="number">10000</span> is <span class="number">99990000</span></span><br><span class="line">Program ended with <span class="built_in">exit</span> code: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>互斥锁</p>
<p>上述例子中所使用的 <code>pthread_mutex_t</code> 即为互斥锁，互斥锁其实也是一个共享的全局变量，当该变量满足一定的条件时，允许线程访问临界区，否则该线程即被挂起。我们可以将该互斥锁想象成现实中的锁，锁的初始值的打开的，线程 A 进入房间（临界区）后，将锁锁住（时刻 T1），当线程 B 想进入房间时（时刻 T2），此时房间上锁，它只能挂起等待，直到线程 A 离开房间并且将锁打开（时刻 T3），线程 B 才能进入房间，并将锁锁住。</p>
</li>
<li><p>自旋锁</p>
<p>自旋锁是特殊的互斥锁，特殊的地方是，当线程访问锁变量时，会一直不停的询问锁变量的状态，也就是在 T2 时刻，线程 B 不会被阻塞而是一直不停（死循环）的访问锁变量，直到它的时间片被消耗完或者锁被打开。因此，互斥锁会在临界区加锁时马上进行上下文切换，而自旋锁会不停的死循环，因此自旋锁会消耗更多的 CPU 资源，在不确定临界区执行时间的前提下，慎用自旋锁。</p>
</li>
<li><p>信号量</p>
<p>互斥锁的概念标定了它只能有两种状态，就是加锁和未加锁，而信号量可以控制进入临界区的线程数量， 信号量被定义为一个正整数，当线程要进入临界区时，会首先访问信号量，当信号量大于 0 时，就代表可以进入临界区， 并将信号量减一，当信号量等于 0 时，线程就会被阻塞，当线程出了临界区时，会将信号量加一。</p>
</li>
<li><p>同步锁</p>
<p>同步锁是 objc 语言特有的一种锁，<code>@synchronized{}</code>，代码块中的内容即为临界区，它会被编译器替换为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源代码</span></span><br><span class="line">@synchronized&#123;</span><br><span class="line">    work();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译器替换后</span></span><br><span class="line">objc_sync_enter(obj);</span><br><span class="line">work();</span><br><span class="line">objc_sync_exit(obj);</span><br></pre></td></tr></table></figure>
<p>我们可以从 runtime 动态库中的 <code>&lt;objc/objc-sync.h&gt;</code>（<a href="https://opensource.apple.com/source/objc4/objc4-646/runtime/objc-sync.h" target="_blank" rel="noopener">在这</a>）中找到这两个方法的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Begin synchronizing on 'obj'.  </span></span><br><span class="line"><span class="comment"> * Allocates recursive pthread_mutex associated with 'obj' if needed.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param obj The object to begin synchronizing on.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return OBJC_SYNC_SUCCESS once lock is acquired.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">OBJC_EXPORT  <span class="keyword">int</span> <span class="title">objc_sync_enter</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    <span class="title">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.3</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * End synchronizing on 'obj'. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param obj The objet to end synchronizing on.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">OBJC_EXPORT  <span class="keyword">int</span> <span class="title">objc_sync_exit</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function">    <span class="title">OBJC_AVAILABLE</span><span class="params">(<span class="number">10.3</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">1.0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>进一步从实现文件中，我们可以得到的结论是：<code>objc_sync_enter()</code> 会为 <code>obj</code> 生成并关联一个递归锁，然后将临界区的内容加锁，临界区代码执行完后，调用 <code>objc_sync_exit()</code> 解锁。</p>
</li>
<li><p>NSLock</p>
<p>NSLock 是对 <code>pthread_mutex_t</code> 的对象封装。</p>
</li>
</ul>
<p><strong>NOTE</strong>：除了同步锁，其他几个锁都是不可重入锁，如果重复加同一个锁，就会造成死锁，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br></pre></td></tr></table></figure>
<p>这样锁变量将永远不会处于解锁状态导致死锁。</p>
<h3 id="四、GCD-中的多线程编程"><a href="#四、GCD-中的多线程编程" class="headerlink" title="四、GCD 中的多线程编程"></a>四、GCD 中的多线程编程</h3><p>GCD 是对 POSIX 线程的高级封装，它会帮我们管理线程的生命周期，我们只需要将要执行的任务（block）以同步或者异步的形式添加进队列中，GCD 会选择合适的线程去执行任务。队列就是一种先入先出的数据结构，因此，添加进队列中的任务的执行顺序即为入队的顺序，而执行完成的顺序，取决于线程的调度、任务的长短、队列是串行还是并发、同步任务还是异步任务等等。</p>
<p><strong>NOTE</strong>：我们所有没有添加进队列的任务其实就是主线程在执行，我们可以将这些任务理解为同步串行任务，也就是所有的函数顺序执行，当前函数执行完才会执行下一个，这些任务包含 <code>dispatch_sync()</code> 和 <code>dispatch_async()</code>。大概的模型就是这样（忽略任务之间空隙）：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5314152-b3a0b67c91fe605f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>下面的讨论的队列均不包含主队列。我们将 <code>dispatch_sync()</code> 和 <code>dispatch_async()</code> 定义为一个 Task。并且将上下文切换以并行（伪并行）的形式描述。</p>
<h4 id="4-1-同步串行"><a href="#4-1-同步串行" class="headerlink" title="4.1 同步串行"></a>4.1 同步串行</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.xm.test.serialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// Task1</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(serialQueue, ^&#123;</span><br><span class="line">	<span class="comment">// Task2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task2"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [<span class="built_in">NSThread</span> isMainThread]); </span><br><span class="line">    <span class="comment">// log result is 1.</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Task3</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">	<span class="comment">// task4</span></span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Task4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// task5</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task5"</span>);</span><br></pre></td></tr></table></figure>
<p>此时这段代码的执行情况理论上应该为：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5314152-7de31071475c4fa6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在时间 T1 处切换到子线程执行加入 <code>serialQueue</code> 中的同步任务 <code>Task2</code>，直到任务执行完，切回主线程继续执行 <code>Task3</code>。同步任务阻塞主线程的原因是：主线程在等待 <code>dispatch_sync()</code> 函数返回，而 <code>dispatch_sync()</code> 函数在等待 <code>Task2</code> 返回，因此，即使同步任务由子线程完成，它依然会阻塞主线程。实际上，GCD 会帮我们做一些优化：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5314152-43745da8a0d48a26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>GCD 会直接返回 <code>dispatch_sync()</code> 函数，然后在主线程执行同步任务，这样就避免了多余的上下文切换的开销。</p>
<h4 id="4-2-同步并发"><a href="#4-2-同步并发" class="headerlink" title="4.2 同步并发"></a>4.2 同步并发</h4><p>同样是上面的示例代码，我们将串行队列，替换为并发队列：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.xm.test.concurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">// Task1</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">	<span class="comment">// Task2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task2"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [<span class="built_in">NSThread</span> isMainThread]); </span><br><span class="line">    <span class="comment">// log result is 1.</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Task3</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(concurrentQueue, ^&#123;</span><br><span class="line">	<span class="comment">// task4</span></span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Task4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// task5</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task5"</span>);</span><br></pre></td></tr></table></figure>
<p>此时，理论上的任务的执行方式为：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5314152-0daa148ae166e0cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>实际上 GCD 仍然会做上面的优化：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5314152-f23c4a04836b7903.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>即使是添加进并发队列的同步任务也会阻塞主线程，理由同上，因此，GCD 同样会将任务放到主线程去执行，避免了上下文切换的开销。</p>
<h4 id="4-3-异步串行"><a href="#4-3-异步串行" class="headerlink" title="4.3 异步串行"></a>4.3 异步串行</h4><p>我们现在将 4.1 中的同步方法改成异步方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"com.xm.test.serialQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="comment">// Task1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">	<span class="comment">// Task2 (可使用 for 循环模拟线程阻塞，看代码的输出顺序)</span></span><br><span class="line">	<span class="comment">// for (int i = 0; i &lt; 1000; ++i) &#123;&#125;</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task2"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [<span class="built_in">NSThread</span> isMainThread]); </span><br><span class="line">    <span class="comment">// log result is 0.</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Task3</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">	<span class="comment">// task4</span></span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Task4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// task5</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task5"</span>);</span><br></pre></td></tr></table></figure>
<p>主线程会在执行 <code>dispatch_async()</code> 时将任务加入 <code>serialQueue</code> 然后立刻返回执行下一条指令，同时调度子线程去执行加入队列中的任务，此时任务执行完成的时机依赖于调度程序的调度、任务的长短和加入队列中的顺序。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5314152-e70e3cc5db0846cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>NOTE</strong>：当该示例中的队列为主队列时，异步任务会添加进主队列的队尾，当主线程执行完主队列中其他任务时，才会去执行该任务。</p>
<h4 id="4-4-异步并发"><a href="#4-4-异步并发" class="headerlink" title="4.4 异步并发"></a>4.4 异步并发</h4><p>将 4.2 中的同步改为异步：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> concurrentQueue = dispatch_queue_create(<span class="string">"com.xm.test.concurrentQueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="comment">// Task1</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">	<span class="comment">// Task2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Task2"</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, [<span class="built_in">NSThread</span> isMainThread]); </span><br><span class="line">    <span class="comment">// log result is 0.</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Task3</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">	<span class="comment">// task4</span></span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"Task4"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// task5</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Task5"</span>);</span><br></pre></td></tr></table></figure>
<p>此时：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5314152-1710825fa0fa14cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>任务执行完成的顺序仍然依赖于调度程序分配的时间片、任务的长度等。<code>Task4</code> 会在 <code>dispatch_async2()</code> 执行后加入队列，GCD 会分配合适的线程去执行它。</p>
<h4 id="4-5-死锁"><a href="#4-5-死锁" class="headerlink" title="4.5 死锁"></a>4.5 死锁</h4><p>同步任务是造成死锁的主要原因，假如将 4.1 中的串行队列换成主队列的话，此时主队列在等待 <code>dispatch_sync()</code> 返回，<code>dispatch_sync()</code> 在等待 <code>block</code> 返回，block 被添加进主队列，并且在 <code>dispatch_sync()</code> 之后，因此，<code>dispatch_sync()</code> 返回后才能执行 block，这样就造成了 <code>dispatch_sync()</code> 和 block 之间的循环等待而造成死锁（只有添加进非主队列的同步任务，GCD 才会优化）。</p>
<p><strong>NOTE：</strong>GCD 造成的死锁不是<a href="https://zhangxiaom.github.io/2018/06/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E8%BF%9B%E7%A8%8B/" target="_blank" rel="noopener">并发编程之进程</a>中所描述的进程同步造成的死锁，也就是，这里的死锁不是多个线程争夺共享资源造成的死锁，而是由于同步任务和串行队列的性质造成的死锁，两者都是造成死锁的充分非必要条件。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在实际工作中，并发带来的问题是比较让人头痛的问题。本文以最简单的模型分析并发时多个线程协同工作的原理，当然必须理解原理才能在工作中更好的分析并发带来的问题。推荐一本书 《现代操作系统》，虽然它不讲 GCD，但是看了它再去理解 GCD 有种豁然开朗的感觉。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/07/13/runtime管理weak引用的方式/" class="prev">上一篇</a><a href="/2018/07/01/dyld-和链接/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="http://yoursite.com">zmc</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>